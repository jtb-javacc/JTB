Notes sur JTB
- jtbgram.jtb a été écrite à partir de JavaCC.jj de la version JavaCC 4.2, et adaptée (voir commentaires ModMMa) :
  * renommages de noms de classes et de productions
  * ajout de la syntaxe try-ExpansionChoices-catch-finally (ExpansionUnitInTCF) 
  * ajout des syntaxes ! et % pour ne pas générer des nœuds JTB
  * corrections sur la grammaire java
  * ajout des options par défaut
- Token.java a été modifiée pour l'ajout de GTToken (possibilité prévue dans Token, impliquant une sauvegarde et une copie)
- parser.JavaFiles, parser.OtherFilesGen, parser.ParseGen & utils.JavaFileGenerator ont été modifiées pour GTToken
   (commentaires : // ModMMa : modified for Token.template with GTToken),
   mais en fait cela ne sert à rien parce c'est JavaCC et non JTB qui génère Token.java (via parser.OtherFilesGen.java), 
   et bien que le ficher /templates/Token.template n'existe pas cela ne se voit pas car les 4 classes ne sont pas utilisées
- dans les specials : on a les commentaires de fin de ligne reportés à la ligne suivante, et les premiers sauts de ligne bouffés
   il faudrait que JavaCC passe au schéma trailing / orphan / leading comme dans JavaParser,
   ou bien il faudrait gérer dans NodeToken le delta des lignes avec le token précédent
   
Notes sur JavaCC
- les essais String.intern() dans ParseursForms sur SimpleCharStream.GetImage(), en construisant une TreeMap des littéraux déclarés dans la grammaire (récupérés de xxxConstants) (les littéraux sont automatiquement internés par le compilateur et sont en très grand nombre dans les statistiques ; cf. https://shipilev.net/jvm/anatomy-quarks/10-string-intern/ -XX:+PrintStringTableStatistics -XX:StringTableSize) ne sont pas concluants (il faut profiler SANS l'enregistrement des allocations sinon les temps sont trop distordus) : le temps passé dans GetImage contrebalance le temps gagné sur les allocations ; il faudrait regarder, dans le TokenManager, jjFillToken() et jjstrLiteralImages qui ne contient que les littéraux "uniques" (si un Regexpr est un OR de littéraux, style < EOL : "\r\n" | "\r" | "\n" >, le littéral est retrouvé dans GetImage et n'est pas interné ; s'il c'est un seul littéral, style < AT : "@" >, il est récupéré du tableau jjstrLiteralImages et est donc automatiquement interné) ; il faudrait voir à étendre ce mécanisme

Génération avec des templates de fichiers
- ajouter des options pour indiquer les fichiers à générer
- DepthFirst Visitors : 
  * à fixer par JTB :
    $ noms des classes et interfaces de base : fait
  * à laisser au choix de l'utilisateur :
    $ visitorDir JTB_VD/JTB_VP fait & classesList (DFVG)
    $ noms des classes et interfaces des visiteurs, n, n., argu, depthLevel, jtbrt_ (default dans Globals)
    $ options prefix/suffix/package/directory/superclass/jb.out.jj (changeable dans Globals)
    $ comment : permettre de surcharger Globals ou autre ?
- voir pour les commentaires initiaux (generated by, date, nom du template, version de JTB, ...)
 
Idées futuristes sur JTB/JavaCC
- revoir les concepts et voir où la programmation fonctionnelle et une meilleure approche objet peuvent simplifier les choses
- voir à ajouter dans la grammaire la gestion des versions d'une grammaire
- voir à ajouter la fonctionnalité de recouvrement de tokens (ex : mot réservé qui peut être un identifieur) (pour ne pas être obligés de rajouter des OR)
- revoir la génération JavaCC pour les méthodes spagettis et l'influence des changements d'états lexicaux sur les performances
- revoir la génération JavaCC pour les switchs générés (tableaux à double indirection pour lookups performants, ...)
- revoir la génération des infos de debug (lookahead)
- revoir la structure de la grammaire pour maximiser le réemploi des grammaires : 1 source grammaire (voire 2 sources lexer/parser), n sources options génération (noeuds à générer ou non, visiteurs, Unicode, mono-multi thread, avec/sans debug, ...)
- voir de quoi on peut s'inspirer de XText (génération pour plugin, ...), JavaCC 21 (simplification dans la génération JavaCC, AST / parsers intégrés, ...), TreeSitter (?)
- voir à produire un table driven tokenmanager (comme javacc 8) et/ou génération avec templates FreeMarker/Velocity (avec le système 1.5.0 ou comme javacc 8 / 21)
- générer en une seule passe JTB+JavaCC
- produire des versions Kotlin, C, C++, JavaScript... (grammaires sources et parseurs cibles)
- voir à faire un intégré JTB/JavaCC (comme JavaCC 21) (une seule grammaire, génération ASTs style JTB ou JJTree et parsing en une seule fois)
- écrire une grammaire en pur java via des annotations (pour ne plus avoir à mettre à jour des plugins IDE)
- voir à faire un parser incrémental / fault tolerant
- voir à faire un LSP

A faire prochainement sur JTB
- voir pourquoi signature/* ne sont pas marqués dérivés
- tcf avec autres options
- tests exhaustifs sur suppression / ajout de noeuds
- changer le NodeToken pour qu'il référence le Token au lieu de copier ses propriétés (vérifier que les Tokens sont GCed bien avant les NodeTokens), ou mieux (?) faire hériter Token d'un NodeToken 
- supprimer les intern() dans makeNodeToken
- corriger le bug rencontré sur la 1.5.0 sur BindVariable du parser PL/SQL (mauvaise génération du jj annotation finale n11 = ... au lieu de n2 = ...)
- générer correctement les commentaires lorsque l'on utilise un noeud JAVACODE (%)
- ajouter la gestion du chaînage des parseurs, passer JTB en un parseur pur JTB et un parseur Java, mettre à jour la grammaire Java 13+
- corriger le type de retour lorsqu'il est qualifié par son package BNF et JavaCode productions a.b.Cd Cd() ...
- corriger le NPE sur syntaxe [ "x" ! ] ou [ Prod() ! ] ou [ Prod() ] sur une Prod() !
- changer la syntaxe ! par #void, % par #xyz, ajouter #xyz pour permettre la surcharge du noeud 
- ajouter une option pour le chaînage des NodeTokens comme pour les Tokens de JavaCC
- revoir la gestion des specials en visitant tous les identifieurs et en imprimant les specials à ce moment là
- voir à accepter les noms de production qui posent conflit, ex String
- voir le NPE dans les visiteurs lorsque le nœud n'est pas créé
- construire des exemples de grammaire avec des Lookahead dans Expansion et dans ExpansionUnit, et avec (<TK> | {})
- voir pourquoi les classes ne sont pas générées pour les productions orphelines
- voir les options par défaut jtb (options/wiki) et plugin ia/jd/tk true ou false ?
- mettre à jour le wiki (overview, // 1.5.0, et ajouter une doc plus complète, en particulier différences // JJT)
- mettre à jour le plugin maven
- choisir un repository maven pour publier jtb et son plugin maven
- écrire une doc pour target ant via une task java
- mettre des tests JUnit dans le build ?
- voir si corrections bugs JavaCC dont char e = 'é';
- voir les ajouts faits par FA ou à faire pour JavaCC 6+ et C++
- ajouter dans les tests que JTB fonctionne avec et sans les commentaires de debug
- ajouter dans les tests que JTB/JavaCC peut tourner en multi thread
- voir à ajouter des benchmarks jmh
- voir à améliorer les indicateurs de qualité
- voir les aspects sécurité

Fait sur JTB en 1.5.1
- corrigé des problèmes de génération de node (node choice, EUNS)
- changé le package de jtbgram.jtb pour l'aligner avec la déclaration interne
- corrigé la génération des imports pour différentes combinaisons d'options
- amélioré la génération build.xml des grammaires sans options pour les aligner avec la génération Eclipse
- ajouté la grammaire sans package
- ajouté les annotations optionnelles dans ExpansionUnitTCF
- supprimé le GTToken et le NodeToken.tokenImage
- revu les .gitignore

Fait sur JTB en 1.5.0
- créé les pages wiki, mis à jour les différents fichiers de docs et autres
- passé en JDK 1.8
- ajouté des annotations pour supprimer des warnings et utilisé des try-with-resource
- supprimé la classe JTBToolkit générée avec le parseur
- modifié AllocationExpression pour prendre en compte EmptyTypeArguments
- remis les serialVersionUID au numéro de version JTBToolkit
- renommé en Unused les classes (venant du parseur JavaCC) non utilisées pour la génération JTB
- ajouté la génération de la classe NodeConstants.java
- ajouté l'option et la génération des classe et interface et appels de méthodes node scope hook dans les BNFProduction
- ajouté la génération d'une signature de contrôle dans les commentaires des classes et méthodes visit, dans NodeConstants,
   et d'une annotation sur les méthodes visit des visiteurs par défaut, et d'une classe d'annotation et de processeur d'annotation, 
   et d'une option pour supprimer la génération de ces annotations
- passé le projet en UTF-8, enrichi le pom.xml
- ajouté l'option novis (ne pas générer les visiteurs)
- ajouté la génération des méthodes children et de l'option associée
- migré les listes de ClassInfo dans FieldInfo, changé les for iterator en enhanced for
- supprimé l'option scheme
- revu certaines javadoc
- supprimé la classe InternalError et la méthode inutilisée de FieldNameGenerator qui l'utilisait seule
- ajouté l'appel à une méthode d'une classe externe pour la génération de classes
- refondu la génération des visiteurs avec tous les types possibles pour les arguments et le retour
- restructuré / renommé les classes et packages
- passé en structure maven (generate / tests)
- passé en stdout + stderr
- passé la génération des user classes en parallèle
- supprimé les FileExistsException
- passé en non static en gardant do_main static
- passé UCDetector et corrigé ou mis en commentaires les final et modifiers
- ajouté l'appel à System.exit(in) dans JTB.main(String[]) (pour ant)
- modifié la gestion des special tokens : JTB_TK stocke dans les nœuds JTB les special tokens JavaCC et JTB_TKJJ les imprime 
- ajouté final dans ExpansionUnitTCF's catch
- ajouté dans le build.xml une tâche d'ajout des SuppressWarnings pour jtbgram.jtb, et changé les depend en antcall
- mis l'énumération des langues et des extensions
- revu la gestion des nœuds ne devant pas être créés
- créé le data model pour FreeMarker
- rajouté la compilation  et l'exécution de grammaires de test dans build.xml
- ajouté les @SuppressWarnings lorsque les commentaires javadoc ne sont pas demandés et pour les cas unused
- corrigé une partie des lignes blanches manquantes dans les specials
- ajouté l'analyse de la couverture de tests et la production des rapports via JaCoCo
- ajouté les exemples de JJTree et leur équivalent JTB
- enrichi les grammaires de tests
- restructuré / simplifié le build.xml
- corrigé la mauvaise génération du nom des méthodes lors d'un préfixe / suffixe (JTB_P) et d'une suppression de la génération des nœuds (!)
- corrigé la mauvaise génération des types de retour tableaux
- passé Expression dans semantic lookahead en optionnel
- passé releases.notes, HowTo.txt en md, complété README.md
- passé le wiki en md
- testé avec JavaCC 7.0.10
- supprimé la génération des NodeTCF et des TCF dans les visiteurs
- afficher les paths générés en absolu, sans les ../..
- ajouté un test avec ("xxx"|{}) (issue #86)
- modifié les méthodes dépréciées
- généré correctement les imports si pas d'options
- changé le package de jtbgram.jtb (EDU.purdue.jtb.parser) pour l'aligner sur celui déclaré dans la grammaire

Fait sur JTB en 1.4.13
- ajouté les options dans la grammaire pour une génération correcte directe sous Eclipse
- ajouté des commentaires dans le fichier Token.java.save
- corrigé le problème d'espace sur les modifiers de déclaration de variables locales (Annotator:VariableModifiers)

Fait sur JTB en 1.4.12 (FA)
- modifications fichiers XML et autres pour build et maven
- passage sous Git / GitHub

Fait sur JTB en 1.4.11
- mis des espaces entre les '<' et '>' et les noms des tokens pour qu'ils s'affichent correctement dans les javadoc (< AMONG > au lieu de <AMONG>)
- corrigé les conditions d'apparition du "warning:  Empty choice : a NodeChoice with a 'null' choice member ..."
- corrigé les numéros de colonne dans les messages

Fait sur JTB en 1.4.10
- ajouté la méthode JTB.do_main() et modifié les méthodes Messages.hardErr() pour ne plus appeler System.exit()

Fait sur JTB en 1.4.9
- rien

Fait sur JTB en 1.4.8.fix_a
- corrigé régression (Annotator#bnfFinalActions())

Fait sur JTB en 1.4.8
- null choice for an empty choice
- contrôler qu'un Javacode n'est pas déclaré 2 fois
- voir bug 3164860
- syntaxe "%" sur Javacode
- corriger préfixe / suffixe dans lookahead
- changé dans NodeToken.java  public ArrayList<NodeToken> specialTokens; ->   public List<NodeToken> specialTokens;
- ajouté AnnotationTypeDeclaration() dans ClassOrInterfaceBodyDeclaration()
- ajouté ReferenceType() dans ExplicitConstructorInvocation()
- ajouté des annotations @Override et @SuppressWarnings("unused") dans la génération des visiteurs
- ajouté node_descriptor() et node_descriptor_expression() et modifié JavaCodeProduction, BNFProduction,
   Expansion & MethodDeclaration pour autoriser un node descriptor
- corrigé la non mise en commentaires des specials dans les options JTB à la génération
- ajouté la génération de noms courts pour les variables intermédiaires
- modifié le message de warning sur les LOOKAHEAD ignorés (car ils peuvent ne pas être ignorés en fait)
- corrigé la génération des blocs java (Annotator visit LocalVariableDeclaration)
- corrigé le LOOKAHEAD dans ExplicitConstructorInvocation
- ajouté la génération des annotations override
- amélioré la gestion des specials
- passé les versions de 4.2.j.m à 5.0
- passé de implements constantes à import static
- renommé TreeWalkerOp en ITreeWalkerOp
- enlevé le membre ordinal de RegularExpression_ qui cachait celui de la superclass Expansion_
- supprimé les warnings partout sauf dans certaines grosses classes de parser

