/* Generated By:JavaCC: Do not edit this line. JTBParser.java */
package EDU.purdue.jtb.parser;

import java.util.List;
import java.util.ArrayList;
import EDU.purdue.jtb.syntaxtree.*;


/**
 * This file contains the code for JavaCCParser generated
 * by JavaCCParser itself.
 */
// MMa : adapted from JavaCC.jj to fit to JTB class name
public class JTBParser extends JavaCCParserInternals implements JTBParserConstants {

  /*
   * JTB generated return variables declarations
   */

  /** Return variable for {@link #LocalLookahead} production */
  Lookahead jtbrt_LocalLookahead;

  /** Return variable for {@link #IdentifierAsString} production */
  String jtbrt_IdentifierAsString;

  /** Return variable for {@link #JavaIdentifier} production */
  Token jtbrt_JavaIdentifier;

  /** Return variable for {@link #Modifiers} production */
  int jtbrt_Modifiers;

  /** Return variable for {@link #IntegerLiteral} production */
  int jtbrt_IntegerLiteral;

  /** Return variable for {@link #BooleanLiteral} production */
  boolean jtbrt_BooleanLiteral;

  /** Return variable for {@link #StringLiteral} production */
  String jtbrt_StringLiteral;

  /**
   * The name of the parser class.
   */
  String parser_class_name;

  /**
   * This flag is set to true when the part between PARSER_BEGIN and
   * PARSER_END is being parsed.
   */
  boolean processing_cu = false;

  /**
   * The level of class nesting.
   */
  int class_nesting = 0;

  /**
   * This int variable is incremented while parsing local lookaheads.
   * Hence it keeps track of *syntactic* lookahead nesting.
   * This is used to provide warnings when actions and nested lookaheads
   * are used in syntactic lookahead productions.  This is to prevent
   * typos such as leaving out the comma in LOOKAHEAD( foo(), {check()} ).
   */
  int inLocalLA = 0;

  /**
   * Set to true when the parser is within an action.
   */
  boolean inAction = false;

  /**
   * This flag keeps track of whether or not return and throw
   * statements have been patched during the parsing of a production.
   * The value of this flag is assigned the field with the same
   * name in BNFProduction_.java.
   */
  boolean jumpPatched = false;

  /*
   * Returns true if the next token is not in the FOLLOW list of "expansion".
   * It is used to decide when the end of an "expansion" has been reached.
   */
  private boolean notTailOfExpansionUnit() {
    final Token t = getToken(1);
    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET)
      return false;
    return true;
  }

  /**
   * Class to hold modifiers.
   */
  static public final class ModifierSet {

    /* Definitions of the bits in the modifiers field */
    public static final int M_PUBLIC = 0x0001;

    public static final int M_PROTECTED = 0x0002;

    public static final int M_PRIVATE = 0x0004;

    public static final int M_ABSTRACT = 0x0008;

    public static final int M_STATIC = 0x0010;

    public static final int M_FINAL = 0x0020;

    public static final int M_SYNCHRONIZED = 0x0040;

    public static final int M_NATIVE = 0x0080;

    public static final int M_TRANSIENT = 0x0100;

    public static final int M_VOLATILE = 0x0200;

    public static final int M_STRICTFP = 0x1000;

    /* A set of accessors that indicate whether the specified modifier is in the set */
    public boolean isPublic(int modifiers) {
      return (modifiers & M_PUBLIC) != 0;
    }

    public boolean isProtected(int modifiers) {
      return (modifiers & M_PROTECTED) != 0;
    }

    public boolean isPrivate(int modifiers) {
      return (modifiers & M_PRIVATE) != 0;
    }

    public boolean isStatic(int modifiers) {
      return (modifiers & M_STATIC) != 0;
    }

    public boolean isAbstract(int modifiers) {
      return (modifiers & M_ABSTRACT) != 0;
    }

    public boolean isFinal(int modifiers) {
      return (modifiers & M_FINAL) != 0;
    }

    public boolean isNative(int modifiers) {
      return (modifiers & M_NATIVE) != 0;
    }

    public boolean isStrictfp(int modifiers) {
      return (modifiers & M_STRICTFP) != 0;
    }

    public boolean isSynchronized(int modifiers) {
      return (modifiers & M_SYNCHRONIZED) != 0;
    }

    public boolean isTransient(int modifiers) {
      return (modifiers & M_TRANSIENT) != 0;
    }

    public boolean isVolatile(int modifiers) {
      return (modifiers & M_VOLATILE) != 0;
    }

    /* Removes the given modifier */
    static int removeModifier(int modifiers, int mod) {
      return modifiers & ~mod;
    }
  }

/************************************************
 * THE JAVACC GRAMMAR SPECIFICATION STARTS HERE *
 ************************************************/
// MMa : changed all javacc_input into JavaCCInput to conform to class name convention
  final public JavaCCInput JavaCCInput() throws ParseException {
  // --- JTB generated node declarations ---
  JavaCCOptions n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  IdentifierAsString n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  CompilationUnit n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  IdentifierAsString n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeList n16 = new NodeList();
  Production n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  // --- user BNFProduction java block ---
  String id1, id2;
  initialize();
  // MMa : added to JavaCC as called in parser.Main in Javacc 4.2
  Options.init();
    n0 = JavaCCOptions();
    n2 = jj_consume_token(_PARSER_BEGIN);
    n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(LPAREN);
    n3 = JTBToolkit.makeNodeToken(n4);
    n5 = IdentifierAsString();
    id1 = jtbrt_IdentifierAsString;
    addcuname(id1);
    n7 = jj_consume_token(RPAREN);
    n6 = JTBToolkit.makeNodeToken(n7);
    processing_cu = true;
    parser_class_name = id1;
    n8 = CompilationUnit();
    processing_cu = false;
    n10 = jj_consume_token(_PARSER_END);
    n9 = JTBToolkit.makeNodeToken(n10);
    n12 = jj_consume_token(LPAREN);
    n11 = JTBToolkit.makeNodeToken(n12);
    n13 = IdentifierAsString();
    id2 = jtbrt_IdentifierAsString;
    compare(getToken(0), id1, id2);
    n15 = jj_consume_token(RPAREN);
    n14 = JTBToolkit.makeNodeToken(n15);
    label_1:
    while (true) {
      n17 = Production();
      n16.addNode(n17);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case VOID:
      case LT:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    n16.nodes.trimToSize();
    n19 = jj_consume_token(0);
    n19.beginColumn++;
    n19.endColumn++;
    { n18 = JTBToolkit.makeNodeToken(n19); }
    {if (true) return new JavaCCInput(n0, n1, n3, n5, n6, n8, n9, n11, n13, n14, n16, n18);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all javacc_options into JavaCCOptions to conform to class name convention
  final public JavaCCOptions JavaCCOptions() throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeListOptional n6 = null;
  OptionBinding n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    if (getToken(1).image.equals("options")) {
      n6 = new NodeListOptional();
      n1 = new NodeSequence(4);
      n3 = jj_consume_token(140);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n5 = jj_consume_token(LBRACE);
      n4 = JTBToolkit.makeNodeToken(n5);
      n1.addNode(n4);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case STATIC:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        n7 = OptionBinding();
        n6.addNode(n7);
      }
      n6.nodes.trimToSize();
      n1.addNode(n6);
      n9 = jj_consume_token(RBRACE);
      n8 = JTBToolkit.makeNodeToken(n9);
      n1.addNode(n8);
      n0.addNode(n1);
    } else {
      ;
    }
    Options.normalize();
    {if (true) return new JavaCCOptions(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all option_binding into OptionBinding to conform to class name convention
  final public OptionBinding OptionBinding() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeChoice n11 = null;
  IntegerLiteral n12 = null;
  BooleanLiteral n13 = null;
  StringLiteral n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  // --- user BNFProduction java block ---
  String option_name;
  int int_val;
  boolean bool_val;
  String string_val;
  Token t = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n2 = jj_consume_token(IDENTIFIER);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 4);
      break;
    case _LOOKAHEAD:
      n4 = jj_consume_token(_LOOKAHEAD);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 4);
      break;
    case _IGNORE_CASE:
      n6 = jj_consume_token(_IGNORE_CASE);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 4);
      break;
    case STATIC:
      n8 = jj_consume_token(STATIC);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3, 4);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    option_name = t.image;
    n10 = jj_consume_token(ASSIGN);
    n9 = JTBToolkit.makeNodeToken(n10);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      n12 = IntegerLiteral();
        int_val = jtbrt_IntegerLiteral;
        Options.setInputFileOption(t, getToken(0), option_name, new Integer(int_val));
        n11 = new NodeChoice(n12, 0, 3);
      break;
    case FALSE:
    case TRUE:
      n13 = BooleanLiteral();
        bool_val = jtbrt_BooleanLiteral;
        Options.setInputFileOption(t, getToken(0), option_name, new Boolean(bool_val));
        n11 = new NodeChoice(n13, 1, 3);
      break;
    case STRING_LITERAL:
      n14 = StringLiteral();
        string_val = jtbrt_StringLiteral;
        Options.setInputFileOption(t, getToken(0), option_name, string_val);
        n11 = new NodeChoice(n14, 2, 3);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n16 = jj_consume_token(SEMICOLON);
    n15 = JTBToolkit.makeNodeToken(n16);
    {if (true) return new OptionBinding(n0, n9, n11, n15);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all production into Production to conform to class name convention
  final public Production Production() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  JavaCodeProduction n1 = null;
  RegularExprProduction n2 = null;
  TokenManagerDecls n3 = null;
  BNFProduction n4 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _JAVACODE:
      n1 = JavaCodeProduction();
      n0 = new NodeChoice(n1, 0, 4);
      break;
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case LT:
      n2 = RegularExprProduction();
      n0 = new NodeChoice(n2, 1, 4);
      break;
    case _TOKEN_MGR_DECLS:
      n3 = TokenManagerDecls();
      n0 = new NodeChoice(n3, 2, 4);
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case VOID:
    case IDENTIFIER:
      n4 = BNFProduction();
      n0 = new NodeChoice(n4, 3, 4);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Production(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all JavaCodeProduction into JavaCodeProduction_ (JavaCC specific class)
// MMa : changed all javacode_production into JavaCodeProduction to conform to class name convention
  final public JavaCodeProduction JavaCodeProduction() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  AccessModifier n2 = null;
  ResultType n3 = null;
  IdentifierAsString n4 = null;
  FormalParameters n5 = null;
  NodeOptional n6 = new NodeOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  Name n10 = null;
  NodeListOptional n11 = null;
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  Name n15 = null;
  Block n16 = null;
  // --- user BNFProduction java block ---
  JavaCodeProduction_ p = new JavaCodeProduction_();
  String lhs;
  Token t = getToken(1);
  p.setFirstToken(t);
  List<Token> excName;
  p.setThrowsList(new ArrayList<List<Token>>());
  p.setLine(t.beginLine);
  p.setColumn(t.beginColumn);
    n1 = jj_consume_token(_JAVACODE);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = AccessModifier(p);
    n3 = ResultType(p.getReturnTypeTokens());
    n4 = IdentifierAsString();
    lhs = jtbrt_IdentifierAsString;
    p.setLhs(lhs);
    n5 = FormalParameters(p.getParameterListTokens());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      n11 = new NodeListOptional();
      n7 = new NodeSequence(5);
      n9 = jj_consume_token(THROWS);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      excName = new ArrayList<Token>();
      n10 = Name(excName);
      n7.addNode(n10);
      p.getThrowsList().add(excName);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
        n12 = new NodeSequence(4);
        excName = new ArrayList<Token>();
        n14 = jj_consume_token(COMMA);
        n13 = JTBToolkit.makeNodeToken(n14);
        n12.addNode(n13);
        n15 = Name(excName);
        n12.addNode(n15);
        p.getThrowsList().add(excName);
        n11.addNode(n12);
      }
      n11.nodes.trimToSize();
      n7.addNode(n11);
      n6.addNode(n7);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    n16 = Block(p.getCodeTokens());
    p.setLastToken(getToken(0));
    addproduction(p);
    {if (true) return new JavaCodeProduction(n0, n2, n3, n4, n5, n6, n16);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all BNFProduction into BNFProduction_ (JavaCC specific class)
// MMa : changed all bnf_production into BNFProduction to conform to class name convention
  final public BNFProduction BNFProduction() throws ParseException {
  // --- JTB generated node declarations ---
  AccessModifier n0 = null;
  ResultType n1 = null;
  IdentifierAsString n2 = null;
  FormalParameters n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  Name n8 = null;
  NodeListOptional n9 = null;
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  Name n13 = null;
  NodeOptional n14 = new NodeOptional();
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  Block n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  ExpansionChoices n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  // --- user BNFProduction java block ---
  BNFProduction_ p = new BNFProduction_();
  Container c = new Container();
  Token t = getToken(1);
  p.setFirstToken(t);
  List<Token> excName;
  String lhs;
  p.setThrowsList(new ArrayList<List<Token>>());
  p.setLine(t.beginLine);
  p.setColumn(t.beginColumn);
  jumpPatched = false;
    n0 = AccessModifier(p);
    n1 = ResultType(p.getReturnTypeTokens());
    n2 = IdentifierAsString();
    lhs = jtbrt_IdentifierAsString;
    p.setLhs(lhs);
    n3 = FormalParameters(p.getParameterListTokens());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      n9 = new NodeListOptional();
      n5 = new NodeSequence(5);
      n7 = jj_consume_token(THROWS);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      excName = new ArrayList<Token>();
      n8 = Name(excName);
      n5.addNode(n8);
      p.getThrowsList().add(excName);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        n10 = new NodeSequence(4);
        excName = new ArrayList<Token>();
        n12 = jj_consume_token(COMMA);
        n11 = JTBToolkit.makeNodeToken(n12);
        n10.addNode(n11);
        n13 = Name(excName);
        n10.addNode(n13);
        p.getThrowsList().add(excName);
        n9.addNode(n10);
      }
      n9.nodes.trimToSize();
      n5.addNode(n9);
      n4.addNode(n5);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
      n16 = jj_consume_token(BANG);
      n15 = JTBToolkit.makeNodeToken(n16);
      n14.addNode(n15);
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    n18 = jj_consume_token(COLON);
    n17 = JTBToolkit.makeNodeToken(n18);
    n19 = Block(p.getDeclarationTokens());
    n21 = jj_consume_token(LBRACE);
    n20 = JTBToolkit.makeNodeToken(n21);
    n22 = ExpansionChoices(c);
    n24 = jj_consume_token(RBRACE);
    n23 = JTBToolkit.makeNodeToken(n24);
    t = n24;
    p.setLastToken(t);
    p.setJumpPatched(jumpPatched);
    production_addexpansion(p, (Expansion_)(c.member));
    addproduction(p);
    {if (true) return new BNFProduction(n0, n1, n2, n3, n4, n14, n17, n19, n20, n22, n23);}
    throw new Error("Missing return statement in function");
  }

  final public AccessModifier AccessModifier(NormalProduction p) throws ParseException {
  // --- JTB generated node declarations ---
  NodeListOptional n0 = new NodeListOptional();
  NodeChoice n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  // --- user BNFProduction java block ---
  Token t = null;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINAL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        n3 = jj_consume_token(PUBLIC);
        n2 = JTBToolkit.makeNodeToken(n3);
        t = n3;
        n1 = new NodeChoice(n2, 0, 4);
        break;
      case PROTECTED:
        n5 = jj_consume_token(PROTECTED);
        n4 = JTBToolkit.makeNodeToken(n5);
        t = n5;
        n1 = new NodeChoice(n4, 1, 4);
        break;
      case PRIVATE:
        n7 = jj_consume_token(PRIVATE);
        n6 = JTBToolkit.makeNodeToken(n7);
        t = n7;
        n1 = new NodeChoice(n6, 2, 4);
        break;
      case FINAL:
        n9 = jj_consume_token(FINAL);
        n8 = JTBToolkit.makeNodeToken(n9);
        n1 = new NodeChoice(n8, 3, 4);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n0.addNode(n1);
    }
    n0.nodes.trimToSize();
    if (t != null) {
      p.setAccessMod(t.image);
    }
    {if (true) return new AccessModifier(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all regular_expr_production into RegularExprProduction to conform to class name convention
  final public RegularExprProduction RegularExprProduction() throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeChoice n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeListOptional n14 = null;
  NodeSequence n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  RegExprKind n22 = null;
  NodeOptional n23 = new NodeOptional();
  NodeSequence n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeToken n31 = null;
  Token n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  RegExprSpec n35 = null;
  NodeListOptional n36 = new NodeListOptional();
  NodeSequence n37 = null;
  NodeToken n38 = null;
  Token n39 = null;
  RegExprSpec n40 = null;
  NodeToken n41 = null;
  Token n42 = null;
  // --- user BNFProduction java block ---
  TokenProduction p = new TokenProduction();
  List<String> states;
  Token t = p.firstToken = getToken(1);
  p.setLine(t.beginLine);
  p.setColumn(t.beginColumn);
    /* Set p.lexStates assuming there is no lexical state specified, and then override if necessary */
    p.lexStates = new String[]{ "DEFAULT" };
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      n14 = new NodeListOptional();
      if (jj_2_1(2)) {
        n2 = new NodeSequence(4);
        n4 = jj_consume_token(LT);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n6 = jj_consume_token(STAR);
        n5 = JTBToolkit.makeNodeToken(n6);
        n2.addNode(n5);
        n8 = jj_consume_token(GT);
        n7 = JTBToolkit.makeNodeToken(n8);
        n2.addNode(n7);
        p.lexStates = null;
        n1 = new NodeChoice(n2, 0, 2);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
        n9 = new NodeSequence(7);
          n11 = jj_consume_token(LT);
        n10 = JTBToolkit.makeNodeToken(n11);
        n9.addNode(n10);
        states = new ArrayList<String>();
          n13 = jj_consume_token(IDENTIFIER);
        n12 = JTBToolkit.makeNodeToken(n13);
        t = n13;
        n9.addNode(n12);
        states.add(t.image);
          label_6:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[12] = jj_gen;
              break label_6;
            }
          n15 = new NodeSequence(3);
            n17 = jj_consume_token(COMMA);
          n16 = JTBToolkit.makeNodeToken(n17);
          n15.addNode(n16);
            n19 = jj_consume_token(IDENTIFIER);
          n18 = JTBToolkit.makeNodeToken(n19);
          t = n19;
          n15.addNode(n18);
          states.add(t.image);
          n14.addNode(n15);
          }
        n14.nodes.trimToSize();
        n9.addNode(n14);
          n21 = jj_consume_token(GT);
        n20 = JTBToolkit.makeNodeToken(n21);
        n9.addNode(n20);
        p.lexStates = new String[states.size()];
        for (int i = 0; // modified MMa : workaround for Eclipse plugin color syntax problem
        //      i < states.size();
        i != states.size(); i++) {
          p.lexStates[i] = states.get(i);
        }
        n1 = new NodeChoice(n9, 1, 2);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      n0.addNode(n1);
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    n22 = RegExprKind(p);
    if (p.kind != TokenProduction.TOKEN && Options.getUserTokenManager()) {
      JavaCCErrors.warning(getToken(0), "Regular expression is being treated as if it were a TOKEN since option USER_TOKEN_MANAGER has been set to true.");
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      n24 = new NodeSequence(4);
      n26 = jj_consume_token(LBRACKET);
      n25 = JTBToolkit.makeNodeToken(n26);
      n24.addNode(n25);
      n28 = jj_consume_token(_IGNORE_CASE);
      n27 = JTBToolkit.makeNodeToken(n28);
      t = n28;
      n24.addNode(n27);
      n30 = jj_consume_token(RBRACKET);
      n29 = JTBToolkit.makeNodeToken(n30);
      n24.addNode(n29);
      p.ignoreCase = true;
      if (Options.getUserTokenManager()) {
        JavaCCErrors.warning(t, "Ignoring \u005c"IGNORE_CASE\u005c" specification since option USER_TOKEN_MANAGER has been set to true.");
      }
      n23.addNode(n24);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    n32 = jj_consume_token(COLON);
    n31 = JTBToolkit.makeNodeToken(n32);
    n34 = jj_consume_token(LBRACE);
    n33 = JTBToolkit.makeNodeToken(n34);
    n35 = RegExprSpec(p);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
      n37 = new NodeSequence(2);
      n39 = jj_consume_token(BIT_OR);
      n38 = JTBToolkit.makeNodeToken(n39);
      n37.addNode(n38);
      n40 = RegExprSpec(p);
      n37.addNode(n40);
      n36.addNode(n37);
    }
    n36.nodes.trimToSize();
    n42 = jj_consume_token(RBRACE);
    n41 = JTBToolkit.makeNodeToken(n42);
    t = n42;
    p.lastToken = t;
    addregexpr(p);
    {if (true) return new RegularExprProduction(n0, n22, n23, n31, n33, n35, n36, n41);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all token_manager_decls into TokenManagerDecls to conform to class name convention
  final public TokenManagerDecls TokenManagerDecls() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  ClassOrInterfaceBody n4 = null;
  // --- user BNFProduction java block ---
  List<Token> decls = new ArrayList<Token>();
  Token t;
    n1 = jj_consume_token(_TOKEN_MGR_DECLS);
    n0 = JTBToolkit.makeNodeToken(n1);
    t = n1;
    n3 = jj_consume_token(COLON);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ClassOrInterfaceBody(false, decls);
    add_token_manager_decls(t, decls);
    {if (true) return new TokenManagerDecls(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all regexpr_kind into RegExprKind to conform to class name convention
  final public RegExprKind RegExprKind(TokenProduction p) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _TOKEN:
      n2 = jj_consume_token(_TOKEN);
      n1 = JTBToolkit.makeNodeToken(n2);
      p.kind = TokenProduction.TOKEN;
      n0 = new NodeChoice(n1, 0, 4);
      break;
    case _SPECIAL_TOKEN:
      n4 = jj_consume_token(_SPECIAL_TOKEN);
      n3 = JTBToolkit.makeNodeToken(n4);
      p.kind = TokenProduction.SPECIAL;
      n0 = new NodeChoice(n3, 1, 4);
      break;
    case _SKIP:
      n6 = jj_consume_token(_SKIP);
      n5 = JTBToolkit.makeNodeToken(n6);
      p.kind = TokenProduction.SKIP;
      n0 = new NodeChoice(n5, 2, 4);
      break;
    case _MORE:
      n8 = jj_consume_token(_MORE);
      n7 = JTBToolkit.makeNodeToken(n8);
      p.kind = TokenProduction.MORE;
      n0 = new NodeChoice(n7, 3, 4);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new RegExprKind(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all RegExprSpec into RegExprSpec_ (JavaCC specific class)
// MMa : changed all regexpr_spec into RegExprSpec to conform to class name convention
  final public RegExprSpec RegExprSpec(TokenProduction p) throws ParseException {
  // --- JTB generated node declarations ---
  RegularExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  Block n5 = null;
  NodeOptional n6 = new NodeOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  // --- user BNFProduction java block ---
  Container c = new Container();
  Action act = new Action();
  Token t = null;
  RegExprSpec_ res = new RegExprSpec_();
    n0 = RegularExpression(c);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
      n3 = jj_consume_token(BANG);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    res.rexp = (RegularExpression_)c.member;
    res.rexp.tpContext = p;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      t = getToken(1);
      n5 = Block(act.getActionTokens());
      if (Options.getUserTokenManager()) {
        JavaCCErrors.warning(t, "Ignoring action in regular expression specification since option USER_TOKEN_MANAGER has been set to true.");
      }
      if (res.rexp.private_rexp) {
        JavaCCErrors.parse_error(t, "Actions are not permitted on private (#) regular expressions.");
      }
      n4.addNode(n5);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      n7 = new NodeSequence(3);
      n9 = jj_consume_token(COLON);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      n11 = jj_consume_token(IDENTIFIER);
      n10 = JTBToolkit.makeNodeToken(n11);
      t = n11;
      n7.addNode(n10);
      res.nextState = t.image;
      if (res.rexp.private_rexp) {
        JavaCCErrors.parse_error(t, "Lexical state changes are not permitted after private (#) regular expressions.");
      }
      n6.addNode(n7);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    res.act = act;
    res.nsTok = t;
    p.respecs.add(res);
    {if (true) return new RegExprSpec(n0, n1, n4, n6);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all expansion_choices into ExpansionChoices to conform to class name convention
  final public ExpansionChoices ExpansionChoices(Container c1) throws ParseException {
  // --- JTB generated node declarations ---
  Expansion n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Expansion n5 = null;
  // --- user BNFProduction java block ---
  boolean morethanone = false;
  Choice ch = new Choice();
  Container c2 = new Container();
    n0 = Expansion(c1);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_8;
      }
      n2 = new NodeSequence(3);
      n4 = jj_consume_token(BIT_OR);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = Expansion(c2);
      n2.addNode(n5);
      if (morethanone) {
        ch.getChoices().add((Expansion_)c2.member);
        ((Expansion_)c2.member).parent = ch;
      } else {
        morethanone = true;
        ch = new Choice((Expansion_)c1.member);
        ((Expansion_)c1.member).parent = ch;
        ch.getChoices().add((Expansion_)c2.member);
        ((Expansion_)c2.member).parent = ch;
      }
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    if (morethanone) {
      c1.member = ch;
    }
    {if (true) return new ExpansionChoices(n0, n1);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all Expansion into Expansion_ (JavaCC specific class)
// MMa : changed all expansion into Expansion to conform to class name convention
  final public Expansion Expansion(Container c1) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  LocalLookahead n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeList n9 = new NodeList();
  ExpansionUnit n10 = null;
  // --- user BNFProduction java block ---
  Sequence seq = new Sequence();
  Container c2 = new Container();
  Lookahead la = new Lookahead();
  Token t = getToken(1);
  seq.setLine(t.beginLine);
  seq.setColumn(t.beginColumn);
  la.setLine(t.beginLine);
  la.setColumn(t.beginColumn);
    la.setAmount(Options.getLookahead());
    la.setLaExpansion(null);
    la.setExplicit(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _LOOKAHEAD:
      n1 = new NodeSequence(5);
      n3 = jj_consume_token(_LOOKAHEAD);
      n2 = JTBToolkit.makeNodeToken(n3);
      t = n3;
      n1.addNode(n2);
      n5 = jj_consume_token(LPAREN);
      n4 = JTBToolkit.makeNodeToken(n5);
      n1.addNode(n4);
      n6 = LocalLookahead();
      la = jtbrt_LocalLookahead;
      n1.addNode(n6);
      n8 = jj_consume_token(RPAREN);
      n7 = JTBToolkit.makeNodeToken(n8);
      n1.addNode(n7);
      if (inLocalLA != 0 && la.getAmount() != 0) {
        JavaCCErrors.warning(t, "Only semantic lookahead specifications within other lookahead specifications is considered.  Syntactic lookahead is ignored.");
      }
      n0.addNode(n1);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    seq.units.add(la);
    label_9:
    while (true) {
      n10 = ExpansionUnit(c2);
      seq.units.add((Expansion_)c2.member);
      ((Expansion_)c2.member).parent = seq;
      ((Expansion_)c2.member).ordinal = seq.units.size() - 1;
      n9.addNode(n10);
      if (notTailOfExpansionUnit()) {
        ;
      } else {
        break label_9;
      }
    }
    n9.nodes.trimToSize();
    if (la.getLaExpansion() == null) {
      la.setLaExpansion(seq);
    }
    c1.member = seq;
    {if (true) return new Expansion(n0, n9);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all local_lookahead into LocalLookahead to conform to class name convention
  final public LocalLookahead LocalLookahead() throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  IntegerLiteral n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  ExpansionChoices n6 = null;
  NodeOptional n7 = new NodeOptional();
  NodeToken n8 = null;
  Token n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeSequence n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  Expression n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  // --- user BNFProduction java block ---
  Lookahead la = new Lookahead();
  la.setExplicit(true);
  Token t = getToken(1);
  la.setLine(t.beginLine);
  la.setColumn(t.beginColumn);
  la.setLaExpansion(null);
  Container c = new Container();
  boolean commaAtEnd = false, emptyLA = true;
  int laAmount;
  inLocalLA++;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      n1 = IntegerLiteral();
      laAmount = jtbrt_IntegerLiteral;
      emptyLA = false;
      la.setAmount(laAmount);
      n0.addNode(n1);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    if (!emptyLA && (getToken(1).kind != RPAREN)) {
      n4 = jj_consume_token(COMMA);
      n3 = JTBToolkit.makeNodeToken(n4);
      commaAtEnd = true;
      n2.addNode(n3);
    } else {
      ;
    }
    if (getToken(1).kind != RPAREN && getToken(1).kind != LBRACE) {
      n6 = ExpansionChoices(c);
      emptyLA = false;
      commaAtEnd = false;
      la.setLaExpansion((Expansion_)c.member);
      n5.addNode(n6);
    } else {
      ;
    }
    if (!emptyLA && !commaAtEnd && (getToken(1).kind != RPAREN)) {
      n9 = jj_consume_token(COMMA);
      n8 = JTBToolkit.makeNodeToken(n9);
      commaAtEnd = true;
      n7.addNode(n8);
    } else {
      ;
    }
    if (emptyLA || commaAtEnd) {
      n11 = new NodeSequence(4);
      n13 = jj_consume_token(LBRACE);
      n12 = JTBToolkit.makeNodeToken(n13);
      n11.addNode(n12);
      n14 = Expression(la.getActionTokens());
      n11.addNode(n14);
      n16 = jj_consume_token(RBRACE);
      n15 = JTBToolkit.makeNodeToken(n16);
      n11.addNode(n15);
      if (emptyLA) {
        la.setAmount(0);
      }
      n10.addNode(n11);
    } else {
      ;
    }
    inLocalLA--;
    jtbrt_LocalLookahead = la;
    {if (true) return new LocalLookahead(n0, n2, n5, n7, n10);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all expansion_unit into ExpansionUnit to conform to class name convention
  final public ExpansionUnit ExpansionUnit(Container c) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  LocalLookahead n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  Block n9 = null;
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  ExpansionChoices n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  ExpansionUnitTCF n16 = null;
  NodeSequence n17 = null;
  NodeOptional n18 = new NodeOptional();
  NodeSequence n19 = null;
  PrimaryExpression n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeChoice n23 = null;
  NodeSequence n24 = null;
  IdentifierAsString n25 = null;
  Arguments n26 = null;
  NodeOptional n27 = new NodeOptional();
  NodeToken n28 = null;
  Token n29 = null;
  NodeSequence n30 = null;
  RegularExpression n31 = null;
  NodeOptional n32 = new NodeOptional();
  NodeSequence n33 = null;
  NodeToken n34 = null;
  Token n35 = null;
  NodeToken n36 = null;
  Token n37 = null;
  NodeOptional n38 = new NodeOptional();
  NodeToken n39 = null;
  Token n40 = null;
  NodeSequence n41 = null;
  NodeToken n42 = null;
  Token n43 = null;
  ExpansionChoices n44 = null;
  NodeToken n45 = null;
  Token n46 = null;
  NodeOptional n47 = new NodeOptional();
  NodeChoice n48 = null;
  NodeToken n49 = null;
  Token n50 = null;
  NodeToken n51 = null;
  Token n52 = null;
  NodeToken n53 = null;
  Token n54 = null;
  // --- user BNFProduction java block ---
  String name;
  List<Token> lhsTokens = new ArrayList<Token>();
  NonTerminal nt;
  Action act;
  Token t;
  Lookahead la;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _LOOKAHEAD:
      n1 = new NodeSequence(5);
      n3 = jj_consume_token(_LOOKAHEAD);
      n2 = JTBToolkit.makeNodeToken(n3);
      /*
     * We give this priority over primary expressions which use LOOKAHEAD as the name of its identifier */
    t = n3;
      n1.addNode(n2);
      n5 = jj_consume_token(LPAREN);
      n4 = JTBToolkit.makeNodeToken(n5);
      n1.addNode(n4);
      n6 = LocalLookahead();
      la = jtbrt_LocalLookahead;
      n1.addNode(n6);
      n8 = jj_consume_token(RPAREN);
      n7 = JTBToolkit.makeNodeToken(n8);
      n1.addNode(n7);
      // Now set the la_expansion field of la with a dummy expansion (we use EOF)
      la.setLaExpansion(new REndOfFile());
      // Create a singleton choice with an empty action
      Choice ch = new Choice(t);
      Sequence seq = new Sequence(t, la);
      la.parent = seq;
      la.ordinal = 0;
      act = new Action();
      act.setLine(t.beginLine);
      act.setColumn(t.beginColumn);
      seq.units.add(act);
      act.parent = seq;
      act.ordinal = 1;
      ch.getChoices().add(seq);
      seq.parent = ch;
      seq.ordinal = 0;
      if (la.getAmount() != 0) {
        if (la.getActionTokens().size() != 0) {
          JavaCCErrors.warning(t, "Encountered LOOKAHEAD(...) at a non-choice location.  Only semantic lookahead will be considered here.");
        } else {
          JavaCCErrors.warning(t, "Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.");
        }
      }
      c.member = ch;
      n0 = new NodeChoice(n1, 0, 6);
      break;
    case LBRACE:
      act = new Action();
      t = getToken(1);
      act.setLine(t.beginLine);
      act.setColumn(t.beginColumn);
      inAction = true;
      n9 = Block(act.getActionTokens());
      inAction = false;
      if (inLocalLA != 0) {
        JavaCCErrors.warning(t, "Action within lookahead specification will be ignored.");
      }
      c.member = act;
      n0 = new NodeChoice(n9, 1, 6);
      break;
    case LBRACKET:
      n10 = new NodeSequence(4);
      n12 = jj_consume_token(LBRACKET);
      n11 = JTBToolkit.makeNodeToken(n12);
      t = n12;
      n10.addNode(n11);
      n13 = ExpansionChoices(c);
      n10.addNode(n13);
      n15 = jj_consume_token(RBRACKET);
      n14 = JTBToolkit.makeNodeToken(n15);
      n10.addNode(n14);
      c.member = new ZeroOrOne(t, (Expansion_)c.member);
      n0 = new NodeChoice(n10, 2, 6);
      break;
    case TRY:
      n16 = ExpansionUnitTCF(c);
      n0 = new NodeChoice(n16, 3, 6);
      break;
    default:
      jj_la1[30] = jj_gen;
      if (jj_2_4(2147483647)) {
      n17 = new NodeSequence(2);
        if (jj_2_2(2147483647)) {
        n19 = new NodeSequence(5);
        Token first = getToken(1);
          n20 = PrimaryExpression();
        n19.addNode(n20);
        Token last = getToken(0);
          n22 = jj_consume_token(ASSIGN);
        n21 = JTBToolkit.makeNodeToken(n22);
        n19.addNode(n21);
        t = first;
        while (true) {
          lhsTokens.add(t);
          if (t == last)
            break;
          t = t.next;
        }
        n18.addNode(n19);
        } else {
          ;
        }
      n17.addNode(n18);
        if (jj_2_3(2147483647)) {
          n24 = new NodeSequence(5);
          nt = new NonTerminal();
          t = getToken(1);
          nt.setLine(t.beginLine);
          nt.setColumn(t.beginColumn);
          nt.setLhsTokens(lhsTokens);
          n25 = IdentifierAsString();
          name = jtbrt_IdentifierAsString;
          n24.addNode(n25);
          n26 = Arguments(nt.getArgumentTokens());
          n24.addNode(n26);
          nt.setName(name);
          c.member = nt;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BANG:
            n29 = jj_consume_token(BANG);
            n28 = JTBToolkit.makeNodeToken(n29);
            n27.addNode(n28);
            break;
          default:
            jj_la1[24] = jj_gen;
            ;
          }
          n24.addNode(n27);
          n23 = new NodeChoice(n24, 0, 2);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case STRING_LITERAL:
          case LT:
          n30 = new NodeSequence(4);
            n31 = RegularExpression(c);
          n30.addNode(n31);
          ((RegularExpression_)(c.member)).lhsTokens = lhsTokens;
          add_inline_regexpr((RegularExpression_)(c.member));
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DOT:
            n33 = new NodeSequence(3);
              n35 = jj_consume_token(DOT);
            n34 = JTBToolkit.makeNodeToken(n35);
            n33.addNode(n34);
              n37 = jj_consume_token(IDENTIFIER);
            n36 = JTBToolkit.makeNodeToken(n37);
            t = n37;
            n33.addNode(n36);
            ((RegularExpression_)(c.member)).rhsToken = t;
            n32.addNode(n33);
              break;
            default:
              jj_la1[25] = jj_gen;
              ;
            }
          n30.addNode(n32);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BANG:
              n40 = jj_consume_token(BANG);
            n39 = JTBToolkit.makeNodeToken(n40);
            n38.addNode(n39);
              break;
            default:
              jj_la1[26] = jj_gen;
              ;
            }
          n30.addNode(n38);
          n23 = new NodeChoice(n30, 1, 2);
            break;
          default:
            jj_la1[27] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      n17.addNode(n23);
      n0 = new NodeChoice(n17, 4, 6);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
      n41 = new NodeSequence(4);
          n43 = jj_consume_token(LPAREN);
      n42 = JTBToolkit.makeNodeToken(n43);
      t = n43;
      n41.addNode(n42);
          n44 = ExpansionChoices(c);
      n41.addNode(n44);
          n46 = jj_consume_token(RPAREN);
      n45 = JTBToolkit.makeNodeToken(n46);
      n41.addNode(n45);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case HOOK:
          case PLUS:
          case STAR:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case PLUS:
              n50 = jj_consume_token(PLUS);
          n49 = JTBToolkit.makeNodeToken(n50);
          c.member = new OneOrMore(t, (Expansion_)c.member);
          n48 = new NodeChoice(n49, 0, 3);
              break;
            case STAR:
              n52 = jj_consume_token(STAR);
          n51 = JTBToolkit.makeNodeToken(n52);
          c.member = new ZeroOrMore(t, (Expansion_)c.member);
          n48 = new NodeChoice(n51, 1, 3);
              break;
            case HOOK:
              n54 = jj_consume_token(HOOK);
          n53 = JTBToolkit.makeNodeToken(n54);
          c.member = new ZeroOrOne(t, (Expansion_)c.member);
          n48 = new NodeChoice(n53, 2, 3);
              break;
            default:
              jj_la1[28] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
        n47.addNode(n48);
            break;
          default:
            jj_la1[29] = jj_gen;
            ;
          }
      n41.addNode(n47);
      n0 = new NodeChoice(n41, 5, 6);
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    {if (true) return new ExpansionUnit(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa : added to create a node ; renamed from ExpansionUnitInTCF
  final public ExpansionUnitTCF ExpansionUnitTCF(Container c) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  ExpansionChoices n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeListOptional n7 = new NodeListOptional();
  NodeSequence n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  Name n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  Block n18 = null;
  NodeOptional n19 = new NodeOptional();
  NodeSequence n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  Block n23 = null;
  // --- user BNFProduction java block ---
  Token t;
    Container expch = new Container();
    List<List<Token>> types = new ArrayList<List<Token>>();
    List<Token> ids = new ArrayList<Token>();
    List<List<Token>> catchblks = new ArrayList<List<Token>>();
    List<Token> finallyblk = null;
    List<Token> vec = new ArrayList<Token>();
    Token t0;
    n1 = jj_consume_token(TRY);
    n0 = JTBToolkit.makeNodeToken(n1);
    t0 = n1;
    n3 = jj_consume_token(LBRACE);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ExpansionChoices(expch);
    n6 = jj_consume_token(RBRACE);
    n5 = JTBToolkit.makeNodeToken(n6);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CATCH:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_10;
      }
      n8 = new NodeSequence(8);
      n10 = jj_consume_token(CATCH);
      n9 = JTBToolkit.makeNodeToken(n10);
      n8.addNode(n9);
      n12 = jj_consume_token(LPAREN);
      n11 = JTBToolkit.makeNodeToken(n12);
      n8.addNode(n11);
      n13 = Name(vec);
      n8.addNode(n13);
      n15 = jj_consume_token(IDENTIFIER);
      n14 = JTBToolkit.makeNodeToken(n15);
      t = n15;
      n8.addNode(n14);
      n17 = jj_consume_token(RPAREN);
      n16 = JTBToolkit.makeNodeToken(n17);
      n8.addNode(n16);
      types.add(vec);
      ids.add(t);
      vec = new ArrayList<Token>();
      inAction = true;
      n18 = Block(vec);
      n8.addNode(n18);
      inAction = false;
      catchblks.add(vec);
      vec = new ArrayList<Token>();
      n7.addNode(n8);
    }
    n7.nodes.trimToSize();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINALLY:
      n20 = new NodeSequence(4);
      inAction = true;
      n22 = jj_consume_token(FINALLY);
      n21 = JTBToolkit.makeNodeToken(n22);
      n20.addNode(n21);
      n23 = Block(vec);
      n20.addNode(n23);
      inAction = false;
      finallyblk = vec;
      n19.addNode(n20);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    makeTryBlock(t0, c, expch, types, ids, catchblks, finallyblk);
    {if (true) return new ExpansionUnitTCF(n0, n2, n4, n5, n7, n19);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all RegularExpression into RegularExpression_ (JavaCC specific class)
// MMa : changed all regular_expression into RegularExpression to conform to class name convention
  final public RegularExpression RegularExpression(Container c) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  StringLiteral n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeOptional n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  IdentifierAsString n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  ComplexRegularExpressionChoices n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeSequence n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  IdentifierAsString n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeSequence n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  // --- user BNFProduction java block ---
  REndOfFile ef;
  String image;
  boolean private_rexp = false;
  Token t = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      n1 = StringLiteral();
      image = jtbrt_StringLiteral;
      c.member = new RStringLiteral(t, image);
      n0 = new NodeChoice(n1, 0, 4);
      break;
    default:
      jj_la1[36] = jj_gen;
      if (jj_2_5(3)) {
      n2 = new NodeSequence(6);
      image = "";
        n4 = jj_consume_token(LT);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 141:
        case IDENTIFIER:
        n7 = new NodeOptional();
        n6 = new NodeSequence(3);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 141:
            n9 = jj_consume_token(141);
          n8 = JTBToolkit.makeNodeToken(n9);
          private_rexp = true;
          n7.addNode(n8);
            break;
          default:
            jj_la1[34] = jj_gen;
            ;
          }
        n6.addNode(n7);
          n10 = IdentifierAsString();
        image = jtbrt_IdentifierAsString;
        n6.addNode(n10);
          n12 = jj_consume_token(COLON);
        n11 = JTBToolkit.makeNodeToken(n12);
        n6.addNode(n11);
        n5.addNode(n6);
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
        }
      n2.addNode(n5);
        n13 = ComplexRegularExpressionChoices(c);
      n2.addNode(n13);
        n15 = jj_consume_token(GT);
      n14 = JTBToolkit.makeNodeToken(n15);
      n2.addNode(n14);
      RegularExpression_ re;
      if (c.member instanceof RJustName) {
        RSequence seq = new RSequence();
        seq.units.add((RegularExpression_)c.member);
        re = seq;
      } else {
        re = (RegularExpression_)c.member;
      }
      re.label = image;
      re.private_rexp = private_rexp;
      re.setLine(t.beginLine);
      re.setColumn(t.beginColumn);
      c.member = re;
      n0 = new NodeChoice(n2, 1, 4);
      } else if (jj_2_6(2)) {
      n16 = new NodeSequence(4);
        n18 = jj_consume_token(LT);
      n17 = JTBToolkit.makeNodeToken(n18);
      n16.addNode(n17);
        n19 = IdentifierAsString();
      image = jtbrt_IdentifierAsString;
      n16.addNode(n19);
        n21 = jj_consume_token(GT);
      n20 = JTBToolkit.makeNodeToken(n21);
      n16.addNode(n20);
      c.member = new RJustName(t, image);
      n0 = new NodeChoice(n16, 2, 4);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
      n22 = new NodeSequence(4);
          n24 = jj_consume_token(LT);
      n23 = JTBToolkit.makeNodeToken(n24);
      n22.addNode(n23);
          n26 = jj_consume_token(_EOF);
      n25 = JTBToolkit.makeNodeToken(n26);
      n22.addNode(n25);
          n28 = jj_consume_token(GT);
      n27 = JTBToolkit.makeNodeToken(n28);
      n22.addNode(n27);
      ef = new REndOfFile();
      ef.setLine(t.beginLine);
      ef.setColumn(t.beginColumn);
      ef.ordinal = 0;
      c.member = ef;
      n0 = new NodeChoice(n22, 3, 4);
          break;
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    {if (true) return new RegularExpression(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all complex_regular_expression_choices into ComplexRegularExpressionChoices to conform to class name convention
  final public ComplexRegularExpressionChoices ComplexRegularExpressionChoices(Container c1) throws ParseException {
  // --- JTB generated node declarations ---
  ComplexRegularExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  ComplexRegularExpression n5 = null;
  // --- user BNFProduction java block ---
  boolean morethanone = false;
  RChoice ch = new RChoice();
  Container c2 = new Container();
    n0 = ComplexRegularExpression(c1);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_11;
      }
      n2 = new NodeSequence(3);
      n4 = jj_consume_token(BIT_OR);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = ComplexRegularExpression(c2);
      n2.addNode(n5);
      if (morethanone) {
        ch.getChoices().add((RegularExpression_)c2.member);
      } else {
        morethanone = true;
        ch = new RChoice();
        ch.setLine(((RegularExpression_)c1.member).getLine());
        ch.setColumn(((RegularExpression_)c1.member).getColumn());
        ch.getChoices().add((RegularExpression_)c1.member);
        ch.getChoices().add((RegularExpression_)c2.member);
      }
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    if (morethanone) {
      c1.member = ch;
    }
    {if (true) return new ComplexRegularExpressionChoices(n0, n1);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all complex_regular_expression into ComplexRegularExpression to conform to class name convention
  final public ComplexRegularExpression ComplexRegularExpression(Container c1) throws ParseException {
  // --- JTB generated node declarations ---
  NodeList n0 = new NodeList();
  ComplexRegularExpressionUnit n1 = null;
  // --- user BNFProduction java block ---
  int count = 0;
  RSequence seq = new RSequence();
  Container c2 = new Container();
    label_12:
    while (true) {
      n1 = ComplexRegularExpressionUnit(c2);
      count++;
      if (count == 1) {
        c1.member = c2.member;
      // if count does not go beyond 1, we are done.
      } else
        if (count == 2) {
          // more than 1, so create a sequence.
          seq = new RSequence();
          seq.setLine(((RegularExpression_)c1.member).getLine());
          seq.setColumn(((RegularExpression_)c1.member).getColumn());
          seq.units.add((RegularExpression_)c1.member);
          seq.units.add((RegularExpression_)c2.member);
        } else {
          seq.units.add((RegularExpression_)c2.member);
        }
      n0.addNode(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
      case LPAREN:
      case LBRACKET:
      case LT:
      case TILDE:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_12;
      }
    }
    n0.nodes.trimToSize();
    if (count > 1) {
      c1.member = seq;
    }
    {if (true) return new ComplexRegularExpression(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all complex_regular_expression_unit into ComplexRegularExpressionUnit to conform to class name convention
  final public ComplexRegularExpressionUnit ComplexRegularExpressionUnit(Container c) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  StringLiteral n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  IdentifierAsString n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  CharacterList n8 = null;
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  ComplexRegularExpressionChoices n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeOptional n15 = new NodeOptional();
  NodeChoice n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeSequence n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  IntegerLiteral n26 = null;
  NodeOptional n27 = null;
  NodeSequence n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeOptional n31 = null;
  IntegerLiteral n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  // --- user BNFProduction java block ---
  String image;
  Token t = getToken(1);
  int r1 = 0, r2 = -1;
  boolean hasMax = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      n1 = StringLiteral();
      image = jtbrt_StringLiteral;
      c.member = new RStringLiteral(t, image);
      n0 = new NodeChoice(n1, 0, 4);
      break;
    case LT:
      n2 = new NodeSequence(4);
      n4 = jj_consume_token(LT);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = IdentifierAsString();
      image = jtbrt_IdentifierAsString;
      n2.addNode(n5);
      n7 = jj_consume_token(GT);
      n6 = JTBToolkit.makeNodeToken(n7);
      n2.addNode(n6);
      c.member = new RJustName(t, image);
      n0 = new NodeChoice(n2, 1, 4);
      break;
    case LBRACKET:
    case TILDE:
      n8 = CharacterList(c);
      n0 = new NodeChoice(n8, 2, 4);
      break;
    case LPAREN:
      n9 = new NodeSequence(4);
      n11 = jj_consume_token(LPAREN);
      n10 = JTBToolkit.makeNodeToken(n11);
      n9.addNode(n10);
      n12 = ComplexRegularExpressionChoices(c);
      n9.addNode(n12);
      n14 = jj_consume_token(RPAREN);
      n13 = JTBToolkit.makeNodeToken(n14);
      n9.addNode(n13);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case HOOK:
      case PLUS:
      case STAR:
        n27 = new NodeOptional();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          n18 = jj_consume_token(PLUS);
          n17 = JTBToolkit.makeNodeToken(n18);
          c.member = new ROneOrMore(t, (RegularExpression_)c.member);
          n16 = new NodeChoice(n17, 0, 4);
          break;
        case STAR:
          n20 = jj_consume_token(STAR);
          n19 = JTBToolkit.makeNodeToken(n20);
          c.member = new RZeroOrMore(t, (RegularExpression_)c.member);
          n16 = new NodeChoice(n19, 1, 4);
          break;
        case HOOK:
          n22 = jj_consume_token(HOOK);
          n21 = JTBToolkit.makeNodeToken(n22);
          RZeroOrOne zorexp = new RZeroOrOne();
          zorexp.setLine(t.beginLine);
          zorexp.setColumn(t.beginColumn);
          zorexp.regexpr = (RegularExpression_)c.member;
          c.member = zorexp;
          n16 = new NodeChoice(n21, 2, 4);
          break;
        case LBRACE:
          n23 = new NodeSequence(5);
          n25 = jj_consume_token(LBRACE);
          n24 = JTBToolkit.makeNodeToken(n25);
          n23.addNode(n24);
          n26 = IntegerLiteral();
          r1 = jtbrt_IntegerLiteral;
          n23.addNode(n26);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            n31 = new NodeOptional();
            n28 = new NodeSequence(3);
            n30 = jj_consume_token(COMMA);
            n29 = JTBToolkit.makeNodeToken(n30);
            n28.addNode(n29);
            hasMax = true;
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INTEGER_LITERAL:
              n32 = IntegerLiteral();
              r2 = jtbrt_IntegerLiteral;
              n31.addNode(n32);
              break;
            default:
              jj_la1[40] = jj_gen;
              ;
            }
            n28.addNode(n31);
            n27.addNode(n28);
            break;
          default:
            jj_la1[41] = jj_gen;
            ;
          }
          n23.addNode(n27);
          n34 = jj_consume_token(RBRACE);
          n33 = JTBToolkit.makeNodeToken(n34);
          n23.addNode(n33);
          RRepetitionRange rrrexp = new RRepetitionRange();
          rrrexp.setLine(t.beginLine);
          rrrexp.setColumn(t.beginColumn);
          rrrexp.min = r1;
          rrrexp.max = r2;
          rrrexp.hasMax = hasMax;
          rrrexp.regexpr = (RegularExpression_)c.member;
          c.member = rrrexp;
          n16 = new NodeChoice(n23, 3, 4);
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n15.addNode(n16);
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      n9.addNode(n15);
      n0 = new NodeChoice(n9, 3, 4);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ComplexRegularExpressionUnit(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all character_list into CharacterList to conform to class name convention
  final public CharacterList CharacterList(Container c1) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  CharacterDescriptor n7 = null;
  NodeListOptional n8 = null;
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  CharacterDescriptor n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  // --- user BNFProduction java block ---
  RCharacterList chlist = new RCharacterList();
  Token t = getToken(1);
  chlist.setLine(t.beginLine);
  chlist.setColumn(t.beginColumn);
  Container c2 = new Container();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TILDE:
      n2 = jj_consume_token(TILDE);
      n1 = JTBToolkit.makeNodeToken(n2);
      chlist.negated_list = true;
      n0.addNode(n1);
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    n4 = jj_consume_token(LBRACKET);
    n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      n8 = new NodeListOptional();
      n6 = new NodeSequence(3);
      n7 = CharacterDescriptor(c2);
      n6.addNode(n7);
      chlist.descriptors.add(c2.member);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[46] = jj_gen;
          break label_13;
        }
        n9 = new NodeSequence(3);
        n11 = jj_consume_token(COMMA);
        n10 = JTBToolkit.makeNodeToken(n11);
        n9.addNode(n10);
        n12 = CharacterDescriptor(c2);
        n9.addNode(n12);
        chlist.descriptors.add(c2.member);
        n8.addNode(n9);
      }
      n8.nodes.trimToSize();
      n6.addNode(n8);
      n5.addNode(n6);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    n14 = jj_consume_token(RBRACKET);
    n13 = JTBToolkit.makeNodeToken(n14);
    c1.member = chlist;
    {if (true) return new CharacterList(n0, n3, n5, n13);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all character_descriptor into CharacterDescriptor to conform to class name convention
  final public CharacterDescriptor CharacterDescriptor(Container c) throws ParseException {
  // --- JTB generated node declarations ---
  StringLiteral n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  StringLiteral n5 = null;
  // --- user BNFProduction java block ---
  char c1, c2 = ' ';
  // "unnecessary" initialization to make the Java compiler happy!
  boolean isrange = false;
  String imageL, imageR;
  Token t = getToken(1);
    n0 = StringLiteral();
    imageL = jtbrt_StringLiteral;
    c1 = character_descriptor_assign(getToken(0), imageL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
      n2 = new NodeSequence(3);
      n4 = jj_consume_token(MINUS);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = StringLiteral();
      imageR = jtbrt_StringLiteral;
      n2.addNode(n5);
      isrange = true;
      c2 = character_descriptor_assign(getToken(0), imageR, imageL);
      n1.addNode(n2);
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    if (isrange) {
      CharacterRange cr = new CharacterRange();
      cr.setLine(t.beginLine);
      cr.setColumn(t.beginColumn);
      cr.setLeft(c1);
      cr.setRight(c2);
      c.member = cr;
    } else {
      SingleCharacter sc = new SingleCharacter();
      sc.setLine(t.beginLine);
      sc.setColumn(t.beginColumn);
      sc.ch = c1;
      c.member = sc;
    }
    {if (true) return new CharacterDescriptor(n0, n1);}
    throw new Error("Missing return statement in function");
  }

// MMa : changed all identifier into Identifier to conform to class name convention
// MMa 07/2012 : renamed from Identifier to IdentifierAsString
  final public IdentifierAsString IdentifierAsString() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  // --- user BNFProduction java block ---
  Token t = null;
    n1 = jj_consume_token(IDENTIFIER);
    n0 = JTBToolkit.makeNodeToken(n1);
    t = n1;
    jtbrt_IdentifierAsString = t.image;
    {if (true) return new IdentifierAsString(n0);}
    throw new Error("Missing return statement in function");
  }

/**********************************************
 * THE JAVA GRAMMAR SPECIFICATION STARTS HERE *
 **********************************************/
/*
 * The Java grammar is modified to use sequences of tokens for the missing tokens
 * (those that include "<<" and ">>")
 */
/* Java identifiers and JavaCC reserved words */
// MMa 07/2012 : is it useful to return a Token ? Seems not in Name() and BlockStatement()
  final public JavaIdentifier JavaIdentifier() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n2 = jj_consume_token(IDENTIFIER);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 12);
      break;
    case _LOOKAHEAD:
      n4 = jj_consume_token(_LOOKAHEAD);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 12);
      break;
    case _IGNORE_CASE:
      n6 = jj_consume_token(_IGNORE_CASE);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 12);
      break;
    case _PARSER_BEGIN:
      n8 = jj_consume_token(_PARSER_BEGIN);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3, 12);
      break;
    case _PARSER_END:
      n10 = jj_consume_token(_PARSER_END);
        n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4, 12);
      break;
    case _JAVACODE:
      n12 = jj_consume_token(_JAVACODE);
        n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5, 12);
      break;
    case _TOKEN:
      n14 = jj_consume_token(_TOKEN);
        n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6, 12);
      break;
    case _SPECIAL_TOKEN:
      n16 = jj_consume_token(_SPECIAL_TOKEN);
        n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7, 12);
      break;
    case _MORE:
      n18 = jj_consume_token(_MORE);
        n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8, 12);
      break;
    case _SKIP:
      n20 = jj_consume_token(_SKIP);
        n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9, 12);
      break;
    case _TOKEN_MGR_DECLS:
      n22 = jj_consume_token(_TOKEN_MGR_DECLS);
        n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10, 12);
      break;
    case _EOF:
      n24 = jj_consume_token(_EOF);
        n23 = JTBToolkit.makeNodeToken(n24);
        n0 = new NodeChoice(n23, 11, 12);
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    Token retval = getToken(0);
    retval.kind = IDENTIFIER;
    jtbrt_JavaIdentifier = retval;
    {if (true) return new JavaIdentifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public CompilationUnit CompilationUnit() throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  PackageDeclaration n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  ImportDeclaration n3 = null;
  NodeListOptional n4 = new NodeListOptional();
  TypeDeclaration n5 = null;
  // --- user BNFProduction java block ---
  set_initial_cu_token(getToken(1));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PACKAGE:
      n1 = PackageDeclaration();
      n0.addNode(n1);
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_14;
      }
      n3 = ImportDeclaration();
      n2.addNode(n3);
    }
    n2.nodes.trimToSize();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case CLASS:
      case ENUM:
      case FINAL:
      case INTERFACE:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case SEMICOLON:
      case 147:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_15;
      }
      n5 = TypeDeclaration();
      n4.addNode(n5);
    }
    n4.nodes.trimToSize();
    insertionpointerrors(getToken(1));
    {if (true) return new CompilationUnit(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public PackageDeclaration PackageDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Name n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    n1 = jj_consume_token(PACKAGE);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name(null);
    n4 = jj_consume_token(SEMICOLON);
    n3 = JTBToolkit.makeNodeToken(n4);
    {if (true) return new PackageDeclaration(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public ImportDeclaration ImportDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  Name n5 = null;
  NodeOptional n6 = new NodeOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
    n1 = jj_consume_token(IMPORT);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      n4 = jj_consume_token(STATIC);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    n5 = Name(null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      n7 = new NodeSequence(2);
      n9 = jj_consume_token(DOT);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      n11 = jj_consume_token(STAR);
      n10 = JTBToolkit.makeNodeToken(n11);
      n7.addNode(n10);
      n6.addNode(n7);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    n13 = jj_consume_token(SEMICOLON);
    n12 = JTBToolkit.makeNodeToken(n13);
    {if (true) return new ImportDeclaration(n0, n2, n5, n6, n12);}
    throw new Error("Missing return statement in function");
  }

/*
 * We match all modifiers in a single rule to reduce the chances of syntax errors
 * for simple modifier mistakes. It will also enable us to give better error messages.
 * Used for class, interface, constant, field, method, constructor & abstract method modifiers,
 * but not for variable modifiers (see VariableModifiers()).
 */
  final public Modifiers Modifiers() throws ParseException {
  // --- JTB generated node declarations ---
  NodeListOptional n0 = new NodeListOptional();
  NodeChoice n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  Annotation n24 = null;
  // --- user BNFProduction java block ---
  int modifiers = 0;
    label_16:
    while (true) {
      if (jj_2_7(2)) {
        ;
      } else {
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        n3 = jj_consume_token(PUBLIC);
          n2 = JTBToolkit.makeNodeToken(n3);
          modifiers |= ModifierSet.M_PUBLIC;
          n1 = new NodeChoice(n2, 0, 12);
        break;
      case STATIC:
        n5 = jj_consume_token(STATIC);
          n4 = JTBToolkit.makeNodeToken(n5);
          modifiers |= ModifierSet.M_STATIC;
          n1 = new NodeChoice(n4, 1, 12);
        break;
      case PROTECTED:
        n7 = jj_consume_token(PROTECTED);
          n6 = JTBToolkit.makeNodeToken(n7);
          modifiers |= ModifierSet.M_PROTECTED;
          n1 = new NodeChoice(n6, 2, 12);
        break;
      case PRIVATE:
        n9 = jj_consume_token(PRIVATE);
          n8 = JTBToolkit.makeNodeToken(n9);
          modifiers |= ModifierSet.M_PRIVATE;
          n1 = new NodeChoice(n8, 3, 12);
        break;
      case FINAL:
        n11 = jj_consume_token(FINAL);
          n10 = JTBToolkit.makeNodeToken(n11);
          modifiers |= ModifierSet.M_FINAL;
          n1 = new NodeChoice(n10, 4, 12);
        break;
      case ABSTRACT:
        n13 = jj_consume_token(ABSTRACT);
          n12 = JTBToolkit.makeNodeToken(n13);
          modifiers |= ModifierSet.M_ABSTRACT;
          n1 = new NodeChoice(n12, 5, 12);
        break;
      case SYNCHRONIZED:
        n15 = jj_consume_token(SYNCHRONIZED);
          n14 = JTBToolkit.makeNodeToken(n15);
          modifiers |= ModifierSet.M_SYNCHRONIZED;
          n1 = new NodeChoice(n14, 6, 12);
        break;
      case NATIVE:
        n17 = jj_consume_token(NATIVE);
          n16 = JTBToolkit.makeNodeToken(n17);
          modifiers |= ModifierSet.M_NATIVE;
          n1 = new NodeChoice(n16, 7, 12);
        break;
      case TRANSIENT:
        n19 = jj_consume_token(TRANSIENT);
          n18 = JTBToolkit.makeNodeToken(n19);
          modifiers |= ModifierSet.M_TRANSIENT;
          n1 = new NodeChoice(n18, 8, 12);
        break;
      case VOLATILE:
        n21 = jj_consume_token(VOLATILE);
          n20 = JTBToolkit.makeNodeToken(n21);
          modifiers |= ModifierSet.M_VOLATILE;
          n1 = new NodeChoice(n20, 9, 12);
        break;
      case STRICTFP:
        n23 = jj_consume_token(STRICTFP);
          n22 = JTBToolkit.makeNodeToken(n23);
          modifiers |= ModifierSet.M_STRICTFP;
          n1 = new NodeChoice(n22, 10, 12);
        break;
      case 147:
        n24 = Annotation();
          n1 = new NodeChoice(n24, 11, 12);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n0.addNode(n1);
    }
    n0.nodes.trimToSize();
    jtbrt_Modifiers = modifiers;
    {if (true) return new Modifiers(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TypeDeclaration TypeDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeSequence n3 = null;
  Modifiers n4 = null;
  NodeChoice n5 = null;
  ClassOrInterfaceDeclaration n6 = null;
  EnumDeclaration n7 = null;
  AnnotationTypeDeclaration n8 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      n2 = jj_consume_token(SEMICOLON);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case ABSTRACT:
    case CLASS:
    case ENUM:
    case FINAL:
    case INTERFACE:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 147:
      n3 = new NodeSequence(2);
      n4 = Modifiers();
      n3.addNode(n4);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
      case INTERFACE:
        n6 = ClassOrInterfaceDeclaration();
          n5 = new NodeChoice(n6, 0, 3);
        break;
      case ENUM:
        n7 = EnumDeclaration();
          n5 = new NodeChoice(n7, 1, 3);
        break;
      case 147:
        n8 = AnnotationTypeDeclaration();
          n5 = new NodeChoice(n8, 2, 3);
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n3.addNode(n5);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new TypeDeclaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ClassOrInterfaceDeclaration ClassOrInterfaceDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = new NodeOptional();
  TypeParameters n8 = null;
  NodeOptional n9 = new NodeOptional();
  ExtendsList n10 = null;
  NodeOptional n11 = new NodeOptional();
  ImplementsList n12 = null;
  ClassOrInterfaceBody n13 = null;
  // --- user BNFProduction java block ---
  boolean isInterface = false;
  class_nesting++;
  Token t;
  boolean is_parser_class = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
      n2 = jj_consume_token(CLASS);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case INTERFACE:
      n4 = jj_consume_token(INTERFACE);
        n3 = JTBToolkit.makeNodeToken(n4);
        isInterface = true;
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n6 = jj_consume_token(IDENTIFIER);
    n5 = JTBToolkit.makeNodeToken(n6);
    t = n6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      n8 = TypeParameters();
      n7.addNode(n8);
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      n10 = ExtendsList(isInterface);
      n9.addNode(n10);
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      n12 = ImplementsList(isInterface);
      n11.addNode(n12);
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
    if (t.image.equals(parser_class_name) && class_nesting == 1 && processing_cu) {
      is_parser_class = true;
      setinsertionpoint(getToken(1), 1);
    }
    n13 = ClassOrInterfaceBody(isInterface, null);
    if (is_parser_class) {
      setinsertionpoint(getToken(0), 2);
    }
    class_nesting--;
    {if (true) return new ClassOrInterfaceDeclaration(n0, n5, n7, n9, n11, n13);}
    throw new Error("Missing return statement in function");
  }

  final public ExtendsList ExtendsList(boolean isInterface) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ClassOrInterfaceType n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  ClassOrInterfaceType n7 = null;
  // --- user BNFProduction java block ---
  boolean extendsMoreThanOne = false;
    n1 = jj_consume_token(EXTENDS);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ClassOrInterfaceType();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[62] = jj_gen;
        break label_17;
      }
      n4 = new NodeSequence(3);
      n6 = jj_consume_token(COMMA);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = ClassOrInterfaceType();
      n4.addNode(n7);
      extendsMoreThanOne = true;
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    if (extendsMoreThanOne && !isInterface)
      {if (true) throw new ParseException("A class cannot extend more than one other class");}
    {if (true) return new ExtendsList(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public ImplementsList ImplementsList(boolean isInterface) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ClassOrInterfaceType n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  ClassOrInterfaceType n7 = null;
    n1 = jj_consume_token(IMPLEMENTS);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ClassOrInterfaceType();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_18;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = ClassOrInterfaceType();
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    if (isInterface)
      {if (true) throw new ParseException("An interface cannot implement other interfaces");}
    {if (true) return new ImplementsList(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public EnumDeclaration EnumDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  ImplementsList n5 = null;
  EnumBody n6 = null;
    n1 = jj_consume_token(ENUM);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      n5 = ImplementsList(false);
      n4.addNode(n5);
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
    n6 = EnumBody();
    {if (true) return new EnumDeclaration(n0, n2, n4, n6);}
    throw new Error("Missing return statement in function");
  }

  final public EnumBody EnumBody() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  EnumConstant n4 = null;
  NodeListOptional n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  EnumConstant n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeToken n11 = null;
  Token n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeListOptional n17 = null;
  ClassOrInterfaceBodyDeclaration n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
    n1 = jj_consume_token(LBRACE);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case FINAL:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 147:
    case IDENTIFIER:
      n5 = new NodeListOptional();
      n3 = new NodeSequence(2);
      n4 = EnumConstant();
      n3.addNode(n4);
      label_19:
      while (true) {
        if (jj_2_8(2)) {
          ;
        } else {
          break label_19;
        }
        n6 = new NodeSequence(2);
        n8 = jj_consume_token(COMMA);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = EnumConstant();
        n6.addNode(n9);
        n5.addNode(n6);
      }
      n5.nodes.trimToSize();
      n3.addNode(n5);
      n2.addNode(n3);
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      n12 = jj_consume_token(COMMA);
      n11 = JTBToolkit.makeNodeToken(n12);
      n10.addNode(n11);
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      n17 = new NodeListOptional();
      n14 = new NodeSequence(2);
      n16 = jj_consume_token(SEMICOLON);
      n15 = JTBToolkit.makeNodeToken(n16);
      n14.addNode(n15);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case LBRACE:
        case SEMICOLON:
        case LT:
        case 147:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[67] = jj_gen;
          break label_20;
        }
        n18 = ClassOrInterfaceBodyDeclaration(false);
        n17.addNode(n18);
      }
      n17.nodes.trimToSize();
      n14.addNode(n17);
      n13.addNode(n14);
      break;
    default:
      jj_la1[68] = jj_gen;
      ;
    }
    n20 = jj_consume_token(RBRACE);
    n19 = JTBToolkit.makeNodeToken(n20);
    {if (true) return new EnumBody(n0, n2, n10, n13, n19);}
    throw new Error("Missing return statement in function");
  }

  final public EnumConstant EnumConstant() throws ParseException {
  // --- JTB generated node declarations ---
  Modifiers n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeOptional n3 = new NodeOptional();
  Arguments n4 = null;
  NodeOptional n5 = new NodeOptional();
  ClassOrInterfaceBody n6 = null;
    n0 = Modifiers();
    n2 = jj_consume_token(IDENTIFIER);
    n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      n4 = Arguments(null);
      n3.addNode(n4);
      break;
    default:
      jj_la1[69] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      n6 = ClassOrInterfaceBody(false, null);
      n5.addNode(n6);
      break;
    default:
      jj_la1[70] = jj_gen;
      ;
    }
    {if (true) return new EnumConstant(n0, n1, n3, n5);}
    throw new Error("Missing return statement in function");
  }

  final public TypeParameters TypeParameters() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TypeParameter n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  TypeParameter n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(LT);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TypeParameter();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_21;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = TypeParameter();
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    n9 = jj_consume_token(GT);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new TypeParameters(n0, n2, n3, n8);}
    throw new Error("Missing return statement in function");
  }

  final public TypeParameter TypeParameter() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  TypeBound n3 = null;
    n1 = jj_consume_token(IDENTIFIER);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      n3 = TypeBound();
      n2.addNode(n3);
      break;
    default:
      jj_la1[72] = jj_gen;
      ;
    }
    {if (true) return new TypeParameter(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public TypeBound TypeBound() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ClassOrInterfaceType n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  ClassOrInterfaceType n7 = null;
    n1 = jj_consume_token(EXTENDS);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ClassOrInterfaceType();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[73] = jj_gen;
        break label_22;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(BIT_AND);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = ClassOrInterfaceType();
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    {if (true) return new TypeBound(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public ClassOrInterfaceBody ClassOrInterfaceBody(boolean isInterface, List<Token> tokens) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  ClassOrInterfaceBodyDeclaration n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  // --- user BNFProduction java block ---
  Token first, last;
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n1 = jj_consume_token(LBRACE);
    n0 = JTBToolkit.makeNodeToken(n1);
    first = getToken(1);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case LBRACE:
      case SEMICOLON:
      case LT:
      case 147:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_23;
      }
      n3 = ClassOrInterfaceBodyDeclaration(isInterface);
      n2.addNode(n3);
    }
    n2.nodes.trimToSize();
    last = getToken(0);
    n5 = jj_consume_token(RBRACE);
    n4 = JTBToolkit.makeNodeToken(n5);
    if (last.next != first) {
      // i.e., this is not an empty sequence
      Token t = first;
      while (true) {
        tokens.add(t);
        if (t == last)
          break;
        t = t.next;
      }
    }
    {if (true) return new ClassOrInterfaceBody(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public ClassOrInterfaceBodyDeclaration ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Initializer n1 = null;
  NodeSequence n2 = null;
  Modifiers n3 = null;
  NodeChoice n4 = null;
  ClassOrInterfaceDeclaration n5 = null;
  EnumDeclaration n6 = null;
  ConstructorDeclaration n7 = null;
  FieldDeclaration n8 = null;
  MethodDeclaration n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
    if (jj_2_11(2)) {
      n1 = Initializer();
      if (isInterface)
        {if (true) throw new ParseException("An interface cannot have initializers");}
      n0 = new NodeChoice(n1, 0, 3);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case LT:
      case 147:
      case IDENTIFIER:
      n2 = new NodeSequence(2);
        n3 = Modifiers();
      n2.addNode(n3);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case INTERFACE:
          n5 = ClassOrInterfaceDeclaration();
          n4 = new NodeChoice(n5, 0, 5);
          break;
        case ENUM:
          n6 = EnumDeclaration();
          n4 = new NodeChoice(n6, 1, 5);
          break;
        default:
          jj_la1[75] = jj_gen;
          if (jj_2_9(2147483647)) {
            n7 = ConstructorDeclaration();
          n4 = new NodeChoice(n7, 2, 5);
          } else if (jj_2_10(2147483647)) {
            n8 = FieldDeclaration();
          n4 = new NodeChoice(n8, 3, 5);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BOOLEAN:
            case BYTE:
            case CHAR:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SHORT:
            case VOID:
            case LT:
            case IDENTIFIER:
              n9 = MethodDeclaration();
          n4 = new NodeChoice(n9, 4, 5);
              break;
            default:
              jj_la1[76] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      n2.addNode(n4);
      n0 = new NodeChoice(n2, 1, 3);
        break;
      case SEMICOLON:
        n11 = jj_consume_token(SEMICOLON);
      n10 = JTBToolkit.makeNodeToken(n11);
      n0 = new NodeChoice(n10, 2, 3);
        break;
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new ClassOrInterfaceBodyDeclaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FieldDeclaration FieldDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  Type n0 = null;
  VariableDeclarator n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  VariableDeclarator n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n0 = Type();
    n1 = VariableDeclarator();
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[78] = jj_gen;
        break label_24;
      }
      n3 = new NodeSequence(2);
      n5 = jj_consume_token(COMMA);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n6 = VariableDeclarator();
      n3.addNode(n6);
      n2.addNode(n3);
    }
    n2.nodes.trimToSize();
    n8 = jj_consume_token(SEMICOLON);
    n7 = JTBToolkit.makeNodeToken(n8);
    {if (true) return new FieldDeclaration(n0, n1, n2, n7);}
    throw new Error("Missing return statement in function");
  }

  final public VariableDeclarator VariableDeclarator() throws ParseException {
  // --- JTB generated node declarations ---
  VariableDeclaratorId n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  VariableInitializer n5 = null;
    n0 = VariableDeclaratorId();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(ASSIGN);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = VariableInitializer();
      n2.addNode(n5);
      n1.addNode(n2);
      break;
    default:
      jj_la1[79] = jj_gen;
      ;
    }
    {if (true) return new VariableDeclarator(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public VariableDeclaratorId VariableDeclaratorId() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(IDENTIFIER);
    n0 = JTBToolkit.makeNodeToken(n1);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        jj_la1[80] = jj_gen;
        break label_25;
      }
      n3 = new NodeSequence(2);
      n5 = jj_consume_token(LBRACKET);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n7 = jj_consume_token(RBRACKET);
      n6 = JTBToolkit.makeNodeToken(n7);
      n3.addNode(n6);
      n2.addNode(n3);
    }
    n2.nodes.trimToSize();
    {if (true) return new VariableDeclaratorId(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public VariableInitializer VariableInitializer() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  ArrayInitializer n1 = null;
  Expression n2 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      n1 = ArrayInitializer();
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:
      n2 = Expression(null);
      n0 = new NodeChoice(n2, 1, 2);
      break;
    default:
      jj_la1[81] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new VariableInitializer(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ArrayInitializer ArrayInitializer() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  VariableInitializer n4 = null;
  NodeListOptional n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  VariableInitializer n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
    n1 = jj_consume_token(LBRACE);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:
      n5 = new NodeListOptional();
      n3 = new NodeSequence(2);
      n4 = VariableInitializer();
      n3.addNode(n4);
      label_26:
      while (true) {
        if (jj_2_12(2)) {
          ;
        } else {
          break label_26;
        }
        n6 = new NodeSequence(2);
        n8 = jj_consume_token(COMMA);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = VariableInitializer();
        n6.addNode(n9);
        n5.addNode(n6);
      }
      n5.nodes.trimToSize();
      n3.addNode(n5);
      n2.addNode(n3);
      break;
    default:
      jj_la1[82] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      n12 = jj_consume_token(COMMA);
      n11 = JTBToolkit.makeNodeToken(n12);
      n10.addNode(n11);
      break;
    default:
      jj_la1[83] = jj_gen;
      ;
    }
    n14 = jj_consume_token(RBRACE);
    n13 = JTBToolkit.makeNodeToken(n14);
    {if (true) return new ArrayInitializer(n0, n2, n10, n13);}
    throw new Error("Missing return statement in function");
  }

  final public MethodDeclaration MethodDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  TypeParameters n1 = null;
  ResultType n2 = null;
  MethodDeclarator n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NameList n8 = null;
  NodeChoice n9 = null;
  Block n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      n1 = TypeParameters();
      n0.addNode(n1);
      break;
    default:
      jj_la1[84] = jj_gen;
      ;
    }
    n2 = ResultType(null);
    n3 = MethodDeclarator();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      n5 = new NodeSequence(2);
      n7 = jj_consume_token(THROWS);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n8 = NameList();
      n5.addNode(n8);
      n4.addNode(n5);
      break;
    default:
      jj_la1[85] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      n10 = Block(null);
        n9 = new NodeChoice(n10, 0, 2);
      break;
    case SEMICOLON:
      n12 = jj_consume_token(SEMICOLON);
        n11 = JTBToolkit.makeNodeToken(n12);
        n9 = new NodeChoice(n11, 1, 2);
      break;
    default:
      jj_la1[86] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new MethodDeclaration(n0, n2, n3, n4, n9);}
    throw new Error("Missing return statement in function");
  }

  final public MethodDeclarator MethodDeclarator() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  FormalParameters n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n1 = jj_consume_token(IDENTIFIER);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = FormalParameters(null);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        jj_la1[87] = jj_gen;
        break label_27;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(LBRACKET);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n8 = jj_consume_token(RBRACKET);
      n7 = JTBToolkit.makeNodeToken(n8);
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    {if (true) return new MethodDeclarator(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public FormalParameters FormalParameters(List<Token> tokens) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  FormalParameter n4 = null;
  NodeListOptional n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  FormalParameter n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  // --- user BNFProduction java block ---
  Token first, last;
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n1 = jj_consume_token(LPAREN);
    n0 = JTBToolkit.makeNodeToken(n1);
    first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 147:
    case IDENTIFIER:
      n5 = new NodeListOptional();
      n3 = new NodeSequence(2);
      n4 = FormalParameter();
      n3.addNode(n4);
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[88] = jj_gen;
          break label_28;
        }
        n6 = new NodeSequence(2);
        n8 = jj_consume_token(COMMA);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = FormalParameter();
        n6.addNode(n9);
        n5.addNode(n6);
      }
      n5.nodes.trimToSize();
      n3.addNode(n5);
      n2.addNode(n3);
      break;
    default:
      jj_la1[89] = jj_gen;
      ;
    }
    last = getToken(0);
    n11 = jj_consume_token(RPAREN);
    n10 = JTBToolkit.makeNodeToken(n11);
    if (last.next != first) {
      // i.e., this is not an empty sequence
      Token t = first;
      while (true) {
        tokens.add(t);
        if (t == last)
          break;
        t = t.next;
      }
    }
    {if (true) return new FormalParameters(n0, n2, n10);}
    throw new Error("Missing return statement in function");
  }

  final public FormalParameter FormalParameter() throws ParseException {
  // --- JTB generated node declarations ---
  Modifiers n0 = null;
  Type n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  VariableDeclaratorId n5 = null;
    n0 = Modifiers();
    n1 = Type();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 142:
      n4 = jj_consume_token(142);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[90] = jj_gen;
      ;
    }
    n5 = VariableDeclaratorId();
    {if (true) return new FormalParameter(n0, n1, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public ConstructorDeclaration ConstructorDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  TypeParameters n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  FormalParameters n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NameList n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeOptional n12 = new NodeOptional();
  ExplicitConstructorInvocation n13 = null;
  NodeListOptional n14 = new NodeListOptional();
  BlockStatement n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      n1 = TypeParameters();
      n0.addNode(n1);
      break;
    default:
      jj_la1[91] = jj_gen;
      ;
    }
    n3 = jj_consume_token(IDENTIFIER);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = FormalParameters(null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      n6 = new NodeSequence(2);
      n8 = jj_consume_token(THROWS);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
      n9 = NameList();
      n6.addNode(n9);
      n5.addNode(n6);
      break;
    default:
      jj_la1[92] = jj_gen;
      ;
    }
    n11 = jj_consume_token(LBRACE);
    n10 = JTBToolkit.makeNodeToken(n11);
    if (jj_2_13(2147483647)) {
      n13 = ExplicitConstructorInvocation();
      n12.addNode(n13);
    } else {
      ;
    }
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
      case 147:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[93] = jj_gen;
        break label_29;
      }
      n15 = BlockStatement();
      n14.addNode(n15);
    }
    n14.nodes.trimToSize();
    n17 = jj_consume_token(RBRACE);
    n16 = JTBToolkit.makeNodeToken(n17);
    {if (true) return new ConstructorDeclaration(n0, n2, n4, n5, n10, n12, n14, n16);}
    throw new Error("Missing return statement in function");
  }

  final public ExplicitConstructorInvocation ExplicitConstructorInvocation() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Arguments n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeSequence n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeSequence n9 = null;
  PrimaryExpression n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  Arguments n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
    if (jj_2_15(2147483647)) {
      n1 = new NodeSequence(3);
      n3 = jj_consume_token(THIS);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n4 = Arguments(null);
      n1.addNode(n4);
      n6 = jj_consume_token(SEMICOLON);
      n5 = JTBToolkit.makeNodeToken(n6);
      n1.addNode(n5);
      n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case IDENTIFIER:
      n7 = new NodeSequence(4);
        if (jj_2_14(2)) {
        n9 = new NodeSequence(2);
          n10 = PrimaryExpression();
        n9.addNode(n10);
          n12 = jj_consume_token(DOT);
        n11 = JTBToolkit.makeNodeToken(n12);
        n9.addNode(n11);
        n8.addNode(n9);
        } else {
          ;
        }
      n7.addNode(n8);
        n14 = jj_consume_token(SUPER);
      n13 = JTBToolkit.makeNodeToken(n14);
      n7.addNode(n13);
        n15 = Arguments(null);
      n7.addNode(n15);
        n17 = jj_consume_token(SEMICOLON);
      n16 = JTBToolkit.makeNodeToken(n17);
      n7.addNode(n16);
      n0 = new NodeChoice(n7, 1, 2);
        break;
      default:
        jj_la1[94] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new ExplicitConstructorInvocation(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Initializer Initializer() throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  Block n3 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      n2 = jj_consume_token(STATIC);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0.addNode(n1);
      break;
    default:
      jj_la1[95] = jj_gen;
      ;
    }
    n3 = Block(null);
    {if (true) return new Initializer(n0, n3);}
    throw new Error("Missing return statement in function");
  }

  final public Type Type() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  ReferenceType n1 = null;
  PrimitiveType n2 = null;
    if (jj_2_16(2)) {
      n1 = ReferenceType();
      n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        n2 = PrimitiveType();
      n0 = new NodeChoice(n2, 1, 2);
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new Type(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ReferenceType ReferenceType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  PrimitiveType n2 = null;
  NodeList n3 = new NodeList();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeSequence n9 = null;
  ClassOrInterfaceType n10 = null;
  NodeListOptional n11 = new NodeListOptional();
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
      n1 = new NodeSequence(2);
      n2 = PrimitiveType();
      n1.addNode(n2);
      label_30:
      while (true) {
        n4 = new NodeSequence(2);
        n6 = jj_consume_token(LBRACKET);
        n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
        n8 = jj_consume_token(RBRACKET);
        n7 = JTBToolkit.makeNodeToken(n8);
        n4.addNode(n7);
        n3.addNode(n4);
        if (jj_2_17(2)) {
          ;
        } else {
          break label_30;
        }
      }
      n3.nodes.trimToSize();
      n1.addNode(n3);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case IDENTIFIER:
      n9 = new NodeSequence(2);
      n10 = ClassOrInterfaceType();
      n9.addNode(n10);
      label_31:
      while (true) {
        if (jj_2_18(2)) {
          ;
        } else {
          break label_31;
        }
        n12 = new NodeSequence(2);
        n14 = jj_consume_token(LBRACKET);
        n13 = JTBToolkit.makeNodeToken(n14);
        n12.addNode(n13);
        n16 = jj_consume_token(RBRACKET);
        n15 = JTBToolkit.makeNodeToken(n16);
        n12.addNode(n15);
        n11.addNode(n12);
      }
      n11.nodes.trimToSize();
      n9.addNode(n11);
      n0 = new NodeChoice(n9, 1, 2);
      break;
    default:
      jj_la1[97] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ReferenceType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ClassOrInterfaceType ClassOrInterfaceType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  TypeArguments n3 = null;
  NodeListOptional n4 = new NodeListOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeOptional n10 = null;
  TypeArguments n11 = null;
    n1 = jj_consume_token(IDENTIFIER);
    n0 = JTBToolkit.makeNodeToken(n1);
    if (jj_2_19(2)) {
      n3 = TypeArguments();
      n2.addNode(n3);
    } else {
      ;
    }
    label_32:
    while (true) {
      if (jj_2_20(2)) {
        ;
      } else {
        break label_32;
      }
      n10 = new NodeOptional();
      n5 = new NodeSequence(3);
      n7 = jj_consume_token(DOT);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n9 = jj_consume_token(IDENTIFIER);
      n8 = JTBToolkit.makeNodeToken(n9);
      n5.addNode(n8);
      if (jj_2_21(2)) {
        n11 = TypeArguments();
        n10.addNode(n11);
      } else {
        ;
      }
      n5.addNode(n10);
      n4.addNode(n5);
    }
    n4.nodes.trimToSize();
    {if (true) return new ClassOrInterfaceType(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public TypeArguments TypeArguments() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TypeArgument n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  TypeArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(LT);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TypeArgument();
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[98] = jj_gen;
        break label_33;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = TypeArgument();
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    n9 = jj_consume_token(GT);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new TypeArguments(n0, n2, n3, n8);}
    throw new Error("Missing return statement in function");
  }

  final public TypeArgument TypeArgument() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  ReferenceType n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  WildcardBounds n6 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      n1 = ReferenceType();
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case HOOK:
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(HOOK);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
      case SUPER:
        n6 = WildcardBounds();
        n5.addNode(n6);
        break;
      default:
        jj_la1[99] = jj_gen;
        ;
      }
      n2.addNode(n5);
      n0 = new NodeChoice(n2, 1, 2);
      break;
    default:
      jj_la1[100] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new TypeArgument(n0);}
    throw new Error("Missing return statement in function");
  }

  final public WildcardBounds WildcardBounds() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  ReferenceType n4 = null;
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  ReferenceType n8 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      n1 = new NodeSequence(2);
      n3 = jj_consume_token(EXTENDS);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n4 = ReferenceType();
      n1.addNode(n4);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case SUPER:
      n5 = new NodeSequence(2);
      n7 = jj_consume_token(SUPER);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n8 = ReferenceType();
      n5.addNode(n8);
      n0 = new NodeChoice(n5, 1, 2);
      break;
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new WildcardBounds(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PrimitiveType PrimitiveType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
      n2 = jj_consume_token(BOOLEAN);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 8);
      break;
    case CHAR:
      n4 = jj_consume_token(CHAR);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 8);
      break;
    case BYTE:
      n6 = jj_consume_token(BYTE);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 8);
      break;
    case SHORT:
      n8 = jj_consume_token(SHORT);
      n7 = JTBToolkit.makeNodeToken(n8);
      n0 = new NodeChoice(n7, 3, 8);
      break;
    case INT:
      n10 = jj_consume_token(INT);
      n9 = JTBToolkit.makeNodeToken(n10);
      n0 = new NodeChoice(n9, 4, 8);
      break;
    case LONG:
      n12 = jj_consume_token(LONG);
      n11 = JTBToolkit.makeNodeToken(n12);
      n0 = new NodeChoice(n11, 5, 8);
      break;
    case FLOAT:
      n14 = jj_consume_token(FLOAT);
      n13 = JTBToolkit.makeNodeToken(n14);
      n0 = new NodeChoice(n13, 6, 8);
      break;
    case DOUBLE:
      n16 = jj_consume_token(DOUBLE);
      n15 = JTBToolkit.makeNodeToken(n16);
      n0 = new NodeChoice(n15, 7, 8);
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new PrimitiveType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ResultType ResultType(List<Token> tokens) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  Type n3 = null;
  // --- user BNFProduction java block ---
  Token first = getToken(1);
  if (tokens == null)
    tokens = new ArrayList<Token>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      n2 = jj_consume_token(VOID);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      n3 = Type();
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[103] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    Token last = getToken(0);
    Token t = first;
    while (true) {
      tokens.add(t);
      if (t == last)
        break;
      t = t.next;
    }
    {if (true) return new ResultType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Name Name(List<Token> tokens) throws ParseException {
  // --- JTB generated node declarations ---
  JavaIdentifier n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  JavaIdentifier n5 = null;
  // --- user BNFProduction java block ---
  if (tokens == null)
    tokens = new ArrayList<Token>();
  Token first = getToken(1);
    n0 = JavaIdentifier();
    label_34:
    while (true) {
      if (jj_2_22(2)) {
        ;
      } else {
        break label_34;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(DOT);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = JavaIdentifier();
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    Token last = getToken(0);
    Token t = first;
    while (true) {
      tokens.add(t);
      if (t == last)
        break;
      t = t.next;
    }
    {if (true) return new Name(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public NameList NameList() throws ParseException {
  // --- JTB generated node declarations ---
  Name n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Name n5 = null;
    n0 = Name(null);
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[104] = jj_gen;
        break label_35;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = Name(null);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new NameList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public Expression Expression(List<Token> tokens) throws ParseException {
  // --- JTB generated node declarations ---
  ConditionalExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  AssignmentOperator n3 = null;
  Expression n4 = null;
  // --- user BNFProduction java block ---
  Token first = getToken(1);
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n0 = ConditionalExpression();
    if (jj_2_23(2)) {
      n2 = new NodeSequence(2);
      n3 = AssignmentOperator();
      n2.addNode(n3);
      n4 = Expression(null);
      n2.addNode(n4);
      n1.addNode(n2);
    } else {
      ;
    }
    Token last = getToken(0);
    Token t = first;
    while (true) {
      tokens.add(t);
      if (t == last)
        break;
      t = t.next;
    }
    {if (true) return new Expression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public AssignmentOperator AssignmentOperator() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      n2 = jj_consume_token(ASSIGN);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 12);
      break;
    case STARASSIGN:
      n4 = jj_consume_token(STARASSIGN);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 12);
      break;
    case SLASHASSIGN:
      n6 = jj_consume_token(SLASHASSIGN);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 12);
      break;
    case REMASSIGN:
      n8 = jj_consume_token(REMASSIGN);
      n7 = JTBToolkit.makeNodeToken(n8);
      n0 = new NodeChoice(n7, 3, 12);
      break;
    case PLUSASSIGN:
      n10 = jj_consume_token(PLUSASSIGN);
      n9 = JTBToolkit.makeNodeToken(n10);
      n0 = new NodeChoice(n9, 4, 12);
      break;
    case MINUSASSIGN:
      n12 = jj_consume_token(MINUSASSIGN);
      n11 = JTBToolkit.makeNodeToken(n12);
      n0 = new NodeChoice(n11, 5, 12);
      break;
    case 143:
      n14 = jj_consume_token(143);
      n13 = JTBToolkit.makeNodeToken(n14);
      n0 = new NodeChoice(n13, 6, 12);
      break;
    case 144:
      n16 = jj_consume_token(144);
      n15 = JTBToolkit.makeNodeToken(n16);
      n0 = new NodeChoice(n15, 7, 12);
      break;
    case 145:
      n18 = jj_consume_token(145);
      n17 = JTBToolkit.makeNodeToken(n18);
      n0 = new NodeChoice(n17, 8, 12);
      break;
    case ANDASSIGN:
      n20 = jj_consume_token(ANDASSIGN);
      n19 = JTBToolkit.makeNodeToken(n20);
      n0 = new NodeChoice(n19, 9, 12);
      break;
    case XORASSIGN:
      n22 = jj_consume_token(XORASSIGN);
      n21 = JTBToolkit.makeNodeToken(n22);
      n0 = new NodeChoice(n21, 10, 12);
      break;
    case ORASSIGN:
      n24 = jj_consume_token(ORASSIGN);
      n23 = JTBToolkit.makeNodeToken(n24);
      n0 = new NodeChoice(n23, 11, 12);
      break;
    default:
      jj_la1[105] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new AssignmentOperator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ConditionalExpression ConditionalExpression() throws ParseException {
  // --- JTB generated node declarations ---
  ConditionalOrExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Expression n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  Expression n8 = null;
    n0 = ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      n2 = new NodeSequence(4);
      n4 = jj_consume_token(HOOK);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = Expression(null);
      n2.addNode(n5);
      n7 = jj_consume_token(COLON);
      n6 = JTBToolkit.makeNodeToken(n7);
      n2.addNode(n6);
      n8 = Expression(null);
      n2.addNode(n8);
      n1.addNode(n2);
      break;
    default:
      jj_la1[106] = jj_gen;
      ;
    }
    {if (true) return new ConditionalExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public ConditionalOrExpression ConditionalOrExpression() throws ParseException {
  // --- JTB generated node declarations ---
  ConditionalAndExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  ConditionalAndExpression n5 = null;
    n0 = ConditionalAndExpression();
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC_OR:
        ;
        break;
      default:
        jj_la1[107] = jj_gen;
        break label_36;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(SC_OR);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = ConditionalAndExpression();
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new ConditionalOrExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public ConditionalAndExpression ConditionalAndExpression() throws ParseException {
  // --- JTB generated node declarations ---
  InclusiveOrExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  InclusiveOrExpression n5 = null;
    n0 = InclusiveOrExpression();
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC_AND:
        ;
        break;
      default:
        jj_la1[108] = jj_gen;
        break label_37;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(SC_AND);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = InclusiveOrExpression();
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new ConditionalAndExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public InclusiveOrExpression InclusiveOrExpression() throws ParseException {
  // --- JTB generated node declarations ---
  ExclusiveOrExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  ExclusiveOrExpression n5 = null;
    n0 = ExclusiveOrExpression();
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[109] = jj_gen;
        break label_38;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(BIT_OR);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = ExclusiveOrExpression();
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new InclusiveOrExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public ExclusiveOrExpression ExclusiveOrExpression() throws ParseException {
  // --- JTB generated node declarations ---
  AndExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  AndExpression n5 = null;
    n0 = AndExpression();
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        jj_la1[110] = jj_gen;
        break label_39;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(XOR);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = AndExpression();
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new ExclusiveOrExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public AndExpression AndExpression() throws ParseException {
  // --- JTB generated node declarations ---
  EqualityExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  EqualityExpression n5 = null;
    n0 = EqualityExpression();
    label_40:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[111] = jj_gen;
        break label_40;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(BIT_AND);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = EqualityExpression();
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new AndExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public EqualityExpression EqualityExpression() throws ParseException {
  // --- JTB generated node declarations ---
  InstanceOfExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  InstanceOfExpression n8 = null;
    n0 = InstanceOfExpression();
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[112] = jj_gen;
        break label_41;
      }
      n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        n5 = jj_consume_token(EQ);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3 = new NodeChoice(n4, 0, 2);
        break;
      case NE:
        n7 = jj_consume_token(NE);
          n6 = JTBToolkit.makeNodeToken(n7);
          n3 = new NodeChoice(n6, 1, 2);
        break;
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      n8 = InstanceOfExpression();
      n2.addNode(n8);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new EqualityExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public InstanceOfExpression InstanceOfExpression() throws ParseException {
  // --- JTB generated node declarations ---
  RelationalExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Type n5 = null;
    n0 = RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(INSTANCEOF);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = Type();
      n2.addNode(n5);
      n1.addNode(n2);
      break;
    default:
      jj_la1[114] = jj_gen;
      ;
    }
    {if (true) return new InstanceOfExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public RelationalExpression RelationalExpression() throws ParseException {
  // --- JTB generated node declarations ---
  ShiftExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  ShiftExpression n12 = null;
    n0 = ShiftExpression();
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case LE:
      case GE:
      case GT:
        ;
        break;
      default:
        jj_la1[115] = jj_gen;
        break label_42;
      }
      n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        n5 = jj_consume_token(LT);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3 = new NodeChoice(n4, 0, 4);
        break;
      case GT:
        n7 = jj_consume_token(GT);
          n6 = JTBToolkit.makeNodeToken(n7);
          n3 = new NodeChoice(n6, 1, 4);
        break;
      case LE:
        n9 = jj_consume_token(LE);
          n8 = JTBToolkit.makeNodeToken(n9);
          n3 = new NodeChoice(n8, 2, 4);
        break;
      case GE:
        n11 = jj_consume_token(GE);
          n10 = JTBToolkit.makeNodeToken(n11);
          n3 = new NodeChoice(n10, 3, 4);
        break;
      default:
        jj_la1[116] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      n12 = ShiftExpression();
      n2.addNode(n12);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new RelationalExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public ShiftExpression ShiftExpression() throws ParseException {
  // --- JTB generated node declarations ---
  AdditiveExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  RUnsignedShift n6 = null;
  RSignedShift n7 = null;
  AdditiveExpression n8 = null;
    n0 = AdditiveExpression();
    label_43:
    while (true) {
      if (jj_2_24(1)) {
        ;
      } else {
        break label_43;
      }
      n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 146:
        n5 = jj_consume_token(146);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3 = new NodeChoice(n4, 0, 3);
        break;
      default:
        jj_la1[117] = jj_gen;
        if (jj_2_25(1)) {
          n6 = RUnsignedShift();
          n3 = new NodeChoice(n6, 1, 3);
        } else if (jj_2_26(1)) {
          n7 = RSignedShift();
          n3 = new NodeChoice(n7, 2, 3);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      n2.addNode(n3);
      n8 = AdditiveExpression();
      n2.addNode(n8);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new ShiftExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

/* We use productions to match >>>, >> and > so that we can keep the type declaration syntax with generics clean */
// MMa 07/2012 : moved from after TryStatement() and renamed from RSIGNEDSHIFT()
  final public RSignedShift RSignedShift() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    if (getToken(1).kind == GT && ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    n1 = jj_consume_token(RSIGNEDSHIFT);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new RSignedShift(n0);}
    throw new Error("Missing return statement in function");
  }

// MMa 07/2012 : moved from after TryStatement() and renamed from RUNSIGNEDSHIFT()
  final public RUnsignedShift RUnsignedShift() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    if (getToken(1).kind == GT && ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    n1 = jj_consume_token(RUNSIGNEDSHIFT);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new RUnsignedShift(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AdditiveExpression AdditiveExpression() throws ParseException {
  // --- JTB generated node declarations ---
  MultiplicativeExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  MultiplicativeExpression n8 = null;
    n0 = MultiplicativeExpression();
    label_44:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[118] = jj_gen;
        break label_44;
      }
      n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        n5 = jj_consume_token(PLUS);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3 = new NodeChoice(n4, 0, 2);
        break;
      case MINUS:
        n7 = jj_consume_token(MINUS);
          n6 = JTBToolkit.makeNodeToken(n7);
          n3 = new NodeChoice(n6, 1, 2);
        break;
      default:
        jj_la1[119] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      n8 = MultiplicativeExpression();
      n2.addNode(n8);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new AdditiveExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {
  // --- JTB generated node declarations ---
  UnaryExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  UnaryExpression n10 = null;
    n0 = UnaryExpression();
    label_45:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case REM:
        ;
        break;
      default:
        jj_la1[120] = jj_gen;
        break label_45;
      }
      n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        n5 = jj_consume_token(STAR);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3 = new NodeChoice(n4, 0, 3);
        break;
      case SLASH:
        n7 = jj_consume_token(SLASH);
          n6 = JTBToolkit.makeNodeToken(n7);
          n3 = new NodeChoice(n6, 1, 3);
        break;
      case REM:
        n9 = jj_consume_token(REM);
          n8 = JTBToolkit.makeNodeToken(n9);
          n3 = new NodeChoice(n8, 2, 3);
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      n10 = UnaryExpression();
      n2.addNode(n10);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new MultiplicativeExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryExpression UnaryExpression() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  UnaryExpression n7 = null;
  PreIncrementExpression n8 = null;
  PreDecrementExpression n9 = null;
  UnaryExpressionNotPlusMinus n10 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      n1 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        n4 = jj_consume_token(PLUS);
          n3 = JTBToolkit.makeNodeToken(n4);
          n2 = new NodeChoice(n3, 0, 2);
        break;
      case MINUS:
        n6 = jj_consume_token(MINUS);
          n5 = JTBToolkit.makeNodeToken(n6);
          n2 = new NodeChoice(n5, 1, 2);
        break;
      default:
        jj_la1[122] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n1.addNode(n2);
      n7 = UnaryExpression();
      n1.addNode(n7);
      n0 = new NodeChoice(n1, 0, 4);
      break;
    case INCR:
      n8 = PreIncrementExpression();
      n0 = new NodeChoice(n8, 1, 4);
      break;
    case DECR:
      n9 = PreDecrementExpression();
      n0 = new NodeChoice(n9, 2, 4);
      break;
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case IDENTIFIER:
      n10 = UnaryExpressionNotPlusMinus();
      n0 = new NodeChoice(n10, 3, 4);
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new UnaryExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PreIncrementExpression PreIncrementExpression() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  PrimaryExpression n2 = null;
    n1 = jj_consume_token(INCR);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrimaryExpression();
    {if (true) return new PreIncrementExpression(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public PreDecrementExpression PreDecrementExpression() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  PrimaryExpression n2 = null;
    n1 = jj_consume_token(DECR);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrimaryExpression();
    {if (true) return new PreDecrementExpression(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryExpressionNotPlusMinus UnaryExpressionNotPlusMinus() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  UnaryExpression n7 = null;
  CastExpression n8 = null;
  PostfixExpression n9 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
      n1 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        n4 = jj_consume_token(TILDE);
          n3 = JTBToolkit.makeNodeToken(n4);
          n2 = new NodeChoice(n3, 0, 2);
        break;
      case BANG:
        n6 = jj_consume_token(BANG);
          n5 = JTBToolkit.makeNodeToken(n6);
          n2 = new NodeChoice(n5, 1, 2);
        break;
      default:
        jj_la1[124] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n1.addNode(n2);
      n7 = UnaryExpression();
      n1.addNode(n7);
      n0 = new NodeChoice(n1, 0, 3);
      break;
    default:
      jj_la1[125] = jj_gen;
      if (jj_2_27(2147483647)) {
        n8 = CastExpression();
      n0 = new NodeChoice(n8, 1, 3);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case IDENTIFIER:
          n9 = PostfixExpression();
      n0 = new NodeChoice(n9, 2, 3);
          break;
        default:
          jj_la1[126] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    {if (true) return new UnaryExpressionNotPlusMinus(n0);}
    throw new Error("Missing return statement in function");
  }

/*
 * This production is to determine lookahead only.
 * The LOOKAHEAD specifications below are not used, but they are there just to indicate that we know about this.
 */
  final public CastLookahead CastLookahead() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  PrimitiveType n4 = null;
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  Type n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeSequence n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  Type n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeChoice n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  NodeToken n26 = null;
  Token n27 = null;
  NodeToken n28 = null;
  Token n29 = null;
  NodeToken n30 = null;
  Token n31 = null;
  NodeToken n32 = null;
  Token n33 = null;
  Literal n34 = null;
    if (jj_2_28(2)) {
      n1 = new NodeSequence(2);
      n3 = jj_consume_token(LPAREN);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n4 = PrimitiveType();
      n1.addNode(n4);
      n0 = new NodeChoice(n1, 0, 3);
    } else if (jj_2_29(2147483647)) {
      n5 = new NodeSequence(4);
      n7 = jj_consume_token(LPAREN);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n8 = Type();
      n5.addNode(n8);
      n10 = jj_consume_token(LBRACKET);
      n9 = JTBToolkit.makeNodeToken(n10);
      n5.addNode(n9);
      n12 = jj_consume_token(RBRACKET);
      n11 = JTBToolkit.makeNodeToken(n12);
      n5.addNode(n11);
      n0 = new NodeChoice(n5, 1, 3);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
      n13 = new NodeSequence(4);
        n15 = jj_consume_token(LPAREN);
      n14 = JTBToolkit.makeNodeToken(n15);
      n13.addNode(n14);
        n16 = Type();
      n13.addNode(n16);
        n18 = jj_consume_token(RPAREN);
      n17 = JTBToolkit.makeNodeToken(n18);
      n13.addNode(n17);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          n21 = jj_consume_token(TILDE);
          n20 = JTBToolkit.makeNodeToken(n21);
          n19 = new NodeChoice(n20, 0, 8);
          break;
        case BANG:
          n23 = jj_consume_token(BANG);
          n22 = JTBToolkit.makeNodeToken(n23);
          n19 = new NodeChoice(n22, 1, 8);
          break;
        case LPAREN:
          n25 = jj_consume_token(LPAREN);
          n24 = JTBToolkit.makeNodeToken(n25);
          n19 = new NodeChoice(n24, 2, 8);
          break;
        case IDENTIFIER:
          n27 = jj_consume_token(IDENTIFIER);
          n26 = JTBToolkit.makeNodeToken(n27);
          n19 = new NodeChoice(n26, 3, 8);
          break;
        case THIS:
          n29 = jj_consume_token(THIS);
          n28 = JTBToolkit.makeNodeToken(n29);
          n19 = new NodeChoice(n28, 4, 8);
          break;
        case SUPER:
          n31 = jj_consume_token(SUPER);
          n30 = JTBToolkit.makeNodeToken(n31);
          n19 = new NodeChoice(n30, 5, 8);
          break;
        case NEW:
          n33 = jj_consume_token(NEW);
          n32 = JTBToolkit.makeNodeToken(n33);
          n19 = new NodeChoice(n32, 6, 8);
          break;
        case FALSE:
        case NULL:
        case TRUE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
          n34 = Literal();
          n19 = new NodeChoice(n34, 7, 8);
          break;
        default:
          jj_la1[127] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      n13.addNode(n19);
      n0 = new NodeChoice(n13, 2, 3);
        break;
      default:
        jj_la1[128] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new CastLookahead(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PostfixExpression PostfixExpression() throws ParseException {
  // --- JTB generated node declarations ---
  PrimaryExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n0 = PrimaryExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        n4 = jj_consume_token(INCR);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2 = new NodeChoice(n3, 0, 2);
        break;
      case DECR:
        n6 = jj_consume_token(DECR);
        n5 = JTBToolkit.makeNodeToken(n6);
        n2 = new NodeChoice(n5, 1, 2);
        break;
      default:
        jj_la1[129] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n1.addNode(n2);
      break;
    default:
      jj_la1[130] = jj_gen;
      ;
    }
    {if (true) return new PostfixExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public CastExpression CastExpression() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Type n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  UnaryExpression n7 = null;
  NodeSequence n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  Type n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  UnaryExpressionNotPlusMinus n14 = null;
    if (jj_2_30(2147483647)) {
      n1 = new NodeSequence(4);
      n3 = jj_consume_token(LPAREN);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n4 = Type();
      n1.addNode(n4);
      n6 = jj_consume_token(RPAREN);
      n5 = JTBToolkit.makeNodeToken(n6);
      n1.addNode(n5);
      n7 = UnaryExpression();
      n1.addNode(n7);
      n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
      n8 = new NodeSequence(4);
        n10 = jj_consume_token(LPAREN);
      n9 = JTBToolkit.makeNodeToken(n10);
      n8.addNode(n9);
        n11 = Type();
      n8.addNode(n11);
        n13 = jj_consume_token(RPAREN);
      n12 = JTBToolkit.makeNodeToken(n13);
      n8.addNode(n12);
        n14 = UnaryExpressionNotPlusMinus();
      n8.addNode(n14);
      n0 = new NodeChoice(n8, 1, 2);
        break;
      default:
        jj_la1[131] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new CastExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PrimaryExpression PrimaryExpression() throws ParseException {
  // --- JTB generated node declarations ---
  PrimaryPrefix n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  PrimarySuffix n2 = null;
    n0 = PrimaryPrefix();
    label_46:
    while (true) {
      if (jj_2_31(2)) {
        ;
      } else {
        break label_46;
      }
      n2 = PrimarySuffix();
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new PrimaryExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public MemberSelector MemberSelector() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TypeArguments n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    n1 = jj_consume_token(DOT);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TypeArguments();
    n4 = jj_consume_token(IDENTIFIER);
    n3 = JTBToolkit.makeNodeToken(n4);
    {if (true) return new MemberSelector(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public PrimaryPrefix PrimaryPrefix() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Literal n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeSequence n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  Expression n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  AllocationExpression n17 = null;
  NodeSequence n18 = null;
  ResultType n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  Name n24 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      n1 = Literal();
      n0 = new NodeChoice(n1, 0, 7);
      break;
    case THIS:
      n3 = jj_consume_token(THIS);
      n2 = JTBToolkit.makeNodeToken(n3);
      n0 = new NodeChoice(n2, 1, 7);
      break;
    case SUPER:
      n4 = new NodeSequence(3);
      n6 = jj_consume_token(SUPER);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n8 = jj_consume_token(DOT);
      n7 = JTBToolkit.makeNodeToken(n8);
      n4.addNode(n7);
      n10 = jj_consume_token(IDENTIFIER);
      n9 = JTBToolkit.makeNodeToken(n10);
      n4.addNode(n9);
      n0 = new NodeChoice(n4, 2, 7);
      break;
    case LPAREN:
      n11 = new NodeSequence(3);
      n13 = jj_consume_token(LPAREN);
      n12 = JTBToolkit.makeNodeToken(n13);
      n11.addNode(n12);
      n14 = Expression(null);
      n11.addNode(n14);
      n16 = jj_consume_token(RPAREN);
      n15 = JTBToolkit.makeNodeToken(n16);
      n11.addNode(n15);
      n0 = new NodeChoice(n11, 3, 7);
      break;
    case NEW:
      n17 = AllocationExpression();
      n0 = new NodeChoice(n17, 4, 7);
      break;
    default:
      jj_la1[132] = jj_gen;
      if (jj_2_32(2147483647)) {
      n18 = new NodeSequence(3);
        n19 = ResultType(null);
      n18.addNode(n19);
        n21 = jj_consume_token(DOT);
      n20 = JTBToolkit.makeNodeToken(n21);
      n18.addNode(n20);
        n23 = jj_consume_token(CLASS);
      n22 = JTBToolkit.makeNodeToken(n23);
      n18.addNode(n22);
      n0 = new NodeChoice(n18, 5, 7);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case IDENTIFIER:
          n24 = Name(null);
      n0 = new NodeChoice(n24, 6, 7);
          break;
        default:
          jj_la1[133] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    {if (true) return new PrimaryPrefix(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PrimarySuffix PrimarySuffix() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  AllocationExpression n9 = null;
  MemberSelector n10 = null;
  NodeSequence n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  Expression n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeSequence n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  Arguments n22 = null;
    if (jj_2_33(2)) {
      n1 = new NodeSequence(2);
      n3 = jj_consume_token(DOT);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n5 = jj_consume_token(THIS);
      n4 = JTBToolkit.makeNodeToken(n5);
      n1.addNode(n4);
      n0 = new NodeChoice(n1, 0, 6);
    } else if (jj_2_34(2)) {
      n6 = new NodeSequence(2);
      n8 = jj_consume_token(DOT);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
      n9 = AllocationExpression();
      n6.addNode(n9);
      n0 = new NodeChoice(n6, 1, 6);
    } else if (jj_2_35(3)) {
      n10 = MemberSelector();
      n0 = new NodeChoice(n10, 2, 6);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      n11 = new NodeSequence(3);
        n13 = jj_consume_token(LBRACKET);
      n12 = JTBToolkit.makeNodeToken(n13);
      n11.addNode(n12);
        n14 = Expression(null);
      n11.addNode(n14);
        n16 = jj_consume_token(RBRACKET);
      n15 = JTBToolkit.makeNodeToken(n16);
      n11.addNode(n15);
      n0 = new NodeChoice(n11, 3, 6);
        break;
      case DOT:
      n17 = new NodeSequence(2);
        n19 = jj_consume_token(DOT);
      n18 = JTBToolkit.makeNodeToken(n19);
      n17.addNode(n18);
        n21 = jj_consume_token(IDENTIFIER);
      n20 = JTBToolkit.makeNodeToken(n21);
      n17.addNode(n20);
      n0 = new NodeChoice(n17, 4, 6);
        break;
      case LPAREN:
        n22 = Arguments(null);
      n0 = new NodeChoice(n22, 5, 6);
        break;
      default:
        jj_la1[134] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new PrimarySuffix(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Literal Literal() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  BooleanLiteral n9 = null;
  NullLiteral n10 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      n2 = jj_consume_token(INTEGER_LITERAL);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 6);
      break;
    case FLOATING_POINT_LITERAL:
      n4 = jj_consume_token(FLOATING_POINT_LITERAL);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 6);
      break;
    case CHARACTER_LITERAL:
      n6 = jj_consume_token(CHARACTER_LITERAL);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 6);
      break;
    case STRING_LITERAL:
      n8 = jj_consume_token(STRING_LITERAL);
      n7 = JTBToolkit.makeNodeToken(n8);
      n0 = new NodeChoice(n7, 3, 6);
      break;
    case FALSE:
    case TRUE:
      n9 = BooleanLiteral();
      n0 = new NodeChoice(n9, 4, 6);
      break;
    case NULL:
      n10 = NullLiteral();
      n0 = new NodeChoice(n10, 5, 6);
      break;
    default:
      jj_la1[135] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Literal(n0);}
    throw new Error("Missing return statement in function");
  }

  final public IntegerLiteral IntegerLiteral() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(INTEGER_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    try {
      jtbrt_IntegerLiteral = Integer.parseInt(token.image);
    }
    catch (NumberFormatException e) {
      {if (true) throw new Error();}
    }
    {if (true) return new IntegerLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BooleanLiteral BooleanLiteral() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      n2 = jj_consume_token(TRUE);
      n1 = JTBToolkit.makeNodeToken(n2);
      jtbrt_BooleanLiteral = true;
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case FALSE:
      n4 = jj_consume_token(FALSE);
      n3 = JTBToolkit.makeNodeToken(n4);
      jtbrt_BooleanLiteral = false;
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[136] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new BooleanLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StringLiteral StringLiteral() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  // --- user BNFProduction java block ---
  Token t;
    n1 = jj_consume_token(STRING_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    t = n1;
    jtbrt_StringLiteral = remove_escapes_and_quotes(t, t.image);
    {if (true) return new StringLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public NullLiteral NullLiteral() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(NULL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new NullLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Arguments Arguments(List<Token> tokens) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  ArgumentList n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  // --- user BNFProduction java block ---
  Token first, last;
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n1 = jj_consume_token(LPAREN);
    n0 = JTBToolkit.makeNodeToken(n1);
    first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:
      n3 = ArgumentList();
      n2.addNode(n3);
      break;
    default:
      jj_la1[137] = jj_gen;
      ;
    }
    last = getToken(0);
    n5 = jj_consume_token(RPAREN);
    n4 = JTBToolkit.makeNodeToken(n5);
    if (last.next != first) {
      // i.e., this is not an empty sequence
      Token t = first;
      while (true) {
        tokens.add(t);
        if (t == last)
          break;
        t = t.next;
      }
    }
    {if (true) return new Arguments(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public ArgumentList ArgumentList() throws ParseException {
  // --- JTB generated node declarations ---
  Expression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Expression n5 = null;
    n0 = Expression(null);
    label_47:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[138] = jj_gen;
        break label_47;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = Expression(null);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new ArgumentList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public AllocationExpression AllocationExpression() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  PrimitiveType n4 = null;
  ArrayDimsAndInits n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  ClassOrInterfaceType n9 = null;
  NodeOptional n10 = new NodeOptional();
  TypeArguments n11 = null;
  NodeChoice n12 = null;
  ArrayDimsAndInits n13 = null;
  NodeSequence n14 = null;
  Arguments n15 = null;
  NodeOptional n16 = new NodeOptional();
  ClassOrInterfaceBody n17 = null;
    if (jj_2_36(2)) {
      n1 = new NodeSequence(3);
      n3 = jj_consume_token(NEW);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n4 = PrimitiveType();
      n1.addNode(n4);
      n5 = ArrayDimsAndInits();
      n1.addNode(n5);
      n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEW:
      n6 = new NodeSequence(4);
        n8 = jj_consume_token(NEW);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
        n9 = ClassOrInterfaceType();
      n6.addNode(n9);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          n11 = TypeArguments();
        n10.addNode(n11);
          break;
        default:
          jj_la1[139] = jj_gen;
          ;
        }
      n6.addNode(n10);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          n13 = ArrayDimsAndInits();
          n12 = new NodeChoice(n13, 0, 2);
          break;
        case LPAREN:
          n14 = new NodeSequence(2);
          n15 = Arguments(null);
          n14.addNode(n15);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            n17 = ClassOrInterfaceBody(false, null);
            n16.addNode(n17);
            break;
          default:
            jj_la1[140] = jj_gen;
            ;
          }
          n14.addNode(n16);
          n12 = new NodeChoice(n14, 1, 2);
          break;
        default:
          jj_la1[141] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      n6.addNode(n12);
      n0 = new NodeChoice(n6, 1, 2);
        break;
      default:
        jj_la1[142] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new AllocationExpression(n0);}
    throw new Error("Missing return statement in function");
  }

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]"
 */
  final public ArrayDimsAndInits ArrayDimsAndInits() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeList n2 = new NodeList();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  Expression n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeListOptional n9 = new NodeListOptional();
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeSequence n15 = null;
  NodeList n16 = new NodeList();
  NodeSequence n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  ArrayInitializer n22 = null;
    if (jj_2_39(2)) {
      n1 = new NodeSequence(2);
      label_48:
      while (true) {
        n3 = new NodeSequence(3);
        n5 = jj_consume_token(LBRACKET);
        n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
        n6 = Expression(null);
        n3.addNode(n6);
        n8 = jj_consume_token(RBRACKET);
        n7 = JTBToolkit.makeNodeToken(n8);
        n3.addNode(n7);
        n2.addNode(n3);
        if (jj_2_37(2)) {
          ;
        } else {
          break label_48;
        }
      }
      n2.nodes.trimToSize();
      n1.addNode(n2);
      label_49:
      while (true) {
        if (jj_2_38(2)) {
          ;
        } else {
          break label_49;
        }
        n10 = new NodeSequence(2);
        n12 = jj_consume_token(LBRACKET);
        n11 = JTBToolkit.makeNodeToken(n12);
        n10.addNode(n11);
        n14 = jj_consume_token(RBRACKET);
        n13 = JTBToolkit.makeNodeToken(n14);
        n10.addNode(n13);
        n9.addNode(n10);
      }
      n9.nodes.trimToSize();
      n1.addNode(n9);
      n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      n15 = new NodeSequence(2);
        label_50:
        while (true) {
        n17 = new NodeSequence(2);
          n19 = jj_consume_token(LBRACKET);
        n18 = JTBToolkit.makeNodeToken(n19);
        n17.addNode(n18);
          n21 = jj_consume_token(RBRACKET);
        n20 = JTBToolkit.makeNodeToken(n21);
        n17.addNode(n20);
        n16.addNode(n17);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ;
            break;
          default:
            jj_la1[143] = jj_gen;
            break label_50;
          }
        }
      n16.nodes.trimToSize();
      n15.addNode(n16);
        n22 = ArrayInitializer();
      n15.addNode(n22);
      n0 = new NodeChoice(n15, 1, 2);
        break;
      default:
        jj_la1[144] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new ArrayDimsAndInits(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Statement Statement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  LabeledStatement n1 = null;
  AssertStatement n2 = null;
  Block n3 = null;
  EmptyStatement n4 = null;
  NodeSequence n5 = null;
  StatementExpression n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  SwitchStatement n9 = null;
  IfStatement n10 = null;
  WhileStatement n11 = null;
  DoStatement n12 = null;
  ForStatement n13 = null;
  BreakStatement n14 = null;
  ContinueStatement n15 = null;
  ReturnStatement n16 = null;
  ThrowStatement n17 = null;
  SynchronizedStatement n18 = null;
  TryStatement n19 = null;
    if (jj_2_40(2)) {
      n1 = LabeledStatement();
      n0 = new NodeChoice(n1, 0, 16);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSERT:
        n2 = AssertStatement();
      n0 = new NodeChoice(n2, 1, 16);
        break;
      case LBRACE:
        n3 = Block(null);
      n0 = new NodeChoice(n3, 2, 16);
        break;
      case SEMICOLON:
        n4 = EmptyStatement();
      n0 = new NodeChoice(n4, 3, 16);
        break;
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case INCR:
      case DECR:
      case IDENTIFIER:
      n5 = new NodeSequence(2);
        n6 = StatementExpression();
      n5.addNode(n6);
        n8 = jj_consume_token(SEMICOLON);
      n7 = JTBToolkit.makeNodeToken(n8);
      n5.addNode(n7);
      n0 = new NodeChoice(n5, 4, 16);
        break;
      case SWITCH:
        n9 = SwitchStatement();
      n0 = new NodeChoice(n9, 5, 16);
        break;
      case IF:
        n10 = IfStatement();
      n0 = new NodeChoice(n10, 6, 16);
        break;
      case WHILE:
        n11 = WhileStatement();
      n0 = new NodeChoice(n11, 7, 16);
        break;
      case DO:
        n12 = DoStatement();
      n0 = new NodeChoice(n12, 8, 16);
        break;
      case FOR:
        n13 = ForStatement();
      n0 = new NodeChoice(n13, 9, 16);
        break;
      case BREAK:
        n14 = BreakStatement();
      n0 = new NodeChoice(n14, 10, 16);
        break;
      case CONTINUE:
        n15 = ContinueStatement();
      n0 = new NodeChoice(n15, 11, 16);
        break;
      case RETURN:
        n16 = ReturnStatement();
      n0 = new NodeChoice(n16, 12, 16);
        break;
      case THROW:
        n17 = ThrowStatement();
      n0 = new NodeChoice(n17, 13, 16);
        break;
      case SYNCHRONIZED:
        n18 = SynchronizedStatement();
      n0 = new NodeChoice(n18, 14, 16);
        break;
      case TRY:
        n19 = TryStatement();
      n0 = new NodeChoice(n19, 15, 16);
        break;
      default:
        jj_la1[145] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new Statement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AssertStatement AssertStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Expression n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Expression n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(ASSERT);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Expression(null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(COLON);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = Expression(null);
      n4.addNode(n7);
      n3.addNode(n4);
      break;
    default:
      jj_la1[146] = jj_gen;
      ;
    }
    n9 = jj_consume_token(SEMICOLON);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new AssertStatement(n0, n2, n3, n8);}
    throw new Error("Missing return statement in function");
  }

  final public LabeledStatement LabeledStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Statement n4 = null;
    n1 = jj_consume_token(IDENTIFIER);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(COLON);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Statement();
    {if (true) return new LabeledStatement(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public Block Block(List<Token> tokens) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  BlockStatement n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  // --- user BNFProduction java block ---
  Token first, last;
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n1 = jj_consume_token(LBRACE);
    n0 = JTBToolkit.makeNodeToken(n1);
    first = getToken(1);
    label_51:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
      case 147:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[147] = jj_gen;
        break label_51;
      }
      n3 = BlockStatement();
      n2.addNode(n3);
    }
    n2.nodes.trimToSize();
    last = getToken(0);
    n5 = jj_consume_token(RBRACE);
    n4 = JTBToolkit.makeNodeToken(n5);
    if (last.next != first) {
      // i.e., this is not an empty sequence
      Token t = first;
      while (true) {
        tokens.add(t);
        if (t == last)
          break;
        t = t.next;
      }
    }
    {if (true) return new Block(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public BlockStatement BlockStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  LocalVariableDeclaration n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Statement n5 = null;
  ClassOrInterfaceDeclaration n6 = null;
    if (jj_2_41(2147483647)) {
      n1 = new NodeSequence(2);
      n2 = LocalVariableDeclaration();
      n1.addNode(n2);
      n4 = jj_consume_token(SEMICOLON);
      n3 = JTBToolkit.makeNodeToken(n4);
      n1.addNode(n3);
      n0 = new NodeChoice(n1, 0, 3);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
      case IDENTIFIER:
        n5 = Statement();
      n0 = new NodeChoice(n5, 1, 3);
        break;
      case CLASS:
      case INTERFACE:
        n6 = ClassOrInterfaceDeclaration();
      n0 = new NodeChoice(n6, 2, 3);
        break;
      default:
        jj_la1[148] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new BlockStatement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public LocalVariableDeclaration LocalVariableDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  VariableModifiers n0 = null;
  Type n1 = null;
  VariableDeclarator n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  VariableDeclarator n7 = null;
    n0 = VariableModifiers();
    n1 = Type();
    n2 = VariableDeclarator();
    label_52:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[149] = jj_gen;
        break label_52;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = VariableDeclarator();
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    {if (true) return new LocalVariableDeclaration(n0, n1, n2, n3);}
    throw new Error("Missing return statement in function");
  }

// added MMa 06/2012
  final public VariableModifiers VariableModifiers() throws ParseException {
  // --- JTB generated node declarations ---
  NodeListOptional n0 = new NodeListOptional();
  NodeChoice n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Annotation n4 = null;
    label_53:
    while (true) {
      if (jj_2_42(2)) {
        ;
      } else {
        break label_53;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINAL:
        n3 = jj_consume_token(FINAL);
          n2 = JTBToolkit.makeNodeToken(n3);
          n1 = new NodeChoice(n2, 0, 2);
        break;
      case 147:
        n4 = Annotation();
          n1 = new NodeChoice(n4, 1, 2);
        break;
      default:
        jj_la1[150] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n0.addNode(n1);
    }
    n0.nodes.trimToSize();
    {if (true) return new VariableModifiers(n0);}
    throw new Error("Missing return statement in function");
  }

  final public EmptyStatement EmptyStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SEMICOLON);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new EmptyStatement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StatementExpression StatementExpression() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  PreIncrementExpression n1 = null;
  PreDecrementExpression n2 = null;
  NodeSequence n3 = null;
  PrimaryExpression n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeChoice n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeSequence n11 = null;
  AssignmentOperator n12 = null;
  Expression n13 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
      n1 = PreIncrementExpression();
      n0 = new NodeChoice(n1, 0, 3);
      break;
    case DECR:
      n2 = PreDecrementExpression();
      n0 = new NodeChoice(n2, 1, 3);
      break;
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case IDENTIFIER:
      n3 = new NodeSequence(2);
      n4 = PrimaryExpression();
      n3.addNode(n4);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
      case INCR:
      case DECR:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case 143:
      case 144:
      case 145:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INCR:
          n8 = jj_consume_token(INCR);
          n7 = JTBToolkit.makeNodeToken(n8);
          n6 = new NodeChoice(n7, 0, 3);
          break;
        case DECR:
          n10 = jj_consume_token(DECR);
          n9 = JTBToolkit.makeNodeToken(n10);
          n6 = new NodeChoice(n9, 1, 3);
          break;
        case ASSIGN:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case 143:
        case 144:
        case 145:
          n11 = new NodeSequence(2);
          n12 = AssignmentOperator();
          n11.addNode(n12);
          n13 = Expression(null);
          n11.addNode(n13);
          n6 = new NodeChoice(n11, 2, 3);
          break;
        default:
          jj_la1[151] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n5.addNode(n6);
        break;
      default:
        jj_la1[152] = jj_gen;
        ;
      }
      n3.addNode(n5);
      n0 = new NodeChoice(n3, 2, 3);
      break;
    default:
      jj_la1[153] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new StatementExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SwitchStatement SwitchStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeListOptional n9 = new NodeListOptional();
  NodeSequence n10 = null;
  SwitchLabel n11 = null;
  NodeListOptional n12 = null;
  BlockStatement n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
    n1 = jj_consume_token(SWITCH);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression(null);
    n6 = jj_consume_token(RPAREN);
    n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(LBRACE);
    n7 = JTBToolkit.makeNodeToken(n8);
    label_54:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
      case _DEFAULT:
        ;
        break;
      default:
        jj_la1[154] = jj_gen;
        break label_54;
      }
      n12 = new NodeListOptional();
      n10 = new NodeSequence(2);
      n11 = SwitchLabel();
      n10.addNode(n11);
      label_55:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case ASSERT:
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CLASS:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case FOR:
        case IF:
        case INT:
        case INTERFACE:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case LBRACE:
        case SEMICOLON:
        case INCR:
        case DECR:
        case 147:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[155] = jj_gen;
          break label_55;
        }
        n13 = BlockStatement();
        n12.addNode(n13);
      }
      n12.nodes.trimToSize();
      n10.addNode(n12);
      n9.addNode(n10);
    }
    n9.nodes.trimToSize();
    n15 = jj_consume_token(RBRACE);
    n14 = JTBToolkit.makeNodeToken(n15);
    {if (true) return new SwitchStatement(n0, n2, n4, n5, n7, n9, n14);}
    throw new Error("Missing return statement in function");
  }

  final public SwitchLabel SwitchLabel() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE:
      n1 = new NodeSequence(3);
      n3 = jj_consume_token(CASE);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n4 = Expression(null);
      n1.addNode(n4);
      n6 = jj_consume_token(COLON);
      n5 = JTBToolkit.makeNodeToken(n6);
      n1.addNode(n5);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case _DEFAULT:
      n7 = new NodeSequence(2);
      n9 = jj_consume_token(_DEFAULT);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      n11 = jj_consume_token(COLON);
      n10 = JTBToolkit.makeNodeToken(n11);
      n7.addNode(n10);
      n0 = new NodeChoice(n7, 1, 2);
      break;
    default:
      jj_la1[156] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new SwitchLabel(n0);}
    throw new Error("Missing return statement in function");
  }

  final public IfStatement IfStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Statement n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  Statement n12 = null;
    n1 = jj_consume_token(IF);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression(null);
    n6 = jj_consume_token(RPAREN);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      n9 = new NodeSequence(2);
      n11 = jj_consume_token(ELSE);
      n10 = JTBToolkit.makeNodeToken(n11);
      n9.addNode(n10);
      n12 = Statement();
      n9.addNode(n12);
      n8.addNode(n9);
      break;
    default:
      jj_la1[157] = jj_gen;
      ;
    }
    {if (true) return new IfStatement(n0, n2, n4, n5, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public WhileStatement WhileStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Statement n7 = null;
    n1 = jj_consume_token(WHILE);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression(null);
    n6 = jj_consume_token(RPAREN);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
    {if (true) return new WhileStatement(n0, n2, n4, n5, n7);}
    throw new Error("Missing return statement in function");
  }

  final public DoStatement DoStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Statement n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Expression n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
    n1 = jj_consume_token(DO);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Statement();
    n4 = jj_consume_token(WHILE);
    n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(LPAREN);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Expression(null);
    n9 = jj_consume_token(RPAREN);
    n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(SEMICOLON);
    n10 = JTBToolkit.makeNodeToken(n11);
    {if (true) return new DoStatement(n0, n2, n3, n5, n7, n8, n10);}
    throw new Error("Missing return statement in function");
  }

  final public ForStatement ForStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeChoice n4 = null;
  NodeSequence n5 = null;
  VariableModifiers n6 = null;
  Type n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  Expression n12 = null;
  NodeSequence n13 = null;
  NodeOptional n14 = new NodeOptional();
  ForInit n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeOptional n18 = new NodeOptional();
  Expression n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeOptional n22 = new NodeOptional();
  ForUpdate n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  Statement n26 = null;
    n1 = jj_consume_token(FOR);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
    n2 = JTBToolkit.makeNodeToken(n3);
    if (jj_2_43(2147483647)) {
        n5 = new NodeSequence(5);
      n6 = VariableModifiers();
        n5.addNode(n6);
      n7 = Type();
        n5.addNode(n7);
      n9 = jj_consume_token(IDENTIFIER);
        n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
      n11 = jj_consume_token(COLON);
        n10 = JTBToolkit.makeNodeToken(n11);
        n5.addNode(n10);
      n12 = Expression(null);
        n5.addNode(n12);
        n4 = new NodeChoice(n5, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case SEMICOLON:
      case INCR:
      case DECR:
      case 147:
      case IDENTIFIER:
        n13 = new NodeSequence(5);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case INCR:
        case DECR:
        case 147:
        case IDENTIFIER:
          n15 = ForInit();
          n14.addNode(n15);
          break;
        default:
          jj_la1[158] = jj_gen;
          ;
        }
        n13.addNode(n14);
        n17 = jj_consume_token(SEMICOLON);
        n16 = JTBToolkit.makeNodeToken(n17);
        n13.addNode(n16);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case BANG:
        case TILDE:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case IDENTIFIER:
          n19 = Expression(null);
          n18.addNode(n19);
          break;
        default:
          jj_la1[159] = jj_gen;
          ;
        }
        n13.addNode(n18);
        n21 = jj_consume_token(SEMICOLON);
        n20 = JTBToolkit.makeNodeToken(n21);
        n13.addNode(n20);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case INCR:
        case DECR:
        case IDENTIFIER:
          n23 = ForUpdate();
          n22.addNode(n23);
          break;
        default:
          jj_la1[160] = jj_gen;
          ;
        }
        n13.addNode(n22);
        n4 = new NodeChoice(n13, 1, 2);
        break;
      default:
        jj_la1[161] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    n25 = jj_consume_token(RPAREN);
    n24 = JTBToolkit.makeNodeToken(n25);
    n26 = Statement();
    {if (true) return new ForStatement(n0, n2, n4, n24, n26);}
    throw new Error("Missing return statement in function");
  }

  final public ForInit ForInit() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  LocalVariableDeclaration n1 = null;
  StatementExpressionList n2 = null;
    if (jj_2_44(2147483647)) {
      n1 = LocalVariableDeclaration();
      n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case INCR:
      case DECR:
      case IDENTIFIER:
        n2 = StatementExpressionList();
      n0 = new NodeChoice(n2, 1, 2);
        break;
      default:
        jj_la1[162] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new ForInit(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StatementExpressionList StatementExpressionList() throws ParseException {
  // --- JTB generated node declarations ---
  StatementExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  StatementExpression n5 = null;
    n0 = StatementExpression();
    label_56:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[163] = jj_gen;
        break label_56;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = StatementExpression();
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new StatementExpressionList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public ForUpdate ForUpdate() throws ParseException {
  // --- JTB generated node declarations ---
  StatementExpressionList n0 = null;
    n0 = StatementExpressionList();
    {if (true) return new ForUpdate(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BreakStatement BreakStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(BREAK);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n4 = jj_consume_token(IDENTIFIER);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[164] = jj_gen;
      ;
    }
    n6 = jj_consume_token(SEMICOLON);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new BreakStatement(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public ContinueStatement ContinueStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(CONTINUE);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n4 = jj_consume_token(IDENTIFIER);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[165] = jj_gen;
      ;
    }
    n6 = jj_consume_token(SEMICOLON);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new ContinueStatement(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public ReturnStatement ReturnStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  Expression n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  // --- user BNFProduction java block ---
  Token t;
    n1 = jj_consume_token(RETURN);
    n0 = JTBToolkit.makeNodeToken(n1);
    t = n1;
    // Add if statement to prevent subsequent code generated from being dead code
    if (inAction) {
      t.image = "{if (true) return";
      jumpPatched = true;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:
      n3 = Expression(null);
      n2.addNode(n3);
      break;
    default:
      jj_la1[166] = jj_gen;
      ;
    }
    n5 = jj_consume_token(SEMICOLON);
    n4 = JTBToolkit.makeNodeToken(n5);
    t = n5;
    // Add closing brace for above if statement
    if (inAction) {
      t.image = ";}";
    }
    {if (true) return new ReturnStatement(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public ThrowStatement ThrowStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Expression n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  // --- user BNFProduction java block ---
  Token t;
    n1 = jj_consume_token(THROW);
    n0 = JTBToolkit.makeNodeToken(n1);
    t = n1;
    // Add if statement to prevent subsequent code generated from being dead code
    if (inAction) {
      t.image = "{if (true) throw";
      jumpPatched = true;
    }
    n2 = Expression(null);
    n4 = jj_consume_token(SEMICOLON);
    n3 = JTBToolkit.makeNodeToken(n4);
    t = n4;
    // Add closing brace for above if statement
    if (inAction) {
      t.image = ";}";
    }
    {if (true) return new ThrowStatement(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public SynchronizedStatement SynchronizedStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Block n7 = null;
    n1 = jj_consume_token(SYNCHRONIZED);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression(null);
    n6 = jj_consume_token(RPAREN);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Block(null);
    {if (true) return new SynchronizedStatement(n0, n2, n4, n5, n7);}
    throw new Error("Missing return statement in function");
  }

  final public TryStatement TryStatement() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Block n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  FormalParameter n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  Block n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  Block n17 = null;
    n1 = jj_consume_token(TRY);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Block(null);
    label_57:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CATCH:
        ;
        break;
      default:
        jj_la1[167] = jj_gen;
        break label_57;
      }
      n4 = new NodeSequence(5);
      n6 = jj_consume_token(CATCH);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n8 = jj_consume_token(LPAREN);
      n7 = JTBToolkit.makeNodeToken(n8);
      n4.addNode(n7);
      n9 = FormalParameter();
      n4.addNode(n9);
      n11 = jj_consume_token(RPAREN);
      n10 = JTBToolkit.makeNodeToken(n11);
      n4.addNode(n10);
      n12 = Block(null);
      n4.addNode(n12);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINALLY:
      n14 = new NodeSequence(2);
      n16 = jj_consume_token(FINALLY);
      n15 = JTBToolkit.makeNodeToken(n16);
      n14.addNode(n15);
      n17 = Block(null);
      n14.addNode(n17);
      n13.addNode(n14);
      break;
    default:
      jj_la1[168] = jj_gen;
      ;
    }
    {if (true) return new TryStatement(n0, n2, n3, n13);}
    throw new Error("Missing return statement in function");
  }

  final public Annotation Annotation() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NormalAnnotation n1 = null;
  SingleMemberAnnotation n2 = null;
  MarkerAnnotation n3 = null;
    if (jj_2_45(2147483647)) {
      n1 = NormalAnnotation();
      n0 = new NodeChoice(n1, 0, 3);
    } else if (jj_2_46(2147483647)) {
      n2 = SingleMemberAnnotation();
      n0 = new NodeChoice(n2, 1, 3);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 147:
        n3 = MarkerAnnotation();
      n0 = new NodeChoice(n3, 2, 3);
        break;
      default:
        jj_la1[169] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new Annotation(n0);}
    throw new Error("Missing return statement in function");
  }

  final public NormalAnnotation NormalAnnotation() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Name n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  MemberValuePairs n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n1 = jj_consume_token(147);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name(null);
    n4 = jj_consume_token(LPAREN);
    n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n6 = MemberValuePairs();
      n5.addNode(n6);
      break;
    default:
      jj_la1[170] = jj_gen;
      ;
    }
    n8 = jj_consume_token(RPAREN);
    n7 = JTBToolkit.makeNodeToken(n8);
    {if (true) return new NormalAnnotation(n0, n2, n3, n5, n7);}
    throw new Error("Missing return statement in function");
  }

  final public MarkerAnnotation MarkerAnnotation() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Name n2 = null;
    n1 = jj_consume_token(147);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name(null);
    {if (true) return new MarkerAnnotation(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public SingleMemberAnnotation SingleMemberAnnotation() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Name n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  MemberValue n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(147);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name(null);
    n4 = jj_consume_token(LPAREN);
    n3 = JTBToolkit.makeNodeToken(n4);
    n5 = MemberValue();
    n7 = jj_consume_token(RPAREN);
    n6 = JTBToolkit.makeNodeToken(n7);
    {if (true) return new SingleMemberAnnotation(n0, n2, n3, n5, n6);}
    throw new Error("Missing return statement in function");
  }

  final public MemberValuePairs MemberValuePairs() throws ParseException {
  // --- JTB generated node declarations ---
  MemberValuePair n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  MemberValuePair n5 = null;
    n0 = MemberValuePair();
    label_58:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[171] = jj_gen;
        break label_58;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = MemberValuePair();
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new MemberValuePairs(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public MemberValuePair MemberValuePair() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  MemberValue n4 = null;
    n1 = jj_consume_token(IDENTIFIER);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(ASSIGN);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = MemberValue();
    {if (true) return new MemberValuePair(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public MemberValue MemberValue() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Annotation n1 = null;
  MemberValueArrayInitializer n2 = null;
  ConditionalExpression n3 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 147:
      n1 = Annotation();
      n0 = new NodeChoice(n1, 0, 3);
      break;
    case LBRACE:
      n2 = MemberValueArrayInitializer();
      n0 = new NodeChoice(n2, 1, 3);
      break;
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:
      n3 = ConditionalExpression();
      n0 = new NodeChoice(n3, 2, 3);
      break;
    default:
      jj_la1[172] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new MemberValue(n0);}
    throw new Error("Missing return statement in function");
  }

  final public MemberValueArrayInitializer MemberValueArrayInitializer() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  MemberValue n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  MemberValue n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    n1 = jj_consume_token(LBRACE);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = MemberValue();
    label_59:
    while (true) {
      if (jj_2_47(2)) {
        ;
      } else {
        break label_59;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = MemberValue();
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      n10 = jj_consume_token(COMMA);
      n9 = JTBToolkit.makeNodeToken(n10);
      n8.addNode(n9);
      break;
    default:
      jj_la1[173] = jj_gen;
      ;
    }
    n12 = jj_consume_token(RBRACE);
    n11 = JTBToolkit.makeNodeToken(n12);
    {if (true) return new MemberValueArrayInitializer(n0, n2, n3, n8, n11);}
    throw new Error("Missing return statement in function");
  }

  final public AnnotationTypeDeclaration AnnotationTypeDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  AnnotationTypeBody n6 = null;
    n1 = jj_consume_token(147);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INTERFACE);
    n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(IDENTIFIER);
    n4 = JTBToolkit.makeNodeToken(n5);
    n6 = AnnotationTypeBody();
    {if (true) return new AnnotationTypeDeclaration(n0, n2, n4, n6);}
    throw new Error("Missing return statement in function");
  }

  final public AnnotationTypeBody AnnotationTypeBody() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  AnnotationTypeMemberDeclaration n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
    n1 = jj_consume_token(LBRACE);
    n0 = JTBToolkit.makeNodeToken(n1);
    label_60:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case SEMICOLON:
      case 147:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[174] = jj_gen;
        break label_60;
      }
      n3 = AnnotationTypeMemberDeclaration();
      n2.addNode(n3);
    }
    n2.nodes.trimToSize();
    n5 = jj_consume_token(RBRACE);
    n4 = JTBToolkit.makeNodeToken(n5);
    {if (true) return new AnnotationTypeBody(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public AnnotationTypeMemberDeclaration AnnotationTypeMemberDeclaration() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  Modifiers n2 = null;
  NodeChoice n3 = null;
  NodeSequence n4 = null;
  Type n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeOptional n12 = new NodeOptional();
  DefaultValue n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  ClassOrInterfaceDeclaration n16 = null;
  EnumDeclaration n17 = null;
  AnnotationTypeDeclaration n18 = null;
  FieldDeclaration n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case CLASS:
    case DOUBLE:
    case ENUM:
    case FINAL:
    case FLOAT:
    case INT:
    case INTERFACE:
    case LONG:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 147:
    case IDENTIFIER:
      n1 = new NodeSequence(2);
      n2 = Modifiers();
      n1.addNode(n2);
      if (jj_2_48(2147483647)) {
          n4 = new NodeSequence(6);
        n5 = Type();
          n4.addNode(n5);
        n7 = jj_consume_token(IDENTIFIER);
          n6 = JTBToolkit.makeNodeToken(n7);
          n4.addNode(n6);
        n9 = jj_consume_token(LPAREN);
          n8 = JTBToolkit.makeNodeToken(n9);
          n4.addNode(n8);
        n11 = jj_consume_token(RPAREN);
          n10 = JTBToolkit.makeNodeToken(n11);
          n4.addNode(n10);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case _DEFAULT:
          n13 = DefaultValue();
            n12.addNode(n13);
          break;
        default:
          jj_la1[175] = jj_gen;
          ;
        }
          n4.addNode(n12);
        n15 = jj_consume_token(SEMICOLON);
          n14 = JTBToolkit.makeNodeToken(n15);
          n4.addNode(n14);
          n3 = new NodeChoice(n4, 0, 5);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case INTERFACE:
          n16 = ClassOrInterfaceDeclaration();
          n3 = new NodeChoice(n16, 1, 5);
          break;
        case ENUM:
          n17 = EnumDeclaration();
          n3 = new NodeChoice(n17, 2, 5);
          break;
        case 147:
          n18 = AnnotationTypeDeclaration();
          n3 = new NodeChoice(n18, 3, 5);
          break;
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case IDENTIFIER:
          n19 = FieldDeclaration();
          n3 = new NodeChoice(n19, 4, 5);
          break;
        default:
          jj_la1[176] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      n1.addNode(n3);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case SEMICOLON:
      n21 = jj_consume_token(SEMICOLON);
      n20 = JTBToolkit.makeNodeToken(n21);
      n0 = new NodeChoice(n20, 1, 2);
      break;
    default:
      jj_la1[177] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new AnnotationTypeMemberDeclaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public DefaultValue DefaultValue() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  MemberValue n2 = null;
    n1 = jj_consume_token(_DEFAULT);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = MemberValue();
    {if (true) return new DefaultValue(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  private boolean jj_3_14() {
    if (jj_3R_61()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_395() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_237()) return true;
    return false;
  }

  private boolean jj_3R_123() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) jj_scanpos = xsp;
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_87()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_87()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_318() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_3R_228()) return true;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_3R_303()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_318()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_3R_227()) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_237()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_395()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_364() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_190()) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_87()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_349() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_190()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_364()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) return true;
    }
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_203() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_320() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_319() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_311() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_319()) {
    jj_scanpos = xsp;
    if (jj_3R_320()) return true;
    }
    if (jj_3R_295()) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_414() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_295()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_311()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_112() {
    Token xsp;
    if (jj_3R_181()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_181()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_336() {
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_329() {
    if (jj_3R_350()) return true;
    return false;
  }

  private boolean jj_3R_413() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_335() {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_328() {
    if (jj_3R_349()) return true;
    return false;
  }

  private boolean jj_3_48() {
    if (jj_3R_82()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_404() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_413()) {
    jj_scanpos = xsp;
    if (jj_3R_414()) return true;
    }
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_327() {
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_285()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_264() {
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_3R_285()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_305()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_35() {
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_322() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_332()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_333()) return true;
    xsp = jj_scanpos;
    if (jj_3R_334()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_335()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_336()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_238() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_263()) {
    jj_scanpos = xsp;
    if (jj_3R_264()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_327()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_328()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_329()) jj_scanpos = xsp;
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_405() {
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_scan_token(BIT_OR)) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_3R_112()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_113()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_394() {
    if (jj_3R_404()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_405()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_33() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_298() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_265()) return true;
    return false;
  }

  private boolean jj_3R_98() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_3R_265()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_298()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_394()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_379() {
    if (jj_scan_token(142)) return true;
    return false;
  }

  private boolean jj_3R_367() {
    if (jj_3R_115()) return true;
    if (jj_3R_82()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_379()) jj_scanpos = xsp;
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_239()) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_3R_239()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_287()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3_32() {
    if (jj_3R_99()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_412() {
    if (jj_3R_91()) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_411() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_3R_99()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_410() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_403() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_410()) {
    jj_scanpos = xsp;
    if (jj_3R_411()) {
    jj_scanpos = xsp;
    if (jj_3R_412()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_scan_token(SC_AND)) return true;
    if (jj_3R_226()) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_3R_226()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_267()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_368() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_294() {
    if (jj_3R_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_403()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_3R_302()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_3R_301()) return true;
    return false;
  }

  private boolean jj_3R_354() {
    if (jj_3R_367()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_368()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_273() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_292()) {
    jj_scanpos = xsp;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(STRICTFP)) return true;
    return false;
  }

  private boolean jj_3R_333() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_354()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_scan_token(SUPER)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_scan_token(SC_OR)) return true;
    if (jj_3R_211()) return true;
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3_47() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_3R_211()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_242()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_3R_203()) return true;
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(TRANSIENT)) return true;
    return false;
  }

  private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_47()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_304()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_scan_token(141)) return true;
    return false;
  }

  private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_111()) jj_scanpos = xsp;
    if (jj_3R_62()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(NATIVE)) return true;
    return false;
  }

  private boolean jj_3R_272() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(LT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_66()) jj_scanpos = xsp;
    if (jj_3R_67()) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(ABSTRACT)) return true;
    return false;
  }

  private boolean jj_3R_358() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_3R_193()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_229()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_340() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_333()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_358()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_108() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  private boolean jj_3R_103() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_42()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_89()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(PROTECTED)) return true;
    return false;
  }

  private boolean jj_3R_151() {
    if (jj_scan_token(ORASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_343() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(XORASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_342() {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_scan_token(ANDASSIGN)) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_3R_98()) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_scan_token(145)) return true;
    return false;
  }

  private boolean jj_3R_386() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_3R_109()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_31()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_scan_token(144)) return true;
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(143)) return true;
    return false;
  }

  private boolean jj_3R_115() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_3R_103()) return true;
    if (jj_3R_82()) return true;
    if (jj_3R_337()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_386()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_296()) return true;
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(MINUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_324() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_339()) jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    if (jj_3R_340()) return true;
    xsp = jj_scanpos;
    if (jj_3R_341()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_342()) {
    jj_scanpos = xsp;
    if (jj_3R_343()) return true;
    }
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_3R_296()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_297()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(PLUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_scan_token(REMASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_392() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_373()) return true;
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_scan_token(SLASHASSIGN)) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_3R_238()) return true;
    return false;
  }

  private boolean jj_3_41() {
    if (jj_3R_103()) return true;
    if (jj_3R_82()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_scan_token(STARASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_3R_237()) return true;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_91() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_391() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_344()) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(147)) return true;
    if (jj_3R_106()) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_108()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_3R_236()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_389() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_391()) {
    jj_scanpos = xsp;
    if (jj_3R_392()) return true;
    }
    return false;
  }

  private boolean jj_3R_289() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_209() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_12() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(147)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_3R_85()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_12()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_418() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_288()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_289()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_417() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_266() {
    if (jj_3R_286()) return true;
    return false;
  }

  private boolean jj_3R_409() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_417()) {
    jj_scanpos = xsp;
    if (jj_3R_418()) return true;
    }
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_390() {
    if (jj_3R_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_409()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(147)) return true;
    if (jj_3R_106()) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_266()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_3R_91()) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_187()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_152()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_23()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3_46() {
    if (jj_scan_token(147)) return true;
    if (jj_3R_106()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_3R_203()) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_scan_token(147)) return true;
    if (jj_3R_106()) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    }
    return false;
  }

  private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) return true;
    }
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_3R_207()) return true;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(SUPER)) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_3R_205()) return true;
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_237()) return true;
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_370() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_369() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_356() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_370()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_355() {
    if (jj_3R_106()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_369()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_402() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_393() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(LT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_271() {
    if (jj_scan_token(ASSERT)) return true;
    if (jj_3R_92()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_393()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_29() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_357() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_401() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_367()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_3R_356()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_357()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_119()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_401()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_402()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_262() {
    if (jj_3R_284()) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_scan_token(_EOF)) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_3R_283()) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_3R_90()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_22()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_scan_token(_TOKEN_MGR_DECLS)) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_260() {
    if (jj_3R_282()) return true;
    return false;
  }

  private boolean jj_3R_96() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_scan_token(_SKIP)) return true;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_3R_281()) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_3R_280()) return true;
    return false;
  }

  private boolean jj_3R_338() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_scan_token(_MORE)) return true;
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_3R_279()) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(_SPECIAL_TOKEN)) return true;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_3R_278()) return true;
    return false;
  }

  private boolean jj_3R_323() {
    if (jj_3R_82()) return true;
    if (jj_3R_337()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_338()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_scan_token(_TOKEN)) return true;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_254() {
    if (jj_3R_276()) return true;
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_scan_token(_JAVACODE)) return true;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_3R_275()) return true;
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_scan_token(_PARSER_END)) return true;
    return false;
  }

  private boolean jj_3R_252() {
    if (jj_3R_274()) return true;
    return false;
  }

  private boolean jj_3R_283() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_scan_token(_PARSER_BEGIN)) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_82()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_83()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_scan_token(_IGNORE_CASE)) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_3R_273()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_scan_token(_LOOKAHEAD)) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_250() {
    if (jj_3R_272()) return true;
    return false;
  }

  private boolean jj_3R_316() {
    if (jj_3R_324()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_3R_61()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_249() {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_315() {
    if (jj_3R_323()) return true;
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) return true;
    }
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_3R_271()) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_314() {
    if (jj_3R_322()) return true;
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_90() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_313() {
    if (jj_3R_321()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_62()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_237() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_40()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) {
    jj_scanpos = xsp;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) {
    jj_scanpos = xsp;
    if (jj_3R_258()) {
    jj_scanpos = xsp;
    if (jj_3R_259()) {
    jj_scanpos = xsp;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_382() {
    if (jj_3R_390()) return true;
    return false;
  }

  private boolean jj_3R_312() {
    if (jj_3R_238()) return true;
    return false;
  }

  private boolean jj_3R_381() {
    if (jj_3R_389()) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_388() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_3R_115()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_312()) {
    jj_scanpos = xsp;
    if (jj_3R_313()) {
    jj_scanpos = xsp;
    if (jj_3R_314()) {
    jj_scanpos = xsp;
    if (jj_3R_315()) {
    jj_scanpos = xsp;
    if (jj_3R_316()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_387() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_380() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_387()) {
    jj_scanpos = xsp;
    if (jj_3R_388()) return true;
    }
    if (jj_3R_344()) return true;
    return false;
  }

  private boolean jj_3R_299() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_373() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_380()) {
    jj_scanpos = xsp;
    if (jj_3R_381()) {
    jj_scanpos = xsp;
    if (jj_3R_382()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_61()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_400() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_243() {
    Token xsp;
    if (jj_3R_268()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_268()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_281() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_400()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_290() {
    if (jj_3R_299()) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_269() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_290()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_399() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_362() {
    if (jj_3R_373()) return true;
    return false;
  }

  private boolean jj_3_39() {
    Token xsp;
    if (jj_3_37()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_37()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_38()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_361() {
    if (jj_3R_302()) return true;
    return false;
  }

  private boolean jj_3R_230() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_39()) {
    jj_scanpos = xsp;
    if (jj_3R_243()) return true;
    }
    return false;
  }

  private boolean jj_3R_280() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_399()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_360() {
    if (jj_3R_301()) return true;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_300() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) return true;
    }
    return false;
  }

  private boolean jj_3R_372() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_371() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_270() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_190()) return true;
    return false;
  }

  private boolean jj_3R_398() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_359() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_371()) {
    jj_scanpos = xsp;
    if (jj_3R_372()) return true;
    }
    if (jj_3R_344()) return true;
    return false;
  }

  private boolean jj_3R_344() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_359()) {
    jj_scanpos = xsp;
    if (jj_3R_360()) {
    jj_scanpos = xsp;
    if (jj_3R_361()) {
    jj_scanpos = xsp;
    if (jj_3R_362()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_190()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_235()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_291() {
    if (jj_3R_300()) return true;
    return false;
  }

  private boolean jj_3R_279() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_398()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(HOOK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_291()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_127() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) return true;
    }
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3R_416() {
    if (jj_3R_421()) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_3R_222()) return true;
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_3R_87()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_3R_230()) return true;
    return false;
  }

  private boolean jj_3R_385() {
    if (jj_scan_token(REM)) return true;
    return false;
  }

  private boolean jj_3R_384() {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_383() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_422() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_273()) return true;
    return false;
  }

  private boolean jj_3R_421() {
    if (jj_3R_273()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_422()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3R_374() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_383()) {
    jj_scanpos = xsp;
    if (jj_3R_384()) {
    jj_scanpos = xsp;
    if (jj_3R_385()) return true;
    }
    }
    if (jj_3R_344()) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_190()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_231()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) return true;
    }
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3R_325() {
    if (jj_3R_344()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_374()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_185()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_127()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_245()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3_44() {
    if (jj_3R_103()) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_185()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_186()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_97()) return true;
    if (jj_3R_230()) return true;
    return false;
  }

  private boolean jj_3R_420() {
    if (jj_3R_421()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_246()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACKET)) return true;
    xsp = jj_scanpos;
    if (jj_3R_247()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) return true;
    }
    return false;
  }

  private boolean jj_3R_419() {
    if (jj_3R_236()) return true;
    return false;
  }

  private boolean jj_3R_415() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_419()) {
    jj_scanpos = xsp;
    if (jj_3R_420()) return true;
    }
    return false;
  }

  private boolean jj_3_21() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_376() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_378() {
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3R_375() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_377() {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_408() {
    if (jj_3R_416()) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_363() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_375()) {
    jj_scanpos = xsp;
    if (jj_3R_376()) return true;
    }
    if (jj_3R_325()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_115()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_377()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_378()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_317() {
    if (jj_3R_325()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_363()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_407() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_20()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_3R_92()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_210()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_406() {
    if (jj_3R_415()) return true;
    return false;
  }

  private boolean jj_3R_153() {
    return false;
  }

  private boolean jj_3R_397() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_406()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_407()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_408()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_366() {
    if (jj_3R_299()) return true;
    return false;
  }

  private boolean jj_3_43() {
    if (jj_3R_103()) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == GT && ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_153()) return true;
    if (jj_scan_token(RUNSIGNEDSHIFT)) return true;
    return false;
  }

  private boolean jj_3R_353() {
    if (jj_scan_token(SEMICOLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_366()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_154() {
    return false;
  }

  private boolean jj_3R_352() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_396() {
    if (jj_3R_103()) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_95() {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == GT && ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_154()) return true;
    if (jj_scan_token(RSIGNEDSHIFT)) return true;
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_3R_189()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_80()) return true;
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_3R_190()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_18()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_278() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_396()) {
    jj_scanpos = xsp;
    if (jj_3R_397()) return true;
    }
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_237()) return true;
    return false;
  }

  private boolean jj_3R_351() {
    if (jj_3R_80()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_8()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_331() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_351()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_352()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_353()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3_25() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_3R_97()) return true;
    Token xsp;
    if (jj_3_17()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_17()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_88() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) return true;
    }
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3_26()) return true;
    }
    }
    if (jj_3R_317()) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_310() {
    if (jj_3R_317()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_24()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_3R_350()) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_3R_234()) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_237()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_321() {
    if (jj_scan_token(ENUM)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_330()) jj_scanpos = xsp;
    if (jj_3R_331()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_82() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) return true;
    }
    return false;
  }

  private boolean jj_3R_348() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_346() {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_345() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_204() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_227() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) return true;
    }
    return false;
  }

  private boolean jj_3R_326() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_345()) {
    jj_scanpos = xsp;
    if (jj_3R_346()) {
    jj_scanpos = xsp;
    if (jj_3R_347()) {
    jj_scanpos = xsp;
    if (jj_3R_348()) return true;
    }
    }
    }
    if (jj_3R_310()) return true;
    return false;
  }

  private boolean jj_3R_365() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_190()) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_237()) return true;
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_3R_310()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_326()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_350() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_190()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_365()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  /** Generated Token Manager. */
  public JTBParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[178];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xa00007e0,0x6,0x6,0x0,0xa00007e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe,0x0,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0xa8000000,0x0,0x0,0x0,0x0,0x0,0x0,0xa8000000,0x0,0xa0000000,0xa8000000,0x0,0x0,0x0,0xa0000ffe,0xa0000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0xa8000000,0x0,0x0,0x0,0xf0000ffe,0xa0000ffe,0x0,0xa0000000,0xa0000000,0x0,0x0,0xa0000000,0x0,0xa0000000,0xa0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0000ffe,0x0,0x0,0xa0000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0xffe,0x0,0x0,0x0,0xa0000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0000ffe,0x0,0xf0000ffe,0xf0000ffe,0x0,0x0,0x0,0x0,0xa0000ffe,0x0,0xf0000ffe,0x0,0x0,0xa0000ffe,0xa0000ffe,0xa0000ffe,0xa0000ffe,0xa0000ffe,0x0,0x0,0x0,0xa0000ffe,0x0,0x0,0x0,0x0,0x0,0xa0000ffe,0x0,0xa8000000,0x0,0xa0000000,0xa8000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xe140a104,0x0,0x0,0x1000,0xe140a104,0x0,0x0,0x0,0x0,0x0,0xe0002000,0xe0002000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x100000,0xe2802408,0x0,0x0,0xe2002000,0x800408,0xe2802408,0x800008,0x0,0x800,0x80000,0x0,0x0,0x80000,0xe2002000,0x0,0xe3c0a50c,0x0,0x0,0x0,0x0,0x800,0x0,0xe3c0a50c,0x800408,0x1408104,0xe3c0a50c,0x0,0x0,0x0,0xd409104,0xd409104,0x0,0x0,0x0,0x0,0x0,0x0,0xe340a104,0x0,0x0,0x0,0xdc5b1ac,0xd409104,0x0,0x1408104,0x1408104,0x0,0x800,0x1408104,0x800,0x1408104,0x1408104,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd409104,0x0,0x0,0xd409104,0xc001000,0x0,0x0,0x0,0x0,0xc001000,0x0,0x0,0x8001000,0x1000,0xd409104,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0xd4591a4,0x0,0xdc5b1ac,0xdc591ac,0x0,0x2000,0x0,0x0,0xd409104,0x41,0xdc5b1ac,0x41,0x200,0xd40b104,0xd409104,0xd409104,0xd40b104,0xd409104,0x0,0x0,0x0,0xd409104,0x2,0x4000,0x0,0x0,0x0,0xd409104,0x0,0xe3c0a50c,0x40,0x1c0850c,0xe3c0a50c,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x2002,0x4,0x4,0x90800,0x2002,0x0,0x200,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x80000,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x80000,0x10000,0x0,0x0,0x0,0x80000,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x444c,0x4,0x0,0x444c,0x0,0x444c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x444c,0x0,0x644e,0x0,0x0,0x0,0x0,0x0,0x0,0x644e,0x0,0x2002,0x644e,0x0,0x0,0x0,0xf2892,0xf2892,0x0,0x0,0x200,0x0,0x0,0x0,0x444e,0x0,0x0,0x200,0xfb9f3,0xf2892,0x4,0x2,0x2,0x0,0x10,0x2,0x10,0x2,0x2002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf2892,0x0,0x0,0xf2892,0xf0890,0x0,0x0,0x0,0x0,0xf0890,0x0,0x0,0xf0800,0x800,0xf2892,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb9f3,0x0,0xfb9f3,0xfb9f3,0x0,0x0,0x0,0x0,0xf2892,0x0,0xfb9f3,0x0,0x0,0xf2892,0xf2892,0xf2892,0xf2892,0xf2892,0x0,0x0,0x0,0xf2892,0x0,0x0,0x0,0x0,0x0,0xf2892,0x0,0x444e,0x0,0x2,0x444e,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x1000,0x0,0x0,0x0,0x1000,0x200,0x0,0x200,0x0,0x2000,0x0,0x0,0x200,0x1000,0x1000,0x40,0x40000000,0x0,0x2000,0x10,0x10000,0x40000000,0x0,0x0,0x2000,0x400,0x2000,0x1000,0xa008000,0xa008000,0x50,0x4,0x0,0x0,0x0,0x0,0x0,0x1000,0x40000000,0x5044,0x0,0x200,0xa008010,0xa008010,0x5044,0x4000,0x200,0x0,0x4000000,0x0,0x0,0x0,0x100,0x0,0x400,0x0,0x0,0x100,0x0,0x1000,0x0,0x0,0x200,0x200,0x0,0x0,0x200,0x1110,0x100,0x4,0x10,0x200,0x0,0x20000000,0x1110,0x0,0x1000,0x1100,0x200,0x800,0x40,0x7806014,0x7806014,0x200,0x1000,0x0,0x110,0x40,0x200,0x0,0x0,0x1000,0x0,0x1800114,0x4,0x0,0x0,0x0,0x200,0x0,0x8000,0x0,0x0,0x0,0x200,0x800,0x8000,0x200000,0x400000,0x40000000,0x80000000,0x20000000,0x120000,0x120000,0x0,0xc1000,0xc1000,0x0,0x6000000,0x6000000,0x18000000,0x18000000,0x6000000,0x7806004,0x6000,0x6000,0x4,0x6004,0x4,0x1800000,0x1800000,0x4,0x4,0x0,0x444,0x0,0x0,0x7806004,0x200,0x1000,0x10,0x44,0x0,0x40,0x40,0x1800114,0x10000,0x1800114,0x1800114,0x200,0x0,0x1800800,0x1800800,0x1800004,0x0,0x1800114,0x0,0x0,0x1800004,0x7806004,0x1800004,0x1800104,0x1800004,0x200,0x0,0x0,0x7806004,0x0,0x0,0x0,0x0,0x200,0x7806014,0x200,0x100,0x0,0x0,0x100,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x100000,0x100000,0x100000,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x102000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x80000,0x0,0x0,0x80000,0x80000,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x180000,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x100000,0x180000,0x0,0x0,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x4000,0x0,0x0,0x180000,0x100000,0x0,0x0,0x100000,0x0,0x0,0x100000,0x0,0x0,0x100000,0x0,0x381fe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x40000,0x0,0x0,0x1,0x1,0x0,0x100000,0x0,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x180000,0x100000,0x0,0x80000,0x381fe,0x381fe,0x100000,0x0,0x180000,0x0,0x0,0x180000,0x100000,0x100000,0x180000,0x100000,0x0,0x100000,0x100000,0x100000,0x0,0x0,0x80000,0x100000,0x0,0x180000,0x0,0x180000,0x0,0x180000,0x180000,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[48];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public JTBParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public JTBParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JTBParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 178; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 178; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public JTBParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new JTBParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 178; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 178; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public JTBParser(JTBParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 178; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(JTBParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 178; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[151];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 178; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 151; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 48; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class JTBToolkit {

  static NodeToken makeNodeToken(final Token tok) {
    final NodeToken node = new NodeToken(tok.image.intern(), tok.kind, tok.beginLine, tok.beginColumn, tok.endLine, tok.endColumn);
    if (tok.specialToken == null)
      return node;
    final java.util.ArrayList<NodeToken> temp = new java.util.ArrayList<NodeToken>();
    Token t = tok;
    while (t.specialToken != null) {
      t = t.specialToken;
      temp.add(new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn));
    }
    for (int i = temp.size() - 1; i >= 0; --i)
      node.addSpecial(temp.get(i));
    node.trimSpecials();
    return node;
  }
}
