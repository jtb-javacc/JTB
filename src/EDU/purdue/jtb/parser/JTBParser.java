/* JTBParser.java */
/* Generated By:JavaCC: Do not edit this line. JTBParser.java */
package EDU.purdue.jtb.parser;

import java.util.List;
import java.util.ArrayList;
import EDU.purdue.jtb.syntaxtree.*;


/**
 * This file contains the code for JavaCCParser generated
 * by JavaCCParser itself.
 */
// ModMMa : adapted from JavaCC.jj to fit to JTB class name
public class JTBParser extends JavaCCParserInternals implements JTBParserConstants {

  /* --- JTB generated return variables declarations --- */

  /** Return variable for the {@link #LocalLookahead} BNFProduction */
  Lookahead jtbrt_LocalLookahead;

  /** Return variable for the {@link #IdentifierAsString} BNFProduction */
  String jtbrt_IdentifierAsString;

  /** Return variable for the {@link #JavaIdentifier} BNFProduction */
  Token jtbrt_JavaIdentifier;

  /** Return variable for the {@link #Modifiers} BNFProduction */
  int jtbrt_Modifiers;

  /** Return variable for the {@link #IntegerLiteral} BNFProduction */
  int jtbrt_IntegerLiteral;

  /** Return variable for the {@link #BooleanLiteral} BNFProduction */
  boolean jtbrt_BooleanLiteral;

  /** Return variable for the {@link #StringLiteral} BNFProduction */
  String jtbrt_StringLiteral;

  /* --- User code --- */

  /**
   * The name of the parser class.
   */
  String parser_class_name;

  /**
   * This flag is set to true when the part between PARSER_BEGIN and
   * PARSER_END is being parsed.
   */
  boolean processing_cu = false;

  /**
   * The level of class nesting.
   */
  int class_nesting = 0;

  /**
   * This int variable is incremented while parsing local lookaheads.
   * Hence it keeps track of *syntactic* lookahead nesting.
   * This is used to provide warnings when actions and nested lookaheads
   * are used in syntactic lookahead productions.  This is to prevent
   * typos such as leaving out the comma in LOOKAHEAD( foo(), {check()} ).
   */
  int inLocalLA = 0;

  /**
   * Set to true when the parser is within an action.
   */
  boolean inAction = false;

  /**
   * This flag keeps track of whether or not return and throw
   * statements have been patched during the parsing of a production.
   * The value of this flag is assigned the field with the same
   * name in BNFProduction_.java.
   */
  boolean jumpPatched = false;

  /*
   * Returns true if the next token is not in the FOLLOW list of "expansion".
   * It is used to decide when the end of an "expansion" has been reached.
   */
  private boolean notTailOfExpansionUnit() {
    final Token t = getToken(1);
    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET)
      return false;
    return true;
  }

  /**
   * Class to hold modifiers.
   */
  static public final class ModifierSet {

    /* --- User code --- */

    /* Definitions of the bits in the modifiers field */

    public static final int M_PUBLIC = 0x0001;

    public static final int M_PROTECTED = 0x0002;

    public static final int M_PRIVATE = 0x0004;

    public static final int M_ABSTRACT = 0x0008;

    public static final int M_STATIC = 0x0010;

    public static final int M_FINAL = 0x0020;

    public static final int M_SYNCHRONIZED = 0x0040;

    public static final int M_NATIVE = 0x0080;

    public static final int M_TRANSIENT = 0x0100;

    public static final int M_VOLATILE = 0x0200;

    public static final int M_STRICTFP = 0x1000;

    /* A set of accessors that indicate whether the specified modifier is in the set */

    public boolean isPublic(int modifiers) {
      return (modifiers & M_PUBLIC) != 0;
    }

    public boolean isProtected(int modifiers) {
      return (modifiers & M_PROTECTED) != 0;
    }

    public boolean isPrivate(int modifiers) {
      return (modifiers & M_PRIVATE) != 0;
    }

    public boolean isStatic(int modifiers) {
      return (modifiers & M_STATIC) != 0;
    }

    public boolean isAbstract(int modifiers) {
      return (modifiers & M_ABSTRACT) != 0;
    }

    public boolean isFinal(int modifiers) {
      return (modifiers & M_FINAL) != 0;
    }

    public boolean isNative(int modifiers) {
      return (modifiers & M_NATIVE) != 0;
    }

    public boolean isStrictfp(int modifiers) {
      return (modifiers & M_STRICTFP) != 0;
    }

    public boolean isSynchronized(int modifiers) {
      return (modifiers & M_SYNCHRONIZED) != 0;
    }

    public boolean isTransient(int modifiers) {
      return (modifiers & M_TRANSIENT) != 0;
    }

    public boolean isVolatile(int modifiers) {
      return (modifiers & M_VOLATILE) != 0;
    }

    /* Removes the given modifier */

    static int removeModifier(int modifiers, int mod) {
      return modifiers & ~mod;
    }
  }

/************************************************
 * THE JAVACC GRAMMAR SPECIFICATION STARTS HERE *
 ************************************************/
// ModMMa : changed all javacc_input into JavaCCInput to conform to class name convention
  final public JavaCCInput JavaCCInput() throws ParseException {// --- JTB generated node declarations ---
  JavaCCOptions n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  IdentifierAsString n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  CompilationUnit n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  IdentifierAsString n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeList n16 = new NodeList();
  Production n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  // --- user BNFProduction java block ---
  String id1 = null;
  String id2 = null;
  initialize();
  // ModMMa : added to JavaCC as called in parser.Main in Javacc 4.2
  Options.init();
    n0 = JavaCCOptions();
    n2 = jj_consume_token(_PARSER_BEGIN);
n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(LPAREN);
n3 = JTBToolkit.makeNodeToken(n4);
    n5 = IdentifierAsString();
id1 = jtbrt_IdentifierAsString;
addcuname(id1);
    n7 = jj_consume_token(RPAREN);
n6 = JTBToolkit.makeNodeToken(n7);
processing_cu = true;
    parser_class_name = id1;
    n8 = CompilationUnit();
processing_cu = false;
    n10 = jj_consume_token(_PARSER_END);
n9 = JTBToolkit.makeNodeToken(n10);
    n12 = jj_consume_token(LPAREN);
n11 = JTBToolkit.makeNodeToken(n12);
    n13 = IdentifierAsString();
id2 = jtbrt_IdentifierAsString;
compare(getToken(0), id1, id2);
    n15 = jj_consume_token(RPAREN);
n14 = JTBToolkit.makeNodeToken(n15);
    label_1:
    while (true) {
      n17 = Production();
n16.addNode(n17);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case VOID:
      case LT:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
n16.nodes.trimToSize();
    n19 = jj_consume_token(0);
n19.beginColumn++;
    n19.endColumn++;
    { n18 = JTBToolkit.makeNodeToken(n19); }
{if ("" != null) return new JavaCCInput(n0, n1, n3, n5, n6, n8, n9, n11, n13, n14, n16, n18);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all javacc_options into JavaCCOptions to conform to class name convention
  final public JavaCCOptions JavaCCOptions() throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeListOptional n6 = null;
  OptionBinding n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    if (getToken(1).image.equals("options")) {
n6 = new NodeListOptional();
n1 = new NodeSequence(4);
      n3 = jj_consume_token(140);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n5 = jj_consume_token(LBRACE);
n4 = JTBToolkit.makeNodeToken(n5);
n1.addNode(n4);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case STATIC:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        n7 = OptionBinding();
n6.addNode(n7);
      }
n6.nodes.trimToSize();
n1.addNode(n6);
      n9 = jj_consume_token(RBRACE);
n8 = JTBToolkit.makeNodeToken(n9);
n1.addNode(n8);
n0.addNode(n1);
    } else {
      ;
    }
Options.normalize();
{if ("" != null) return new JavaCCOptions(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all option_binding into OptionBinding to conform to class name convention
  final public OptionBinding OptionBinding() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeChoice n11 = null;
  IntegerLiteral n12 = null;
  BooleanLiteral n13 = null;
  StringLiteral n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  // --- user BNFProduction java block ---
  String option_name = null;
  int int_val = 0;
  boolean bool_val = false;
  String string_val = null;
  Token t = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      n2 = jj_consume_token(IDENTIFIER);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0, 4);
      break;
      }
    case _LOOKAHEAD:{
      n4 = jj_consume_token(_LOOKAHEAD);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1, 4);
      break;
      }
    case _IGNORE_CASE:{
      n6 = jj_consume_token(_IGNORE_CASE);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2, 4);
      break;
      }
    case STATIC:{
      n8 = jj_consume_token(STATIC);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3, 4);
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
option_name = t.image;
    n10 = jj_consume_token(ASSIGN);
n9 = JTBToolkit.makeNodeToken(n10);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:{
      n12 = IntegerLiteral();
int_val = jtbrt_IntegerLiteral;
Options.setInputFileOption(t, getToken(0), option_name, new Integer(int_val));
n11 = new NodeChoice(n12, 0, 3);
      break;
      }
    case FALSE:
    case TRUE:{
      n13 = BooleanLiteral();
bool_val = jtbrt_BooleanLiteral;
Options.setInputFileOption(t, getToken(0), option_name, new Boolean(bool_val));
n11 = new NodeChoice(n13, 1, 3);
      break;
      }
    case STRING_LITERAL:{
      n14 = StringLiteral();
string_val = jtbrt_StringLiteral;
Options.setInputFileOption(t, getToken(0), option_name, string_val);
n11 = new NodeChoice(n14, 2, 3);
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n16 = jj_consume_token(SEMICOLON);
n15 = JTBToolkit.makeNodeToken(n16);
{if ("" != null) return new OptionBinding(n0, n9, n11, n15);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all production into Production to conform to class name convention
  final public Production Production() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  JavaCodeProduction n1 = null;
  RegularExprProduction n2 = null;
  TokenManagerDecls n3 = null;
  BNFProduction n4 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _JAVACODE:{
      /*
         * Since JAVACODE is both a JavaCC reserved word and a Java identifier,
         * we need to give preference to "JavaCodeProduction" over "BNFProduction"
         */
          n1 = JavaCodeProduction();
n0 = new NodeChoice(n1, 0, 4);
      break;
      }
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case LT:{
      /*
         * Since SKIP, TOKEN, etc. are both JavaCC reserved words and Java identifiers,
         * we need to give preference to "RegularExprProduction" over "BNFProduction"
         */
          n2 = RegularExprProduction();
n0 = new NodeChoice(n2, 1, 4);
      break;
      }
    case _TOKEN_MGR_DECLS:{
      /*
         * Since TOKEN_MGR_DECLS is both a JavaCC reserved word and a Java identifier,
         * we need to give preference to "TokenManagerDecls" over "BNFProduction"
         */
          n3 = TokenManagerDecls();
n0 = new NodeChoice(n3, 2, 4);
      break;
      }
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case VOID:
    case IDENTIFIER:{
      n4 = BNFProduction();
n0 = new NodeChoice(n4, 3, 4);
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new Production(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all JavaCodeProduction into JavaCodeProduction_ (JavaCC specific class)
// ModMMa : changed all javacode_production into JavaCodeProduction to conform to class name convention
  final public JavaCodeProduction JavaCodeProduction() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  AccessModifier n2 = null;
  ResultType n3 = null;
  IdentifierAsString n4 = null;
  FormalParameters n5 = null;
  NodeOptional n6 = new NodeOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  Name n10 = null;
  NodeListOptional n11 = null;
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  Name n15 = null;
  NodeOptional n16 = new NodeOptional();
  NodeToken n17 = null;
  Token n18 = null;
  Block n19 = null;
  // --- user BNFProduction java block ---
  JavaCodeProduction_ p = new JavaCodeProduction_();
  String lhs = null;
  Token t = getToken(1);
  p.setFirstToken(t);
  List<Token> excName = null;
  p.setThrowsList(new ArrayList<List<Token>>());
  p.setLine(t.beginLine);
  p.setColumn(t.beginColumn);
    n1 = jj_consume_token(_JAVACODE);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = AccessModifier(p);
    n3 = ResultType(p.getReturnTypeTokens());
    n4 = IdentifierAsString();
lhs = jtbrt_IdentifierAsString;
p.setLhs(lhs);
    n5 = FormalParameters(p.getParameterListTokens());
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THROWS:{
n11 = new NodeListOptional();
n7 = new NodeSequence(5);
      n9 = jj_consume_token(THROWS);
n8 = JTBToolkit.makeNodeToken(n9);
n7.addNode(n8);
excName = new ArrayList<Token>();
      n10 = Name(excName);
n7.addNode(n10);
p.getThrowsList().add(excName);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
excName = new ArrayList<Token>();
n12 = new NodeSequence(4);
        n14 = jj_consume_token(COMMA);
n13 = JTBToolkit.makeNodeToken(n14);
n12.addNode(n13);
        n15 = Name(excName);
n12.addNode(n15);
p.getThrowsList().add(excName);
n11.addNode(n12);
      }
n11.nodes.trimToSize();
n7.addNode(n11);
n6.addNode(n7);
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case REM:{
      n18 = jj_consume_token(REM);
n17 = JTBToolkit.makeNodeToken(n18);
n16.addNode(n17);
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    n19 = Block(p.getCodeTokens());
p.setLastToken(getToken(0));
    addproduction(p);
{if ("" != null) return new JavaCodeProduction(n0, n2, n3, n4, n5, n6, n16, n19);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all BNFProduction into BNFProduction_ (JavaCC specific class)
// ModMMa : changed all bnf_production into BNFProduction to conform to class name convention
  final public BNFProduction BNFProduction() throws ParseException {// --- JTB generated node declarations ---
  AccessModifier n0 = null;
  ResultType n1 = null;
  IdentifierAsString n2 = null;
  FormalParameters n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  Name n8 = null;
  NodeListOptional n9 = null;
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  Name n13 = null;
  NodeOptional n14 = new NodeOptional();
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  Block n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  ExpansionChoices n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  // --- user BNFProduction java block ---
  BNFProduction_ p = new BNFProduction_();
  Container c = new Container();
  Token t = getToken(1);
  p.setFirstToken(t);
  List<Token> excName = null;
  String lhs = null;
  p.setThrowsList(new ArrayList<List<Token>>());
  p.setLine(t.beginLine);
  p.setColumn(t.beginColumn);
  jumpPatched = false;
    n0 = AccessModifier(p);
    n1 = ResultType(p.getReturnTypeTokens());
    n2 = IdentifierAsString();
lhs = jtbrt_IdentifierAsString;
p.setLhs(lhs);
    n3 = FormalParameters(p.getParameterListTokens());
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THROWS:{
n9 = new NodeListOptional();
n5 = new NodeSequence(5);
      n7 = jj_consume_token(THROWS);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
excName = new ArrayList<Token>();
      n8 = Name(excName);
n5.addNode(n8);
p.getThrowsList().add(excName);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[8] = jj_gen;
          break label_4;
        }
excName = new ArrayList<Token>();
n10 = new NodeSequence(4);
        n12 = jj_consume_token(COMMA);
n11 = JTBToolkit.makeNodeToken(n12);
n10.addNode(n11);
        n13 = Name(excName);
n10.addNode(n13);
p.getThrowsList().add(excName);
n9.addNode(n10);
      }
n9.nodes.trimToSize();
n5.addNode(n9);
n4.addNode(n5);
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BANG:{
      n16 = jj_consume_token(BANG);
n15 = JTBToolkit.makeNodeToken(n16);
n14.addNode(n15);
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    n18 = jj_consume_token(COLON);
n17 = JTBToolkit.makeNodeToken(n18);
    n19 = Block(p.getDeclarationTokens());
    n21 = jj_consume_token(LBRACE);
n20 = JTBToolkit.makeNodeToken(n21);
    n22 = ExpansionChoices(c);
    n24 = jj_consume_token(RBRACE);
n23 = JTBToolkit.makeNodeToken(n24);
t = n24;
p.setLastToken(t);
    p.setJumpPatched(jumpPatched);
    production_addexpansion(p, (Expansion_)(c.member));
    addproduction(p);
{if ("" != null) return new BNFProduction(n0, n1, n2, n3, n4, n14, n17, n19, n20, n22, n23);}
    throw new Error("Missing return statement in function");
}

  final public AccessModifier AccessModifier(NormalProduction p) throws ParseException {// --- JTB generated node declarations ---
  NodeListOptional n0 = new NodeListOptional();
  NodeChoice n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  // --- user BNFProduction java block ---
  Token t = null;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FINAL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:{
        ;
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PUBLIC:{
        n3 = jj_consume_token(PUBLIC);
n2 = JTBToolkit.makeNodeToken(n3);
t = n3;
n1 = new NodeChoice(n2, 0, 4);
        break;
        }
      case PROTECTED:{
        n5 = jj_consume_token(PROTECTED);
n4 = JTBToolkit.makeNodeToken(n5);
t = n5;
n1 = new NodeChoice(n4, 1, 4);
        break;
        }
      case PRIVATE:{
        n7 = jj_consume_token(PRIVATE);
n6 = JTBToolkit.makeNodeToken(n7);
t = n7;
n1 = new NodeChoice(n6, 2, 4);
        break;
        }
      case FINAL:{
        n9 = jj_consume_token(FINAL);
n8 = JTBToolkit.makeNodeToken(n9);
n1 = new NodeChoice(n8, 3, 4);
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
    }
n0.nodes.trimToSize();
if (t != null) {
      p.setAccessMod(t.image);
    }
{if ("" != null) return new AccessModifier(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all regular_expr_production into RegularExprProduction to conform to class name convention
  final public RegularExprProduction RegularExprProduction() throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeChoice n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeListOptional n14 = null;
  NodeSequence n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  RegExprKind n22 = null;
  NodeOptional n23 = new NodeOptional();
  NodeSequence n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeToken n31 = null;
  Token n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  RegExprSpec n35 = null;
  NodeListOptional n36 = new NodeListOptional();
  NodeSequence n37 = null;
  NodeToken n38 = null;
  Token n39 = null;
  RegExprSpec n40 = null;
  NodeToken n41 = null;
  Token n42 = null;
  // --- user BNFProduction java block ---
  TokenProduction p = new TokenProduction();
  List<String> states = null;
  Token t = p.firstToken = getToken(1);
  p.setLine(t.beginLine);
  p.setColumn(t.beginColumn);
/* Set p.lexStates assuming there is no lexical state specified, and then override if necessary */
    p.lexStates = new String[]{ "DEFAULT" };
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
n14 = new NodeListOptional();
      if (jj_2_1(2)) {
n2 = new NodeSequence(4);
        n4 = jj_consume_token(LT);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
        n6 = jj_consume_token(STAR);
n5 = JTBToolkit.makeNodeToken(n6);
n2.addNode(n5);
        n8 = jj_consume_token(GT);
n7 = JTBToolkit.makeNodeToken(n8);
n2.addNode(n7);
p.lexStates = null;
n1 = new NodeChoice(n2, 0, 2);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LT:{
n9 = new NodeSequence(7);
          n11 = jj_consume_token(LT);
n10 = JTBToolkit.makeNodeToken(n11);
n9.addNode(n10);
states = new ArrayList<String>();
          n13 = jj_consume_token(IDENTIFIER);
n12 = JTBToolkit.makeNodeToken(n13);
t = n13;
n9.addNode(n12);
states.add(t.image);
          label_6:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case COMMA:{
              ;
              break;
              }
            default:
              jj_la1[13] = jj_gen;
              break label_6;
            }
n15 = new NodeSequence(3);
            n17 = jj_consume_token(COMMA);
n16 = JTBToolkit.makeNodeToken(n17);
n15.addNode(n16);
            n19 = jj_consume_token(IDENTIFIER);
n18 = JTBToolkit.makeNodeToken(n19);
t = n19;
n15.addNode(n18);
states.add(t.image);
n14.addNode(n15);
          }
n14.nodes.trimToSize();
n9.addNode(n14);
          n21 = jj_consume_token(GT);
n20 = JTBToolkit.makeNodeToken(n21);
n9.addNode(n20);
p.lexStates = new String[states.size()];
        for (int i = 0; // modified MMa : workaround for Eclipse plugin color syntax problem
        //      i < states.size();
        i != states.size(); i++) {
          p.lexStates[i] = states.get(i);
        }
n1 = new NodeChoice(n9, 1, 2);
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    n22 = RegExprKind(p);
if (p.kind != TokenProduction.TOKEN && Options.getUserTokenManager()) {
      JavaCCErrors.warning(getToken(0), "Regular expression is being treated as if it were a TOKEN since option USER_TOKEN_MANAGER has been set to true.");
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACKET:{
n24 = new NodeSequence(4);
      n26 = jj_consume_token(LBRACKET);
n25 = JTBToolkit.makeNodeToken(n26);
n24.addNode(n25);
      n28 = jj_consume_token(_IGNORE_CASE);
n27 = JTBToolkit.makeNodeToken(n28);
t = n28;
n24.addNode(n27);
      n30 = jj_consume_token(RBRACKET);
n29 = JTBToolkit.makeNodeToken(n30);
n24.addNode(n29);
p.ignoreCase = true;
      if (Options.getUserTokenManager()) {
        JavaCCErrors.warning(t, "Ignoring \"IGNORE_CASE\" specification since option USER_TOKEN_MANAGER has been set to true.");
      }
n23.addNode(n24);
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    n32 = jj_consume_token(COLON);
n31 = JTBToolkit.makeNodeToken(n32);
    n34 = jj_consume_token(LBRACE);
n33 = JTBToolkit.makeNodeToken(n34);
    n35 = RegExprSpec(p);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_OR:{
        ;
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        break label_7;
      }
n37 = new NodeSequence(2);
      n39 = jj_consume_token(BIT_OR);
n38 = JTBToolkit.makeNodeToken(n39);
n37.addNode(n38);
      n40 = RegExprSpec(p);
n37.addNode(n40);
n36.addNode(n37);
    }
n36.nodes.trimToSize();
    n42 = jj_consume_token(RBRACE);
n41 = JTBToolkit.makeNodeToken(n42);
t = n42;
p.lastToken = t;
    addregexpr(p);
{if ("" != null) return new RegularExprProduction(n0, n22, n23, n31, n33, n35, n36, n41);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all token_manager_decls into TokenManagerDecls to conform to class name convention
  final public TokenManagerDecls TokenManagerDecls() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  ClassOrInterfaceBody n4 = null;
  // --- user BNFProduction java block ---
  List<Token> decls = new ArrayList<Token>();
  Token t = null;
    n1 = jj_consume_token(_TOKEN_MGR_DECLS);
n0 = JTBToolkit.makeNodeToken(n1);
t = n1;
    n3 = jj_consume_token(COLON);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ClassOrInterfaceBody(false, decls);
add_token_manager_decls(t, decls);
{if ("" != null) return new TokenManagerDecls(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all regexpr_kind into RegExprKind to conform to class name convention
  final public RegExprKind RegExprKind(TokenProduction p) throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _TOKEN:{
      n2 = jj_consume_token(_TOKEN);
n1 = JTBToolkit.makeNodeToken(n2);
p.kind = TokenProduction.TOKEN;
n0 = new NodeChoice(n1, 0, 4);
      break;
      }
    case _SPECIAL_TOKEN:{
      n4 = jj_consume_token(_SPECIAL_TOKEN);
n3 = JTBToolkit.makeNodeToken(n4);
p.kind = TokenProduction.SPECIAL;
n0 = new NodeChoice(n3, 1, 4);
      break;
      }
    case _SKIP:{
      n6 = jj_consume_token(_SKIP);
n5 = JTBToolkit.makeNodeToken(n6);
p.kind = TokenProduction.SKIP;
n0 = new NodeChoice(n5, 2, 4);
      break;
      }
    case _MORE:{
      n8 = jj_consume_token(_MORE);
n7 = JTBToolkit.makeNodeToken(n8);
p.kind = TokenProduction.MORE;
n0 = new NodeChoice(n7, 3, 4);
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new RegExprKind(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all RegExprSpec into RegExprSpec_ (JavaCC specific class)
// ModMMa : changed all regexpr_spec into RegExprSpec to conform to class name convention
  final public RegExprSpec RegExprSpec(TokenProduction p) throws ParseException {// --- JTB generated node declarations ---
  RegularExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  Block n5 = null;
  NodeOptional n6 = new NodeOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  // --- user BNFProduction java block ---
  Container c = new Container();
  Action act = new Action();
  Token t = null;
  RegExprSpec_ res = new RegExprSpec_();
    n0 = RegularExpression(c);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BANG:{
      n3 = jj_consume_token(BANG);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      ;
    }
res.rexp = (RegularExpression_)c.member;
    res.rexp.tpContext = p;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE:{
t = getToken(1);
      n5 = Block(act.getActionTokens());
if (Options.getUserTokenManager()) {
        JavaCCErrors.warning(t, "Ignoring action in regular expression specification since option USER_TOKEN_MANAGER has been set to true.");
      }
      if (res.rexp.private_rexp) {
        JavaCCErrors.parse_error(t, "Actions are not permitted on private (#) regular expressions.");
      }
n4.addNode(n5);
      break;
      }
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLON:{
n7 = new NodeSequence(3);
      n9 = jj_consume_token(COLON);
n8 = JTBToolkit.makeNodeToken(n9);
n7.addNode(n8);
      n11 = jj_consume_token(IDENTIFIER);
n10 = JTBToolkit.makeNodeToken(n11);
t = n11;
n7.addNode(n10);
res.nextState = t.image;
      if (res.rexp.private_rexp) {
        JavaCCErrors.parse_error(t, "Lexical state changes are not permitted after private (#) regular expressions.");
      }
n6.addNode(n7);
      break;
      }
    default:
      jj_la1[21] = jj_gen;
      ;
    }
res.act = act;
    res.nsTok = t;
    p.respecs.add(res);
{if ("" != null) return new RegExprSpec(n0, n1, n4, n6);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all expansion_choices into ExpansionChoices to conform to class name convention
  final public ExpansionChoices ExpansionChoices(Container c1) throws ParseException {// --- JTB generated node declarations ---
  Expansion n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Expansion n5 = null;
  // --- user BNFProduction java block ---
  boolean morethanone = false;
  Choice ch = new Choice();
  Container c2 = new Container();
    n0 = Expansion(c1);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_OR:{
        ;
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        break label_8;
      }
n2 = new NodeSequence(3);
      n4 = jj_consume_token(BIT_OR);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Expansion(c2);
n2.addNode(n5);
if (morethanone) {
        ch.getChoices().add((Expansion_)c2.member);
        ((Expansion_)c2.member).parent = ch;
      } else {
        morethanone = true;
        ch = new Choice((Expansion_)c1.member);
        ((Expansion_)c1.member).parent = ch;
        ch.getChoices().add((Expansion_)c2.member);
        ((Expansion_)c2.member).parent = ch;
      }
n1.addNode(n2);
    }
n1.nodes.trimToSize();
if (morethanone) {
      c1.member = ch;
    }
{if ("" != null) return new ExpansionChoices(n0, n1);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all Expansion into Expansion_ (JavaCC specific class)
// ModMMa : changed all expansion into Expansion to conform to class name convention
  final public Expansion Expansion(Container c1) throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  LocalLookahead n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeList n9 = new NodeList();
  ExpansionUnit n10 = null;
  // --- user BNFProduction java block ---
  Sequence seq = new Sequence();
  Container c2 = new Container();
  Lookahead la = new Lookahead();
  Token t = getToken(1);
  seq.setLine(t.beginLine);
  seq.setColumn(t.beginColumn);
  la.setLine(t.beginLine);
  la.setColumn(t.beginColumn);
la.setAmount(Options.getLookahead());
    la.setLaExpansion(null);
    la.setExplicit(false);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _LOOKAHEAD:{
n1 = new NodeSequence(5);
      n3 = jj_consume_token(_LOOKAHEAD);
n2 = JTBToolkit.makeNodeToken(n3);
t = n3;
n1.addNode(n2);
      n5 = jj_consume_token(LPAREN);
n4 = JTBToolkit.makeNodeToken(n5);
n1.addNode(n4);
      n6 = LocalLookahead();
la = jtbrt_LocalLookahead;
n1.addNode(n6);
      n8 = jj_consume_token(RPAREN);
n7 = JTBToolkit.makeNodeToken(n8);
n1.addNode(n7);
if (inLocalLA != 0 && la.getAmount() != 0) {
        JavaCCErrors.warning(t, "Only semantic lookahead specifications within other lookahead specifications is considered.  Syntactic lookahead is ignored.");
      }
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      ;
    }
seq.units.add(la);
    label_9:
    while (true) {
      n10 = ExpansionUnit(c2);
seq.units.add((Expansion_)c2.member);
      ((Expansion_)c2.member).parent = seq;
      ((Expansion_)c2.member).ordinal = seq.units.size() - 1;
n9.addNode(n10);
      if (notTailOfExpansionUnit()) {
        ;
      } else {
        break label_9;
      }
    }
n9.nodes.trimToSize();
if (la.getLaExpansion() == null) {
      la.setLaExpansion(seq);
    }
    c1.member = seq;
{if ("" != null) return new Expansion(n0, n9);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all local_lookahead into LocalLookahead to conform to class name convention
  final public LocalLookahead LocalLookahead() throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  IntegerLiteral n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  ExpansionChoices n6 = null;
  NodeOptional n7 = new NodeOptional();
  NodeToken n8 = null;
  Token n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeSequence n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  Expression n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  // --- user BNFProduction java block ---
  Lookahead la = new Lookahead();
  la.setExplicit(true);
  Token t = getToken(1);
  la.setLine(t.beginLine);
  la.setColumn(t.beginColumn);
  la.setLaExpansion(null);
  Container c = new Container();
  boolean commaAtEnd = false,emptyLA = true;
  int laAmount = 0;
  inLocalLA++;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:{
      n1 = IntegerLiteral();
laAmount = jtbrt_IntegerLiteral;
emptyLA = false;
      la.setAmount(laAmount);
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    if (!emptyLA && (getToken(1).kind != RPAREN)) {
      n4 = jj_consume_token(COMMA);
n3 = JTBToolkit.makeNodeToken(n4);
commaAtEnd = true;
n2.addNode(n3);
    } else {
      ;
    }
    if (getToken(1).kind != RPAREN && getToken(1).kind != LBRACE) {
      n6 = ExpansionChoices(c);
emptyLA = false;
      commaAtEnd = false;
      la.setLaExpansion((Expansion_)c.member);
n5.addNode(n6);
    } else {
      ;
    }
    if (!emptyLA && !commaAtEnd && (getToken(1).kind != RPAREN)) {
      n9 = jj_consume_token(COMMA);
n8 = JTBToolkit.makeNodeToken(n9);
commaAtEnd = true;
n7.addNode(n8);
    } else {
      ;
    }
    if (emptyLA || commaAtEnd) {
n11 = new NodeSequence(4);
      n13 = jj_consume_token(LBRACE);
n12 = JTBToolkit.makeNodeToken(n13);
n11.addNode(n12);
      n14 = Expression(la.getActionTokens());
n11.addNode(n14);
      n16 = jj_consume_token(RBRACE);
n15 = JTBToolkit.makeNodeToken(n16);
n11.addNode(n15);
if (emptyLA) {
        la.setAmount(0);
      }
n10.addNode(n11);
    } else {
      ;
    }
inLocalLA--;
    jtbrt_LocalLookahead = la;
{if ("" != null) return new LocalLookahead(n0, n2, n5, n7, n10);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all expansion_unit into ExpansionUnit to conform to class name convention
  final public ExpansionUnit ExpansionUnit(Container c) throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  LocalLookahead n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  Block n9 = null;
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  ExpansionChoices n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  ExpansionUnitTCF n16 = null;
  NodeSequence n17 = null;
  NodeOptional n18 = new NodeOptional();
  NodeSequence n19 = null;
  PrimaryExpression n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeChoice n23 = null;
  NodeSequence n24 = null;
  IdentifierAsString n25 = null;
  Arguments n26 = null;
  NodeOptional n27 = new NodeOptional();
  NodeToken n28 = null;
  Token n29 = null;
  NodeSequence n30 = null;
  RegularExpression n31 = null;
  NodeOptional n32 = new NodeOptional();
  NodeSequence n33 = null;
  NodeToken n34 = null;
  Token n35 = null;
  NodeToken n36 = null;
  Token n37 = null;
  NodeOptional n38 = new NodeOptional();
  NodeToken n39 = null;
  Token n40 = null;
  NodeSequence n41 = null;
  NodeToken n42 = null;
  Token n43 = null;
  ExpansionChoices n44 = null;
  NodeToken n45 = null;
  Token n46 = null;
  NodeOptional n47 = new NodeOptional();
  NodeChoice n48 = null;
  NodeToken n49 = null;
  Token n50 = null;
  NodeToken n51 = null;
  Token n52 = null;
  NodeToken n53 = null;
  Token n54 = null;
  // --- user BNFProduction java block ---
  String name = null;
  List<Token> lhsTokens = new ArrayList<Token>();
  NonTerminal nt = null;
  Action act = null;
  Token t = null;
  Lookahead la = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _LOOKAHEAD:{
n1 = new NodeSequence(5);
      n3 = jj_consume_token(_LOOKAHEAD);
n2 = JTBToolkit.makeNodeToken(n3);
/*
     * We give this priority over primary expressions which use LOOKAHEAD as the name of its identifier */
    t = n3;
n1.addNode(n2);
      n5 = jj_consume_token(LPAREN);
n4 = JTBToolkit.makeNodeToken(n5);
n1.addNode(n4);
      n6 = LocalLookahead();
la = jtbrt_LocalLookahead;
n1.addNode(n6);
      n8 = jj_consume_token(RPAREN);
n7 = JTBToolkit.makeNodeToken(n8);
n1.addNode(n7);
// Now set the la_expansion field of la with a dummy expansion (we use EOF)
      la.setLaExpansion(new REndOfFile());
      // Create a singleton choice with an empty action
      Choice ch = new Choice(t);
      Sequence seq = new Sequence(t, la);
      la.parent = seq;
      la.ordinal = 0;
      act = new Action();
      act.setLine(t.beginLine);
      act.setColumn(t.beginColumn);
      seq.units.add(act);
      act.parent = seq;
      act.ordinal = 1;
      ch.getChoices().add(seq);
      seq.parent = ch;
      seq.ordinal = 0;
      if (la.getAmount() != 0) {
        if (la.getActionTokens().size() != 0) {
          JavaCCErrors.warning(t, "Encountered LOOKAHEAD(...) at a non-choice location.  Only semantic lookahead will be considered here.");
        } else {
          JavaCCErrors.warning(t, "Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.");
        }
      }
      c.member = ch;
n0 = new NodeChoice(n1, 0, 6);
      break;
      }
    case LBRACE:{
act = new Action();
      t = getToken(1);
      act.setLine(t.beginLine);
      act.setColumn(t.beginColumn);
      inAction = true;
      n9 = Block(act.getActionTokens());
inAction = false;
      if (inLocalLA != 0) {
        JavaCCErrors.warning(t, "Action within lookahead specification will be ignored.");
      }
      c.member = act;
n0 = new NodeChoice(n9, 1, 6);
      break;
      }
    case LBRACKET:{
n10 = new NodeSequence(4);
      n12 = jj_consume_token(LBRACKET);
n11 = JTBToolkit.makeNodeToken(n12);
t = n12;
n10.addNode(n11);
      n13 = ExpansionChoices(c);
n10.addNode(n13);
      n15 = jj_consume_token(RBRACKET);
n14 = JTBToolkit.makeNodeToken(n15);
n10.addNode(n14);
c.member = new ZeroOrOne(t, (Expansion_)c.member);
n0 = new NodeChoice(n10, 2, 6);
      break;
      }
    case TRY:{
      n16 = ExpansionUnitTCF(c);
n0 = new NodeChoice(n16, 3, 6);
      break;
      }
    default:
      jj_la1[31] = jj_gen;
      if (jj_2_4(2147483647)) {
n17 = new NodeSequence(2);
        if (jj_2_2(2147483647)) {
Token first = getToken(1);
n19 = new NodeSequence(5);
          n20 = PrimaryExpression();
n19.addNode(n20);
Token last = getToken(0);
          n22 = jj_consume_token(ASSIGN);
n21 = JTBToolkit.makeNodeToken(n22);
n19.addNode(n21);
t = first;
        while (true) {
          lhsTokens.add(t);
          if (t == last)
            break;
          t = t.next;
        }
n18.addNode(n19);
        } else {
          ;
        }
n17.addNode(n18);
        if (jj_2_3(2147483647)) {
nt = new NonTerminal();
          t = getToken(1);
          nt.setLine(t.beginLine);
          nt.setColumn(t.beginColumn);
          nt.setLhsTokens(lhsTokens);
n24 = new NodeSequence(5);
          n25 = IdentifierAsString();
name = jtbrt_IdentifierAsString;
n24.addNode(n25);
          n26 = Arguments(nt.getArgumentTokens());
n24.addNode(n26);
nt.setName(name);
          c.member = nt;
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case BANG:{
            n29 = jj_consume_token(BANG);
n28 = JTBToolkit.makeNodeToken(n29);
n27.addNode(n28);
            break;
            }
          default:
            jj_la1[25] = jj_gen;
            ;
          }
n24.addNode(n27);
n23 = new NodeChoice(n24, 0, 2);
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case STRING_LITERAL:
          case LT:{
n30 = new NodeSequence(4);
            n31 = RegularExpression(c);
n30.addNode(n31);
((RegularExpression_)(c.member)).lhsTokens = lhsTokens;
          add_inline_regexpr((RegularExpression_)(c.member));
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case DOT:{
n33 = new NodeSequence(3);
              n35 = jj_consume_token(DOT);
n34 = JTBToolkit.makeNodeToken(n35);
n33.addNode(n34);
              n37 = jj_consume_token(IDENTIFIER);
n36 = JTBToolkit.makeNodeToken(n37);
t = n37;
n33.addNode(n36);
((RegularExpression_)(c.member)).rhsToken = t;
n32.addNode(n33);
              break;
              }
            default:
              jj_la1[26] = jj_gen;
              ;
            }
n30.addNode(n32);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case BANG:{
              n40 = jj_consume_token(BANG);
n39 = JTBToolkit.makeNodeToken(n40);
n38.addNode(n39);
              break;
              }
            default:
              jj_la1[27] = jj_gen;
              ;
            }
n30.addNode(n38);
n23 = new NodeChoice(n30, 1, 2);
            break;
            }
          default:
            jj_la1[28] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
n17.addNode(n23);
n0 = new NodeChoice(n17, 4, 6);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
n41 = new NodeSequence(4);
          n43 = jj_consume_token(LPAREN);
n42 = JTBToolkit.makeNodeToken(n43);
t = n43;
n41.addNode(n42);
          n44 = ExpansionChoices(c);
n41.addNode(n44);
          n46 = jj_consume_token(RPAREN);
n45 = JTBToolkit.makeNodeToken(n46);
n41.addNode(n45);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case HOOK:
          case PLUS:
          case STAR:{
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case PLUS:{
              n50 = jj_consume_token(PLUS);
n49 = JTBToolkit.makeNodeToken(n50);
c.member = new OneOrMore(t, (Expansion_)c.member);
n48 = new NodeChoice(n49, 0, 3);
              break;
              }
            case STAR:{
              n52 = jj_consume_token(STAR);
n51 = JTBToolkit.makeNodeToken(n52);
c.member = new ZeroOrMore(t, (Expansion_)c.member);
n48 = new NodeChoice(n51, 1, 3);
              break;
              }
            case HOOK:{
              n54 = jj_consume_token(HOOK);
n53 = JTBToolkit.makeNodeToken(n54);
c.member = new ZeroOrOne(t, (Expansion_)c.member);
n48 = new NodeChoice(n53, 2, 3);
              break;
              }
            default:
              jj_la1[29] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
n47.addNode(n48);
            break;
            }
          default:
            jj_la1[30] = jj_gen;
            ;
          }
n41.addNode(n47);
n0 = new NodeChoice(n41, 5, 6);
          break;
          }
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return new ExpansionUnit(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa : added to create a node ; renamed from ExpansionUnitInTCF
  final public ExpansionUnitTCF ExpansionUnitTCF(Container c) throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  ExpansionChoices n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeListOptional n7 = new NodeListOptional();
  NodeSequence n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  Name n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  Block n18 = null;
  NodeOptional n19 = new NodeOptional();
  NodeSequence n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  Block n23 = null;
  // --- user BNFProduction java block ---
  Token t = null;
Container expch = new Container();
    List<List<Token>> types = new ArrayList<List<Token>>();
    List<Token> ids = new ArrayList<Token>();
    List<List<Token>> catchblks = new ArrayList<List<Token>>();
    List<Token> finallyblk = null;
    List<Token> vec = new ArrayList<Token>();
    Token t0 = null;
    n1 = jj_consume_token(TRY);
n0 = JTBToolkit.makeNodeToken(n1);
t0 = n1;
    n3 = jj_consume_token(LBRACE);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ExpansionChoices(expch);
    n6 = jj_consume_token(RBRACE);
n5 = JTBToolkit.makeNodeToken(n6);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CATCH:{
        ;
        break;
        }
      default:
        jj_la1[33] = jj_gen;
        break label_10;
      }
n8 = new NodeSequence(8);
      n10 = jj_consume_token(CATCH);
n9 = JTBToolkit.makeNodeToken(n10);
n8.addNode(n9);
      n12 = jj_consume_token(LPAREN);
n11 = JTBToolkit.makeNodeToken(n12);
n8.addNode(n11);
      n13 = Name(vec);
n8.addNode(n13);
      n15 = jj_consume_token(IDENTIFIER);
n14 = JTBToolkit.makeNodeToken(n15);
t = n15;
n8.addNode(n14);
      n17 = jj_consume_token(RPAREN);
n16 = JTBToolkit.makeNodeToken(n17);
n8.addNode(n16);
types.add(vec);
      ids.add(t);
      vec = new ArrayList<Token>();
      inAction = true;
      n18 = Block(vec);
n8.addNode(n18);
inAction = false;
      catchblks.add(vec);
      vec = new ArrayList<Token>();
n7.addNode(n8);
    }
n7.nodes.trimToSize();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FINALLY:{
inAction = true;
n20 = new NodeSequence(4);
      n22 = jj_consume_token(FINALLY);
n21 = JTBToolkit.makeNodeToken(n22);
n20.addNode(n21);
      n23 = Block(vec);
n20.addNode(n23);
inAction = false;
      finallyblk = vec;
n19.addNode(n20);
      break;
      }
    default:
      jj_la1[34] = jj_gen;
      ;
    }
makeTryBlock(t0, c, expch, types, ids, catchblks, finallyblk);
{if ("" != null) return new ExpansionUnitTCF(n0, n2, n4, n5, n7, n19);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all RegularExpression into RegularExpression_ (JavaCC specific class)
// ModMMa : changed all regular_expression into RegularExpression to conform to class name convention
  final public RegularExpression RegularExpression(Container c) throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  StringLiteral n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeOptional n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  IdentifierAsString n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  ComplexRegularExpressionChoices n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeSequence n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  IdentifierAsString n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeSequence n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  // --- user BNFProduction java block ---
  REndOfFile ef = null;
  String image = null;
  boolean private_rexp = false;
  Token t = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_LITERAL:{
      n1 = StringLiteral();
image = jtbrt_StringLiteral;
c.member = new RStringLiteral(t, image);
n0 = new NodeChoice(n1, 0, 4);
      break;
      }
    default:
      jj_la1[37] = jj_gen;
      if (jj_2_5(3)) {
image = "";
n2 = new NodeSequence(6);
        // modified MMa 07/2012 : no definition needed (otherwise it supercedes LT)
            //    < LANGLE : "<" >
            n4 = jj_consume_token(LT);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 141:
        case IDENTIFIER:{
n7 = new NodeOptional();
n6 = new NodeSequence(3);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case 141:{
            n9 = jj_consume_token(141);
n8 = JTBToolkit.makeNodeToken(n9);
private_rexp = true;
n7.addNode(n8);
            break;
            }
          default:
            jj_la1[35] = jj_gen;
            ;
          }
n6.addNode(n7);
          n10 = IdentifierAsString();
image = jtbrt_IdentifierAsString;
n6.addNode(n10);
          n12 = jj_consume_token(COLON);
n11 = JTBToolkit.makeNodeToken(n12);
n6.addNode(n11);
n5.addNode(n6);
          break;
          }
        default:
          jj_la1[36] = jj_gen;
          ;
        }
n2.addNode(n5);
        n13 = ComplexRegularExpressionChoices(c);
n2.addNode(n13);
        // modified MMa 07/2012 : no definition needed (otherwise it supercedes GT)
            //    < RANGLE : ">" >
            n15 = jj_consume_token(GT);
n14 = JTBToolkit.makeNodeToken(n15);
n2.addNode(n14);
RegularExpression_ re = null;
      if (c.member instanceof RJustName) {
        RSequence seq = new RSequence();
        seq.units.add((RegularExpression_)c.member);
        re = seq;
      } else {
        re = (RegularExpression_)c.member;
      }
      re.label = image;
      re.private_rexp = private_rexp;
      re.setLine(t.beginLine);
      re.setColumn(t.beginColumn);
      c.member = re;
n0 = new NodeChoice(n2, 1, 4);
      } else if (jj_2_6(2)) {
n16 = new NodeSequence(4);
        n18 = jj_consume_token(LT);
n17 = JTBToolkit.makeNodeToken(n18);
n16.addNode(n17);
        n19 = IdentifierAsString();
image = jtbrt_IdentifierAsString;
n16.addNode(n19);
        n21 = jj_consume_token(GT);
n20 = JTBToolkit.makeNodeToken(n21);
n16.addNode(n20);
c.member = new RJustName(t, image);
n0 = new NodeChoice(n16, 2, 4);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LT:{
n22 = new NodeSequence(4);
          n24 = jj_consume_token(LT);
n23 = JTBToolkit.makeNodeToken(n24);
n22.addNode(n23);
          n26 = jj_consume_token(_EOF);
n25 = JTBToolkit.makeNodeToken(n26);
n22.addNode(n25);
          n28 = jj_consume_token(GT);
n27 = JTBToolkit.makeNodeToken(n28);
n22.addNode(n27);
ef = new REndOfFile();
      ef.setLine(t.beginLine);
      ef.setColumn(t.beginColumn);
      ef.ordinal = 0;
      c.member = ef;
n0 = new NodeChoice(n22, 3, 4);
          break;
          }
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return new RegularExpression(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all complex_regular_expression_choices into ComplexRegularExpressionChoices to conform to class name convention
  final public ComplexRegularExpressionChoices ComplexRegularExpressionChoices(Container c1) throws ParseException {// --- JTB generated node declarations ---
  ComplexRegularExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  ComplexRegularExpression n5 = null;
  // --- user BNFProduction java block ---
  boolean morethanone = false;
  RChoice ch = new RChoice();
  Container c2 = new Container();
    n0 = ComplexRegularExpression(c1);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_OR:{
        ;
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        break label_11;
      }
n2 = new NodeSequence(3);
      n4 = jj_consume_token(BIT_OR);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = ComplexRegularExpression(c2);
n2.addNode(n5);
if (morethanone) {
        ch.getChoices().add((RegularExpression_)c2.member);
      } else {
        morethanone = true;
        ch = new RChoice();
        ch.setLine(((RegularExpression_)c1.member).getLine());
        ch.setColumn(((RegularExpression_)c1.member).getColumn());
        ch.getChoices().add((RegularExpression_)c1.member);
        ch.getChoices().add((RegularExpression_)c2.member);
      }
n1.addNode(n2);
    }
n1.nodes.trimToSize();
if (morethanone) {
      c1.member = ch;
    }
{if ("" != null) return new ComplexRegularExpressionChoices(n0, n1);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all complex_regular_expression into ComplexRegularExpression to conform to class name convention
  final public ComplexRegularExpression ComplexRegularExpression(Container c1) throws ParseException {// --- JTB generated node declarations ---
  NodeList n0 = new NodeList();
  ComplexRegularExpressionUnit n1 = null;
  // --- user BNFProduction java block ---
  int count = 0;
  RSequence seq = new RSequence();
  Container c2 = new Container();
    label_12:
    while (true) {
      n1 = ComplexRegularExpressionUnit(c2);
count++;
      if (count == 1) {
        c1.member = c2.member;
      // if count does not go beyond 1, we are done.
      } else
        if (count == 2) {
          // more than 1, so create a sequence.
          seq = new RSequence();
          seq.setLine(((RegularExpression_)c1.member).getLine());
          seq.setColumn(((RegularExpression_)c1.member).getColumn());
          seq.units.add((RegularExpression_)c1.member);
          seq.units.add((RegularExpression_)c2.member);
        } else {
          seq.units.add((RegularExpression_)c2.member);
        }
n0.addNode(n1);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STRING_LITERAL:
      case LPAREN:
      case LBRACKET:
      case LT:
      case TILDE:{
        ;
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        break label_12;
      }
    }
n0.nodes.trimToSize();
if (count > 1) {
      c1.member = seq;
    }
{if ("" != null) return new ComplexRegularExpression(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all complex_regular_expression_unit into ComplexRegularExpressionUnit to conform to class name convention
  final public ComplexRegularExpressionUnit ComplexRegularExpressionUnit(Container c) throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  StringLiteral n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  IdentifierAsString n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  CharacterList n8 = null;
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  ComplexRegularExpressionChoices n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeOptional n15 = new NodeOptional();
  NodeChoice n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeSequence n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  IntegerLiteral n26 = null;
  NodeOptional n27 = null;
  NodeSequence n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeOptional n31 = null;
  IntegerLiteral n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  // --- user BNFProduction java block ---
  String image = null;
  Token t = getToken(1);
  int r1 = 0,r2 = -1;
  boolean hasMax = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_LITERAL:{
      n1 = StringLiteral();
image = jtbrt_StringLiteral;
c.member = new RStringLiteral(t, image);
n0 = new NodeChoice(n1, 0, 4);
      break;
      }
    case LT:{
n2 = new NodeSequence(4);
      n4 = jj_consume_token(LT);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = IdentifierAsString();
image = jtbrt_IdentifierAsString;
n2.addNode(n5);
      n7 = jj_consume_token(GT);
n6 = JTBToolkit.makeNodeToken(n7);
n2.addNode(n6);
c.member = new RJustName(t, image);
n0 = new NodeChoice(n2, 1, 4);
      break;
      }
    case LBRACKET:
    case TILDE:{
      n8 = CharacterList(c);
n0 = new NodeChoice(n8, 2, 4);
      break;
      }
    case LPAREN:{
n9 = new NodeSequence(4);
      n11 = jj_consume_token(LPAREN);
n10 = JTBToolkit.makeNodeToken(n11);
n9.addNode(n10);
      n12 = ComplexRegularExpressionChoices(c);
n9.addNode(n12);
      n14 = jj_consume_token(RPAREN);
n13 = JTBToolkit.makeNodeToken(n14);
n9.addNode(n13);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:
      case HOOK:
      case PLUS:
      case STAR:{
n27 = new NodeOptional();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PLUS:{
          n18 = jj_consume_token(PLUS);
n17 = JTBToolkit.makeNodeToken(n18);
c.member = new ROneOrMore(t, (RegularExpression_)c.member);
n16 = new NodeChoice(n17, 0, 4);
          break;
          }
        case STAR:{
          n20 = jj_consume_token(STAR);
n19 = JTBToolkit.makeNodeToken(n20);
c.member = new RZeroOrMore(t, (RegularExpression_)c.member);
n16 = new NodeChoice(n19, 1, 4);
          break;
          }
        case HOOK:{
          n22 = jj_consume_token(HOOK);
n21 = JTBToolkit.makeNodeToken(n22);
RZeroOrOne zorexp = new RZeroOrOne();
          zorexp.setLine(t.beginLine);
          zorexp.setColumn(t.beginColumn);
          zorexp.regexpr = (RegularExpression_)c.member;
          c.member = zorexp;
n16 = new NodeChoice(n21, 2, 4);
          break;
          }
        case LBRACE:{
n23 = new NodeSequence(5);
          n25 = jj_consume_token(LBRACE);
n24 = JTBToolkit.makeNodeToken(n25);
n23.addNode(n24);
          n26 = IntegerLiteral();
r1 = jtbrt_IntegerLiteral;
n23.addNode(n26);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
n31 = new NodeOptional();
n28 = new NodeSequence(3);
            n30 = jj_consume_token(COMMA);
n29 = JTBToolkit.makeNodeToken(n30);
n28.addNode(n29);
hasMax = true;
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case INTEGER_LITERAL:{
              n32 = IntegerLiteral();
r2 = jtbrt_IntegerLiteral;
n31.addNode(n32);
              break;
              }
            default:
              jj_la1[41] = jj_gen;
              ;
            }
n28.addNode(n31);
n27.addNode(n28);
            break;
            }
          default:
            jj_la1[42] = jj_gen;
            ;
          }
n23.addNode(n27);
          n34 = jj_consume_token(RBRACE);
n33 = JTBToolkit.makeNodeToken(n34);
n23.addNode(n33);
RRepetitionRange rrrexp = new RRepetitionRange();
          rrrexp.setLine(t.beginLine);
          rrrexp.setColumn(t.beginColumn);
          rrrexp.min = r1;
          rrrexp.max = r2;
          rrrexp.hasMax = hasMax;
          rrrexp.regexpr = (RegularExpression_)c.member;
          c.member = rrrexp;
n16 = new NodeChoice(n23, 3, 4);
          break;
          }
        default:
          jj_la1[43] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
n15.addNode(n16);
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        ;
      }
n9.addNode(n15);
n0 = new NodeChoice(n9, 3, 4);
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new ComplexRegularExpressionUnit(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all character_list into CharacterList to conform to class name convention
  final public CharacterList CharacterList(Container c1) throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  CharacterDescriptor n7 = null;
  NodeListOptional n8 = null;
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  CharacterDescriptor n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  // --- user BNFProduction java block ---
  RCharacterList chlist = new RCharacterList();
  Token t = getToken(1);
  chlist.setLine(t.beginLine);
  chlist.setColumn(t.beginColumn);
  Container c2 = new Container();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TILDE:{
      n2 = jj_consume_token(TILDE);
n1 = JTBToolkit.makeNodeToken(n2);
chlist.negated_list = true;
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    n4 = jj_consume_token(LBRACKET);
n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_LITERAL:{
n8 = new NodeListOptional();
n6 = new NodeSequence(3);
      n7 = CharacterDescriptor(c2);
n6.addNode(n7);
chlist.descriptors.add(c2.member);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[47] = jj_gen;
          break label_13;
        }
n9 = new NodeSequence(3);
        n11 = jj_consume_token(COMMA);
n10 = JTBToolkit.makeNodeToken(n11);
n9.addNode(n10);
        n12 = CharacterDescriptor(c2);
n9.addNode(n12);
chlist.descriptors.add(c2.member);
n8.addNode(n9);
      }
n8.nodes.trimToSize();
n6.addNode(n8);
n5.addNode(n6);
      break;
      }
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    n14 = jj_consume_token(RBRACKET);
n13 = JTBToolkit.makeNodeToken(n14);
c1.member = chlist;
{if ("" != null) return new CharacterList(n0, n3, n5, n13);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all character_descriptor into CharacterDescriptor to conform to class name convention
  final public CharacterDescriptor CharacterDescriptor(Container c) throws ParseException {// --- JTB generated node declarations ---
  StringLiteral n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  StringLiteral n5 = null;
  // --- user BNFProduction java block ---
  char c1 = ' ';
  char c2 = ' ';
  boolean isrange = false;
  String imageL = null;
  String imageR = null;
  Token t = getToken(1);
    n0 = StringLiteral();
imageL = jtbrt_StringLiteral;
c1 = character_descriptor_assign(getToken(0), imageL);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MINUS:{
n2 = new NodeSequence(3);
      n4 = jj_consume_token(MINUS);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = StringLiteral();
imageR = jtbrt_StringLiteral;
n2.addNode(n5);
isrange = true;
      c2 = character_descriptor_assign(getToken(0), imageR, imageL);
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[49] = jj_gen;
      ;
    }
if (isrange) {
      CharacterRange cr = new CharacterRange();
      cr.setLine(t.beginLine);
      cr.setColumn(t.beginColumn);
      cr.setLeft(c1);
      cr.setRight(c2);
      c.member = cr;
    } else {
      SingleCharacter sc = new SingleCharacter();
      sc.setLine(t.beginLine);
      sc.setColumn(t.beginColumn);
      sc.ch = c1;
      c.member = sc;
    }
{if ("" != null) return new CharacterDescriptor(n0, n1);}
    throw new Error("Missing return statement in function");
}

// ModMMa : changed all identifier into Identifier to conform to class name convention
// ModMMa 07/2012 : renamed from Identifier to IdentifierAsString
  final public IdentifierAsString IdentifierAsString() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  // --- user BNFProduction java block ---
  Token t = null;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
t = n1;
jtbrt_IdentifierAsString = t.image;
{if ("" != null) return new IdentifierAsString(n0);}
    throw new Error("Missing return statement in function");
}

/**********************************************
 * THE JAVA GRAMMAR SPECIFICATION STARTS HERE *
 **********************************************/
/*
 * The Java grammar is modified to use sequences of tokens for the missing tokens
 * (those that include "<<" and ">>")
 */
/* Java identifiers and JavaCC reserved words */
// ModMMa 07/2012 : is it useful to return a Token ? Seems not in Name() and BlockStatement()
  final public JavaIdentifier JavaIdentifier() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      n2 = jj_consume_token(IDENTIFIER);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0, 12);
      break;
      }
    case _LOOKAHEAD:{
      n4 = jj_consume_token(_LOOKAHEAD);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1, 12);
      break;
      }
    case _IGNORE_CASE:{
      n6 = jj_consume_token(_IGNORE_CASE);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2, 12);
      break;
      }
    case _PARSER_BEGIN:{
      n8 = jj_consume_token(_PARSER_BEGIN);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3, 12);
      break;
      }
    case _PARSER_END:{
      n10 = jj_consume_token(_PARSER_END);
n9 = JTBToolkit.makeNodeToken(n10);
n0 = new NodeChoice(n9, 4, 12);
      break;
      }
    case _JAVACODE:{
      n12 = jj_consume_token(_JAVACODE);
n11 = JTBToolkit.makeNodeToken(n12);
n0 = new NodeChoice(n11, 5, 12);
      break;
      }
    case _TOKEN:{
      n14 = jj_consume_token(_TOKEN);
n13 = JTBToolkit.makeNodeToken(n14);
n0 = new NodeChoice(n13, 6, 12);
      break;
      }
    case _SPECIAL_TOKEN:{
      n16 = jj_consume_token(_SPECIAL_TOKEN);
n15 = JTBToolkit.makeNodeToken(n16);
n0 = new NodeChoice(n15, 7, 12);
      break;
      }
    case _MORE:{
      n18 = jj_consume_token(_MORE);
n17 = JTBToolkit.makeNodeToken(n18);
n0 = new NodeChoice(n17, 8, 12);
      break;
      }
    case _SKIP:{
      n20 = jj_consume_token(_SKIP);
n19 = JTBToolkit.makeNodeToken(n20);
n0 = new NodeChoice(n19, 9, 12);
      break;
      }
    case _TOKEN_MGR_DECLS:{
      n22 = jj_consume_token(_TOKEN_MGR_DECLS);
n21 = JTBToolkit.makeNodeToken(n22);
n0 = new NodeChoice(n21, 10, 12);
      break;
      }
    case _EOF:{
      n24 = jj_consume_token(_EOF);
n23 = JTBToolkit.makeNodeToken(n24);
n0 = new NodeChoice(n23, 11, 12);
      break;
      }
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
Token retval = getToken(0);
    retval.kind = IDENTIFIER;
    jtbrt_JavaIdentifier = retval;
{if ("" != null) return new JavaIdentifier(n0);}
    throw new Error("Missing return statement in function");
}

  final public CompilationUnit CompilationUnit() throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  PackageDeclaration n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  ImportDeclaration n3 = null;
  NodeListOptional n4 = new NodeListOptional();
  TypeDeclaration n5 = null;
  // --- user BNFProduction java block ---
  set_initial_cu_token(getToken(1));
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PACKAGE:{
      // ModMMa 07/2012 : fixed grammar
          // LOOKAHEAD((Annotation())* "package")
          n1 = PackageDeclaration();
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IMPORT:{
        ;
        break;
        }
      default:
        jj_la1[52] = jj_gen;
        break label_14;
      }
      n3 = ImportDeclaration();
n2.addNode(n3);
    }
n2.nodes.trimToSize();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case CLASS:
      case ENUM:
      case FINAL:
      case INTERFACE:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case SEMICOLON:
      case 147:{
        ;
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        break label_15;
      }
      n5 = TypeDeclaration();
n4.addNode(n5);
    }
n4.nodes.trimToSize();
insertionpointerrors(getToken(1));
{if ("" != null) return new CompilationUnit(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public PackageDeclaration PackageDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Name n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    // ModMMa 07/2012 : fixed grammar : only at most one Annotation is permitted,
      // and must be in package-info.java, so we should not encounter it in the parsed file
      // Modifiers() "package" Name(null) ";"
      n1 = jj_consume_token(PACKAGE);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name(null);
    n4 = jj_consume_token(SEMICOLON);
n3 = JTBToolkit.makeNodeToken(n4);
{if ("" != null) return new PackageDeclaration(n0, n2, n3);}
    throw new Error("Missing return statement in function");
}

  final public ImportDeclaration ImportDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  Name n5 = null;
  NodeOptional n6 = new NodeOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
    n1 = jj_consume_token(IMPORT);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STATIC:{
      n4 = jj_consume_token(STATIC);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    n5 = Name(null);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOT:{
n7 = new NodeSequence(2);
      n9 = jj_consume_token(DOT);
n8 = JTBToolkit.makeNodeToken(n9);
n7.addNode(n8);
      n11 = jj_consume_token(STAR);
n10 = JTBToolkit.makeNodeToken(n11);
n7.addNode(n10);
n6.addNode(n7);
      break;
      }
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    n13 = jj_consume_token(SEMICOLON);
n12 = JTBToolkit.makeNodeToken(n13);
{if ("" != null) return new ImportDeclaration(n0, n2, n5, n6, n12);}
    throw new Error("Missing return statement in function");
}

/*
 * We match all modifiers in a single rule to reduce the chances of syntax errors
 * for simple modifier mistakes. It will also enable us to give better error messages.
 * Used for class, interface, constant, field, method, constructor & abstract method modifiers,
 * but not for variable modifiers (see VariableModifiers()).
 */
  final public Modifiers Modifiers() throws ParseException {// --- JTB generated node declarations ---
  NodeListOptional n0 = new NodeListOptional();
  NodeChoice n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  Annotation n24 = null;
  // --- user BNFProduction java block ---
  int modifiers = 0;
    label_16:
    while (true) {
      if (jj_2_7(2)) {
        ;
      } else {
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PUBLIC:{
        n3 = jj_consume_token(PUBLIC);
n2 = JTBToolkit.makeNodeToken(n3);
modifiers |= ModifierSet.M_PUBLIC;
n1 = new NodeChoice(n2, 0, 12);
        break;
        }
      case STATIC:{
        n5 = jj_consume_token(STATIC);
n4 = JTBToolkit.makeNodeToken(n5);
modifiers |= ModifierSet.M_STATIC;
n1 = new NodeChoice(n4, 1, 12);
        break;
        }
      case PROTECTED:{
        n7 = jj_consume_token(PROTECTED);
n6 = JTBToolkit.makeNodeToken(n7);
modifiers |= ModifierSet.M_PROTECTED;
n1 = new NodeChoice(n6, 2, 12);
        break;
        }
      case PRIVATE:{
        n9 = jj_consume_token(PRIVATE);
n8 = JTBToolkit.makeNodeToken(n9);
modifiers |= ModifierSet.M_PRIVATE;
n1 = new NodeChoice(n8, 3, 12);
        break;
        }
      case FINAL:{
        n11 = jj_consume_token(FINAL);
n10 = JTBToolkit.makeNodeToken(n11);
modifiers |= ModifierSet.M_FINAL;
n1 = new NodeChoice(n10, 4, 12);
        break;
        }
      case ABSTRACT:{
        n13 = jj_consume_token(ABSTRACT);
n12 = JTBToolkit.makeNodeToken(n13);
modifiers |= ModifierSet.M_ABSTRACT;
n1 = new NodeChoice(n12, 5, 12);
        break;
        }
      case SYNCHRONIZED:{
        n15 = jj_consume_token(SYNCHRONIZED);
n14 = JTBToolkit.makeNodeToken(n15);
modifiers |= ModifierSet.M_SYNCHRONIZED;
n1 = new NodeChoice(n14, 6, 12);
        break;
        }
      case NATIVE:{
        n17 = jj_consume_token(NATIVE);
n16 = JTBToolkit.makeNodeToken(n17);
modifiers |= ModifierSet.M_NATIVE;
n1 = new NodeChoice(n16, 7, 12);
        break;
        }
      case TRANSIENT:{
        n19 = jj_consume_token(TRANSIENT);
n18 = JTBToolkit.makeNodeToken(n19);
modifiers |= ModifierSet.M_TRANSIENT;
n1 = new NodeChoice(n18, 8, 12);
        break;
        }
      case VOLATILE:{
        n21 = jj_consume_token(VOLATILE);
n20 = JTBToolkit.makeNodeToken(n21);
modifiers |= ModifierSet.M_VOLATILE;
n1 = new NodeChoice(n20, 9, 12);
        break;
        }
      case STRICTFP:{
        n23 = jj_consume_token(STRICTFP);
n22 = JTBToolkit.makeNodeToken(n23);
modifiers |= ModifierSet.M_STRICTFP;
n1 = new NodeChoice(n22, 10, 12);
        break;
        }
      case 147:{
        n24 = Annotation();
n1 = new NodeChoice(n24, 11, 12);
        break;
        }
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
    }
n0.nodes.trimToSize();
jtbrt_Modifiers = modifiers;
{if ("" != null) return new Modifiers(n0);}
    throw new Error("Missing return statement in function");
}

  final public TypeDeclaration TypeDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeSequence n3 = null;
  Modifiers n4 = null;
  NodeChoice n5 = null;
  ClassOrInterfaceDeclaration n6 = null;
  EnumDeclaration n7 = null;
  AnnotationTypeDeclaration n8 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      n2 = jj_consume_token(SEMICOLON);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case ABSTRACT:
    case CLASS:
    case ENUM:
    case FINAL:
    case INTERFACE:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 147:{
n3 = new NodeSequence(2);
      n4 = Modifiers();
n3.addNode(n4);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CLASS:
      case INTERFACE:{
        n6 = ClassOrInterfaceDeclaration();
n5 = new NodeChoice(n6, 0, 3);
        break;
        }
      case ENUM:{
        n7 = EnumDeclaration();
n5 = new NodeChoice(n7, 1, 3);
        break;
        }
      case 147:{
        n8 = AnnotationTypeDeclaration();
n5 = new NodeChoice(n8, 2, 3);
        break;
        }
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n3.addNode(n5);
n0 = new NodeChoice(n3, 1, 2);
      break;
      }
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new TypeDeclaration(n0);}
    throw new Error("Missing return statement in function");
}

  final public ClassOrInterfaceDeclaration ClassOrInterfaceDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = new NodeOptional();
  TypeParameters n8 = null;
  NodeOptional n9 = new NodeOptional();
  ExtendsList n10 = null;
  NodeOptional n11 = new NodeOptional();
  ImplementsList n12 = null;
  ClassOrInterfaceBody n13 = null;
  // --- user BNFProduction java block ---
  boolean isInterface = false;
  class_nesting++;
  Token t = null;
  boolean is_parser_class = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CLASS:{
      n2 = jj_consume_token(CLASS);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case INTERFACE:{
      n4 = jj_consume_token(INTERFACE);
n3 = JTBToolkit.makeNodeToken(n4);
isInterface = true;
n0 = new NodeChoice(n3, 1, 2);
      break;
      }
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n6 = jj_consume_token(IDENTIFIER);
n5 = JTBToolkit.makeNodeToken(n6);
t = n6;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
      n8 = TypeParameters();
n7.addNode(n8);
      break;
      }
    default:
      jj_la1[60] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
      n10 = ExtendsList(isInterface);
n9.addNode(n10);
      break;
      }
    default:
      jj_la1[61] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IMPLEMENTS:{
      n12 = ImplementsList(isInterface);
n11.addNode(n12);
      break;
      }
    default:
      jj_la1[62] = jj_gen;
      ;
    }
if (t.image.equals(parser_class_name) && class_nesting == 1 && processing_cu) {
      is_parser_class = true;
      setinsertionpoint(getToken(1), 1);
    }
    n13 = ClassOrInterfaceBody(isInterface, null);
if (is_parser_class) {
      setinsertionpoint(getToken(0), 2);
    }
    class_nesting--;
{if ("" != null) return new ClassOrInterfaceDeclaration(n0, n5, n7, n9, n11, n13);}
    throw new Error("Missing return statement in function");
}

  final public ExtendsList ExtendsList(boolean isInterface) throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ClassOrInterfaceType n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  ClassOrInterfaceType n7 = null;
  // --- user BNFProduction java block ---
  boolean extendsMoreThanOne = false;
    n1 = jj_consume_token(EXTENDS);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ClassOrInterfaceType();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[63] = jj_gen;
        break label_17;
      }
n4 = new NodeSequence(3);
      n6 = jj_consume_token(COMMA);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = ClassOrInterfaceType();
n4.addNode(n7);
extendsMoreThanOne = true;
n3.addNode(n4);
    }
n3.nodes.trimToSize();
if (extendsMoreThanOne && !isInterface)
      {if (true) throw new ParseException("A class cannot extend more than one other class");}
{if ("" != null) return new ExtendsList(n0, n2, n3);}
    throw new Error("Missing return statement in function");
}

  final public ImplementsList ImplementsList(boolean isInterface) throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ClassOrInterfaceType n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  ClassOrInterfaceType n7 = null;
    n1 = jj_consume_token(IMPLEMENTS);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ClassOrInterfaceType();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[64] = jj_gen;
        break label_18;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = ClassOrInterfaceType();
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
if (isInterface)
      {if (true) throw new ParseException("An interface cannot implement other interfaces");}
{if ("" != null) return new ImplementsList(n0, n2, n3);}
    throw new Error("Missing return statement in function");
}

  final public EnumDeclaration EnumDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  ImplementsList n5 = null;
  EnumBody n6 = null;
    n1 = jj_consume_token(ENUM);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IMPLEMENTS:{
      n5 = ImplementsList(false);
n4.addNode(n5);
      break;
      }
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    n6 = EnumBody();
{if ("" != null) return new EnumDeclaration(n0, n2, n4, n6);}
    throw new Error("Missing return statement in function");
}

  final public EnumBody EnumBody() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  EnumConstant n4 = null;
  NodeListOptional n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  EnumConstant n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeToken n11 = null;
  Token n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeListOptional n17 = null;
  ClassOrInterfaceBodyDeclaration n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
    n1 = jj_consume_token(LBRACE);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ABSTRACT:
    case FINAL:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 147:
    case IDENTIFIER:{
n5 = new NodeListOptional();
n3 = new NodeSequence(2);
      n4 = EnumConstant();
n3.addNode(n4);
      label_19:
      while (true) {
        if (jj_2_8(2)) {
          ;
        } else {
          break label_19;
        }
n6 = new NodeSequence(2);
        n8 = jj_consume_token(COMMA);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
        n9 = EnumConstant();
n6.addNode(n9);
n5.addNode(n6);
      }
n5.nodes.trimToSize();
n3.addNode(n5);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:{
      n12 = jj_consume_token(COMMA);
n11 = JTBToolkit.makeNodeToken(n12);
n10.addNode(n11);
      break;
      }
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
n17 = new NodeListOptional();
n14 = new NodeSequence(2);
      n16 = jj_consume_token(SEMICOLON);
n15 = JTBToolkit.makeNodeToken(n16);
n14.addNode(n15);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case LBRACE:
        case SEMICOLON:
        case LT:
        case 147:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[68] = jj_gen;
          break label_20;
        }
        n18 = ClassOrInterfaceBodyDeclaration(false);
n17.addNode(n18);
      }
n17.nodes.trimToSize();
n14.addNode(n17);
n13.addNode(n14);
      break;
      }
    default:
      jj_la1[69] = jj_gen;
      ;
    }
    n20 = jj_consume_token(RBRACE);
n19 = JTBToolkit.makeNodeToken(n20);
{if ("" != null) return new EnumBody(n0, n2, n10, n13, n19);}
    throw new Error("Missing return statement in function");
}

  final public EnumConstant EnumConstant() throws ParseException {// --- JTB generated node declarations ---
  Modifiers n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeOptional n3 = new NodeOptional();
  Arguments n4 = null;
  NodeOptional n5 = new NodeOptional();
  ClassOrInterfaceBody n6 = null;
    n0 = Modifiers();
    n2 = jj_consume_token(IDENTIFIER);
n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      n4 = Arguments(null);
n3.addNode(n4);
      break;
      }
    default:
      jj_la1[70] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE:{
      n6 = ClassOrInterfaceBody(false, null);
n5.addNode(n6);
      break;
      }
    default:
      jj_la1[71] = jj_gen;
      ;
    }
{if ("" != null) return new EnumConstant(n0, n1, n3, n5);}
    throw new Error("Missing return statement in function");
}

  final public TypeParameters TypeParameters() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TypeParameter n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  TypeParameter n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(LT);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TypeParameter();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[72] = jj_gen;
        break label_21;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = TypeParameter();
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
    n9 = jj_consume_token(GT);
n8 = JTBToolkit.makeNodeToken(n9);
{if ("" != null) return new TypeParameters(n0, n2, n3, n8);}
    throw new Error("Missing return statement in function");
}

  final public TypeParameter TypeParameter() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  TypeBound n3 = null;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
      n3 = TypeBound();
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[73] = jj_gen;
      ;
    }
{if ("" != null) return new TypeParameter(n0, n2);}
    throw new Error("Missing return statement in function");
}

  final public TypeBound TypeBound() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ClassOrInterfaceType n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  ClassOrInterfaceType n7 = null;
    n1 = jj_consume_token(EXTENDS);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ClassOrInterfaceType();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_AND:{
        ;
        break;
        }
      default:
        jj_la1[74] = jj_gen;
        break label_22;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(BIT_AND);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = ClassOrInterfaceType();
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
{if ("" != null) return new TypeBound(n0, n2, n3);}
    throw new Error("Missing return statement in function");
}

  final public ClassOrInterfaceBody ClassOrInterfaceBody(boolean isInterface, List<Token> tokens) throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  ClassOrInterfaceBodyDeclaration n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  // --- user BNFProduction java block ---
  Token first = null;
  Token last = null;
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n1 = jj_consume_token(LBRACE);
n0 = JTBToolkit.makeNodeToken(n1);
first = getToken(1);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case LBRACE:
      case SEMICOLON:
      case LT:
      case 147:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[75] = jj_gen;
        break label_23;
      }
      n3 = ClassOrInterfaceBodyDeclaration(isInterface);
n2.addNode(n3);
    }
n2.nodes.trimToSize();
last = getToken(0);
    n5 = jj_consume_token(RBRACE);
n4 = JTBToolkit.makeNodeToken(n5);
if (last.next != first) {
      // i.e., this is not an empty sequence
      Token t = first;
      while (true) {
        tokens.add(t);
        if (t == last)
          break;
        t = t.next;
      }
    }
{if ("" != null) return new ClassOrInterfaceBody(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public ClassOrInterfaceBodyDeclaration ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Initializer n1 = null;
  NodeSequence n2 = null;
  Modifiers n3 = null;
  NodeChoice n4 = null;
  ClassOrInterfaceDeclaration n5 = null;
  EnumDeclaration n6 = null;
  AnnotationTypeDeclaration n7 = null;
  ConstructorDeclaration n8 = null;
  FieldDeclaration n9 = null;
  MethodDeclaration n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    if (jj_2_11(2)) {
      n1 = Initializer();
if (isInterface)
        {if (true) throw new ParseException("An interface cannot have initializers");}
n0 = new NodeChoice(n1, 0, 3);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case LT:
      case 147:
      case IDENTIFIER:{
n2 = new NodeSequence(2);
        n3 = Modifiers();
n2.addNode(n3);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CLASS:
        case INTERFACE:{
          n5 = ClassOrInterfaceDeclaration();
n4 = new NodeChoice(n5, 0, 6);
          break;
          }
        case ENUM:{
          n6 = EnumDeclaration();
n4 = new NodeChoice(n6, 1, 6);
          break;
          }
        case 147:{
          n7 = AnnotationTypeDeclaration();
n4 = new NodeChoice(n7, 2, 6);
          break;
          }
        default:
          jj_la1[76] = jj_gen;
          if (jj_2_9(2147483647)) {
            n8 = ConstructorDeclaration();
n4 = new NodeChoice(n8, 3, 6);
          } else if (jj_2_10(2147483647)) {
            n9 = FieldDeclaration();
n4 = new NodeChoice(n9, 4, 6);
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case BOOLEAN:
            case BYTE:
            case CHAR:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SHORT:
            case VOID:
            case LT:
            case IDENTIFIER:{
              n10 = MethodDeclaration();
n4 = new NodeChoice(n10, 5, 6);
              break;
              }
            default:
              jj_la1[77] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
n2.addNode(n4);
n0 = new NodeChoice(n2, 1, 3);
        break;
        }
      case SEMICOLON:{
        n12 = jj_consume_token(SEMICOLON);
n11 = JTBToolkit.makeNodeToken(n12);
n0 = new NodeChoice(n11, 2, 3);
        break;
        }
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new ClassOrInterfaceBodyDeclaration(n0);}
    throw new Error("Missing return statement in function");
}

  final public FieldDeclaration FieldDeclaration() throws ParseException {// --- JTB generated node declarations ---
  Type n0 = null;
  VariableDeclarator n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  VariableDeclarator n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    // Modifiers already matched in the caller
      n0 = Type();
    n1 = VariableDeclarator();
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[79] = jj_gen;
        break label_24;
      }
n3 = new NodeSequence(2);
      n5 = jj_consume_token(COMMA);
n4 = JTBToolkit.makeNodeToken(n5);
n3.addNode(n4);
      n6 = VariableDeclarator();
n3.addNode(n6);
n2.addNode(n3);
    }
n2.nodes.trimToSize();
    n8 = jj_consume_token(SEMICOLON);
n7 = JTBToolkit.makeNodeToken(n8);
{if ("" != null) return new FieldDeclaration(n0, n1, n2, n7);}
    throw new Error("Missing return statement in function");
}

  final public VariableDeclarator VariableDeclarator() throws ParseException {// --- JTB generated node declarations ---
  VariableDeclaratorId n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  VariableInitializer n5 = null;
    n0 = VariableDeclaratorId();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
n2 = new NodeSequence(2);
      n4 = jj_consume_token(ASSIGN);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = VariableInitializer();
n2.addNode(n5);
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[80] = jj_gen;
      ;
    }
{if ("" != null) return new VariableDeclarator(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public VariableDeclaratorId VariableDeclaratorId() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        ;
        break;
        }
      default:
        jj_la1[81] = jj_gen;
        break label_25;
      }
n3 = new NodeSequence(2);
      n5 = jj_consume_token(LBRACKET);
n4 = JTBToolkit.makeNodeToken(n5);
n3.addNode(n4);
      n7 = jj_consume_token(RBRACKET);
n6 = JTBToolkit.makeNodeToken(n7);
n3.addNode(n6);
n2.addNode(n3);
    }
n2.nodes.trimToSize();
{if ("" != null) return new VariableDeclaratorId(n0, n2);}
    throw new Error("Missing return statement in function");
}

  final public VariableInitializer VariableInitializer() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  ArrayInitializer n1 = null;
  Expression n2 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE:{
      n1 = ArrayInitializer();
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:{
      n2 = Expression(null);
n0 = new NodeChoice(n2, 1, 2);
      break;
      }
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new VariableInitializer(n0);}
    throw new Error("Missing return statement in function");
}

  final public ArrayInitializer ArrayInitializer() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  VariableInitializer n4 = null;
  NodeListOptional n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  VariableInitializer n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
    n1 = jj_consume_token(LBRACE);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:{
n5 = new NodeListOptional();
n3 = new NodeSequence(2);
      n4 = VariableInitializer();
n3.addNode(n4);
      label_26:
      while (true) {
        if (jj_2_12(2)) {
          ;
        } else {
          break label_26;
        }
n6 = new NodeSequence(2);
        n8 = jj_consume_token(COMMA);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
        n9 = VariableInitializer();
n6.addNode(n9);
n5.addNode(n6);
      }
n5.nodes.trimToSize();
n3.addNode(n5);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[83] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:{
      n12 = jj_consume_token(COMMA);
n11 = JTBToolkit.makeNodeToken(n12);
n10.addNode(n11);
      break;
      }
    default:
      jj_la1[84] = jj_gen;
      ;
    }
    n14 = jj_consume_token(RBRACE);
n13 = JTBToolkit.makeNodeToken(n14);
{if ("" != null) return new ArrayInitializer(n0, n2, n10, n13);}
    throw new Error("Missing return statement in function");
}

  final public MethodDeclaration MethodDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  TypeParameters n1 = null;
  ResultType n2 = null;
  MethodDeclarator n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NameList n8 = null;
  NodeChoice n9 = null;
  Block n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
      n1 = TypeParameters();
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[85] = jj_gen;
      ;
    }
    n2 = ResultType(null);
    n3 = MethodDeclarator();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THROWS:{
n5 = new NodeSequence(2);
      n7 = jj_consume_token(THROWS);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
      n8 = NameList();
n5.addNode(n8);
n4.addNode(n5);
      break;
      }
    default:
      jj_la1[86] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE:{
      n10 = Block(null);
n9 = new NodeChoice(n10, 0, 2);
      break;
      }
    case SEMICOLON:{
      n12 = jj_consume_token(SEMICOLON);
n11 = JTBToolkit.makeNodeToken(n12);
n9 = new NodeChoice(n11, 1, 2);
      break;
      }
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new MethodDeclaration(n0, n2, n3, n4, n9);}
    throw new Error("Missing return statement in function");
}

  final public MethodDeclarator MethodDeclarator() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  FormalParameters n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = FormalParameters(null);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        ;
        break;
        }
      default:
        jj_la1[88] = jj_gen;
        break label_27;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(LBRACKET);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n8 = jj_consume_token(RBRACKET);
n7 = JTBToolkit.makeNodeToken(n8);
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
{if ("" != null) return new MethodDeclarator(n0, n2, n3);}
    throw new Error("Missing return statement in function");
}

  final public FormalParameters FormalParameters(List<Token> tokens) throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  FormalParameter n4 = null;
  NodeListOptional n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  FormalParameter n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  // --- user BNFProduction java block ---
  Token first = null;
  Token last = null;
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n1 = jj_consume_token(LPAREN);
n0 = JTBToolkit.makeNodeToken(n1);
first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ABSTRACT:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 147:
    case IDENTIFIER:{
n5 = new NodeListOptional();
n3 = new NodeSequence(2);
      n4 = FormalParameter();
n3.addNode(n4);
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[89] = jj_gen;
          break label_28;
        }
n6 = new NodeSequence(2);
        n8 = jj_consume_token(COMMA);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
        n9 = FormalParameter();
n6.addNode(n9);
n5.addNode(n6);
      }
n5.nodes.trimToSize();
n3.addNode(n5);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[90] = jj_gen;
      ;
    }
last = getToken(0);
    n11 = jj_consume_token(RPAREN);
n10 = JTBToolkit.makeNodeToken(n11);
if (last.next != first) {
      // i.e., this is not an empty sequence
      Token t = first;
      while (true) {
        tokens.add(t);
        if (t == last)
          break;
        t = t.next;
      }
    }
{if ("" != null) return new FormalParameters(n0, n2, n10);}
    throw new Error("Missing return statement in function");
}

  final public FormalParameter FormalParameter() throws ParseException {// --- JTB generated node declarations ---
  Modifiers n0 = null;
  Type n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  VariableDeclaratorId n5 = null;
    n0 = Modifiers();
    n1 = Type();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 142:{
      n4 = jj_consume_token(142);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[91] = jj_gen;
      ;
    }
    n5 = VariableDeclaratorId();
{if ("" != null) return new FormalParameter(n0, n1, n2, n5);}
    throw new Error("Missing return statement in function");
}

  final public ConstructorDeclaration ConstructorDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  TypeParameters n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  FormalParameters n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NameList n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeOptional n12 = new NodeOptional();
  ExplicitConstructorInvocation n13 = null;
  NodeListOptional n14 = new NodeListOptional();
  BlockStatement n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
      n1 = TypeParameters();
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[92] = jj_gen;
      ;
    }
    n3 = jj_consume_token(IDENTIFIER);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = FormalParameters(null);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THROWS:{
n6 = new NodeSequence(2);
      n8 = jj_consume_token(THROWS);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
      n9 = NameList();
n6.addNode(n9);
n5.addNode(n6);
      break;
      }
    default:
      jj_la1[93] = jj_gen;
      ;
    }
    n11 = jj_consume_token(LBRACE);
n10 = JTBToolkit.makeNodeToken(n11);
    if (jj_2_13(2147483647)) {
      n13 = ExplicitConstructorInvocation();
n12.addNode(n13);
    } else {
      ;
    }
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
      case 147:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[94] = jj_gen;
        break label_29;
      }
      n15 = BlockStatement();
n14.addNode(n15);
    }
n14.nodes.trimToSize();
    n17 = jj_consume_token(RBRACE);
n16 = JTBToolkit.makeNodeToken(n17);
{if ("" != null) return new ConstructorDeclaration(n0, n2, n4, n5, n10, n12, n14, n16);}
    throw new Error("Missing return statement in function");
}

  final public ExplicitConstructorInvocation ExplicitConstructorInvocation() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  ReferenceType n6 = null;
  NodeListOptional n7 = null;
  NodeSequence n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  ReferenceType n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeChoice n14 = null;
  NodeSequence n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  Arguments n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeSequence n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  Arguments n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeSequence n27 = null;
  PrimaryExpression n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeToken n31 = null;
  Token n32 = null;
  Arguments n33 = null;
  NodeToken n34 = null;
  Token n35 = null;
    if (jj_2_14(3)) {
n1 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:{
n7 = new NodeListOptional();
n3 = new NodeSequence(4);
        n5 = jj_consume_token(LT);
n4 = JTBToolkit.makeNodeToken(n5);
n3.addNode(n4);
        n6 = ReferenceType();
n3.addNode(n6);
        label_30:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[95] = jj_gen;
            break label_30;
          }
n8 = new NodeSequence(2);
          n10 = jj_consume_token(COMMA);
n9 = JTBToolkit.makeNodeToken(n10);
n8.addNode(n9);
          n11 = ReferenceType();
n8.addNode(n11);
n7.addNode(n8);
        }
n7.nodes.trimToSize();
n3.addNode(n7);
        n13 = jj_consume_token(GT);
n12 = JTBToolkit.makeNodeToken(n13);
n3.addNode(n12);
n2.addNode(n3);
        break;
        }
      default:
        jj_la1[96] = jj_gen;
        ;
      }
n1.addNode(n2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case THIS:{
n15 = new NodeSequence(3);
        n17 = jj_consume_token(THIS);
n16 = JTBToolkit.makeNodeToken(n17);
n15.addNode(n16);
        n18 = Arguments(null);
n15.addNode(n18);
        n20 = jj_consume_token(SEMICOLON);
n19 = JTBToolkit.makeNodeToken(n20);
n15.addNode(n19);
n14 = new NodeChoice(n15, 0, 2);
        break;
        }
      case SUPER:{
n21 = new NodeSequence(3);
        n23 = jj_consume_token(SUPER);
n22 = JTBToolkit.makeNodeToken(n23);
n21.addNode(n22);
        n24 = Arguments(null);
n21.addNode(n24);
        n26 = jj_consume_token(SEMICOLON);
n25 = JTBToolkit.makeNodeToken(n26);
n21.addNode(n25);
n14 = new NodeChoice(n21, 1, 2);
        break;
        }
      default:
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n14);
n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case IDENTIFIER:{
n27 = new NodeSequence(5);
        n28 = PrimaryExpression();
n27.addNode(n28);
        n30 = jj_consume_token(DOT);
n29 = JTBToolkit.makeNodeToken(n30);
n27.addNode(n29);
        n32 = jj_consume_token(SUPER);
n31 = JTBToolkit.makeNodeToken(n32);
n27.addNode(n31);
        n33 = Arguments(null);
n27.addNode(n33);
        n35 = jj_consume_token(SEMICOLON);
n34 = JTBToolkit.makeNodeToken(n35);
n27.addNode(n34);
n0 = new NodeChoice(n27, 1, 2);
        break;
        }
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new ExplicitConstructorInvocation(n0);}
    throw new Error("Missing return statement in function");
}

  final public Initializer Initializer() throws ParseException {// --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  Block n3 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STATIC:{
      n2 = jj_consume_token(STATIC);
n1 = JTBToolkit.makeNodeToken(n2);
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[99] = jj_gen;
      ;
    }
    n3 = Block(null);
{if ("" != null) return new Initializer(n0, n3);}
    throw new Error("Missing return statement in function");
}

  final public Type Type() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  ReferenceType n1 = null;
  PrimitiveType n2 = null;
    if (jj_2_15(2)) {
      n1 = ReferenceType();
n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:{
        n2 = PrimitiveType();
n0 = new NodeChoice(n2, 1, 2);
        break;
        }
      default:
        jj_la1[100] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new Type(n0);}
    throw new Error("Missing return statement in function");
}

  final public ReferenceType ReferenceType() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  PrimitiveType n2 = null;
  NodeList n3 = new NodeList();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeSequence n9 = null;
  ClassOrInterfaceType n10 = null;
  NodeListOptional n11 = new NodeListOptional();
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:{
n1 = new NodeSequence(2);
      n2 = PrimitiveType();
n1.addNode(n2);
      label_31:
      while (true) {
n4 = new NodeSequence(2);
        n6 = jj_consume_token(LBRACKET);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
        n8 = jj_consume_token(RBRACKET);
n7 = JTBToolkit.makeNodeToken(n8);
n4.addNode(n7);
n3.addNode(n4);
        if (jj_2_16(2)) {
          ;
        } else {
          break label_31;
        }
      }
n3.nodes.trimToSize();
n1.addNode(n3);
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case IDENTIFIER:{
n9 = new NodeSequence(2);
      n10 = ClassOrInterfaceType();
n9.addNode(n10);
      label_32:
      while (true) {
        if (jj_2_17(2)) {
          ;
        } else {
          break label_32;
        }
n12 = new NodeSequence(2);
        n14 = jj_consume_token(LBRACKET);
n13 = JTBToolkit.makeNodeToken(n14);
n12.addNode(n13);
        n16 = jj_consume_token(RBRACKET);
n15 = JTBToolkit.makeNodeToken(n16);
n12.addNode(n15);
n11.addNode(n12);
      }
n11.nodes.trimToSize();
n9.addNode(n11);
n0 = new NodeChoice(n9, 1, 2);
      break;
      }
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new ReferenceType(n0);}
    throw new Error("Missing return statement in function");
}

  final public ClassOrInterfaceType ClassOrInterfaceType() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  TypeArguments n3 = null;
  NodeListOptional n4 = new NodeListOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeOptional n10 = null;
  TypeArguments n11 = null;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    if (jj_2_18(2)) {
      n3 = TypeArguments();
n2.addNode(n3);
    } else {
      ;
    }
    label_33:
    while (true) {
      if (jj_2_19(2)) {
        ;
      } else {
        break label_33;
      }
n10 = new NodeOptional();
n5 = new NodeSequence(3);
      n7 = jj_consume_token(DOT);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
      n9 = jj_consume_token(IDENTIFIER);
n8 = JTBToolkit.makeNodeToken(n9);
n5.addNode(n8);
      if (jj_2_20(2)) {
        n11 = TypeArguments();
n10.addNode(n11);
      } else {
        ;
      }
n5.addNode(n10);
n4.addNode(n5);
    }
n4.nodes.trimToSize();
{if ("" != null) return new ClassOrInterfaceType(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public TypeArguments TypeArguments() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TypeArgument n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  TypeArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(LT);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TypeArgument();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[102] = jj_gen;
        break label_34;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = TypeArgument();
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
    n9 = jj_consume_token(GT);
n8 = JTBToolkit.makeNodeToken(n9);
{if ("" != null) return new TypeArguments(n0, n2, n3, n8);}
    throw new Error("Missing return statement in function");
}

  final public TypeArgument TypeArgument() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  ReferenceType n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  WildcardBounds n6 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:{
      n1 = ReferenceType();
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case HOOK:{
n2 = new NodeSequence(2);
      n4 = jj_consume_token(HOOK);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXTENDS:
      case SUPER:{
        n6 = WildcardBounds();
n5.addNode(n6);
        break;
        }
      default:
        jj_la1[103] = jj_gen;
        ;
      }
n2.addNode(n5);
n0 = new NodeChoice(n2, 1, 2);
      break;
      }
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new TypeArgument(n0);}
    throw new Error("Missing return statement in function");
}

  final public WildcardBounds WildcardBounds() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  ReferenceType n4 = null;
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  ReferenceType n8 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
n1 = new NodeSequence(2);
      n3 = jj_consume_token(EXTENDS);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = ReferenceType();
n1.addNode(n4);
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case SUPER:{
n5 = new NodeSequence(2);
      n7 = jj_consume_token(SUPER);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
      n8 = ReferenceType();
n5.addNode(n8);
n0 = new NodeChoice(n5, 1, 2);
      break;
      }
    default:
      jj_la1[105] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new WildcardBounds(n0);}
    throw new Error("Missing return statement in function");
}

  final public PrimitiveType PrimitiveType() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:{
      n2 = jj_consume_token(BOOLEAN);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0, 8);
      break;
      }
    case CHAR:{
      n4 = jj_consume_token(CHAR);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1, 8);
      break;
      }
    case BYTE:{
      n6 = jj_consume_token(BYTE);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2, 8);
      break;
      }
    case SHORT:{
      n8 = jj_consume_token(SHORT);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3, 8);
      break;
      }
    case INT:{
      n10 = jj_consume_token(INT);
n9 = JTBToolkit.makeNodeToken(n10);
n0 = new NodeChoice(n9, 4, 8);
      break;
      }
    case LONG:{
      n12 = jj_consume_token(LONG);
n11 = JTBToolkit.makeNodeToken(n12);
n0 = new NodeChoice(n11, 5, 8);
      break;
      }
    case FLOAT:{
      n14 = jj_consume_token(FLOAT);
n13 = JTBToolkit.makeNodeToken(n14);
n0 = new NodeChoice(n13, 6, 8);
      break;
      }
    case DOUBLE:{
      n16 = jj_consume_token(DOUBLE);
n15 = JTBToolkit.makeNodeToken(n16);
n0 = new NodeChoice(n15, 7, 8);
      break;
      }
    default:
      jj_la1[106] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new PrimitiveType(n0);}
    throw new Error("Missing return statement in function");
}

  final public ResultType ResultType(List<Token> tokens) throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  Type n3 = null;
  // --- user BNFProduction java block ---
  Token first = getToken(1);
  if (tokens == null)
    tokens = new ArrayList<Token>();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VOID:{
      n2 = jj_consume_token(VOID);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:{
      n3 = Type();
n0 = new NodeChoice(n3, 1, 2);
      break;
      }
    default:
      jj_la1[107] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
Token last = getToken(0);
    Token t = first;
    while (true) {
      tokens.add(t);
      if (t == last)
        break;
      t = t.next;
    }
{if ("" != null) return new ResultType(n0);}
    throw new Error("Missing return statement in function");
}

  final public Name Name(List<Token> tokens) throws ParseException {// --- JTB generated node declarations ---
  JavaIdentifier n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  JavaIdentifier n5 = null;
  // --- user BNFProduction java block ---
  if (tokens == null)
    tokens = new ArrayList<Token>();
  Token first = getToken(1);
    n0 = JavaIdentifier();
    label_35:
    while (true) {
      if (jj_2_21(2)) {
        ;
      } else {
        break label_35;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(DOT);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = JavaIdentifier();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
Token last = getToken(0);
    Token t = first;
    while (true) {
      tokens.add(t);
      if (t == last)
        break;
      t = t.next;
    }
{if ("" != null) return new Name(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public NameList NameList() throws ParseException {// --- JTB generated node declarations ---
  Name n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Name n5 = null;
    n0 = Name(null);
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[108] = jj_gen;
        break label_36;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Name(null);
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new NameList(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public Expression Expression(List<Token> tokens) throws ParseException {// --- JTB generated node declarations ---
  ConditionalExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  AssignmentOperator n3 = null;
  Expression n4 = null;
  // --- user BNFProduction java block ---
  Token first = getToken(1);
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n0 = ConditionalExpression();
    if (jj_2_22(2)) {
n2 = new NodeSequence(2);
      n3 = AssignmentOperator();
n2.addNode(n3);
      n4 = Expression(null);
n2.addNode(n4);
n1.addNode(n2);
    } else {
      ;
    }
Token last = getToken(0);
    Token t = first;
    while (true) {
      tokens.add(t);
      if (t == last)
        break;
      t = t.next;
    }
{if ("" != null) return new Expression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public AssignmentOperator AssignmentOperator() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
      n2 = jj_consume_token(ASSIGN);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0, 12);
      break;
      }
    case STARASSIGN:{
      n4 = jj_consume_token(STARASSIGN);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1, 12);
      break;
      }
    case SLASHASSIGN:{
      n6 = jj_consume_token(SLASHASSIGN);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2, 12);
      break;
      }
    case REMASSIGN:{
      n8 = jj_consume_token(REMASSIGN);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3, 12);
      break;
      }
    case PLUSASSIGN:{
      n10 = jj_consume_token(PLUSASSIGN);
n9 = JTBToolkit.makeNodeToken(n10);
n0 = new NodeChoice(n9, 4, 12);
      break;
      }
    case MINUSASSIGN:{
      n12 = jj_consume_token(MINUSASSIGN);
n11 = JTBToolkit.makeNodeToken(n12);
n0 = new NodeChoice(n11, 5, 12);
      break;
      }
    case 143:{
      n14 = jj_consume_token(143);
n13 = JTBToolkit.makeNodeToken(n14);
n0 = new NodeChoice(n13, 6, 12);
      break;
      }
    case 144:{
      n16 = jj_consume_token(144);
n15 = JTBToolkit.makeNodeToken(n16);
n0 = new NodeChoice(n15, 7, 12);
      break;
      }
    case 145:{
      n18 = jj_consume_token(145);
n17 = JTBToolkit.makeNodeToken(n18);
n0 = new NodeChoice(n17, 8, 12);
      break;
      }
    case ANDASSIGN:{
      n20 = jj_consume_token(ANDASSIGN);
n19 = JTBToolkit.makeNodeToken(n20);
n0 = new NodeChoice(n19, 9, 12);
      break;
      }
    case XORASSIGN:{
      n22 = jj_consume_token(XORASSIGN);
n21 = JTBToolkit.makeNodeToken(n22);
n0 = new NodeChoice(n21, 10, 12);
      break;
      }
    case ORASSIGN:{
      n24 = jj_consume_token(ORASSIGN);
n23 = JTBToolkit.makeNodeToken(n24);
n0 = new NodeChoice(n23, 11, 12);
      break;
      }
    default:
      jj_la1[109] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new AssignmentOperator(n0);}
    throw new Error("Missing return statement in function");
}

  final public ConditionalExpression ConditionalExpression() throws ParseException {// --- JTB generated node declarations ---
  ConditionalOrExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Expression n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  Expression n8 = null;
    n0 = ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case HOOK:{
n2 = new NodeSequence(4);
      n4 = jj_consume_token(HOOK);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Expression(null);
n2.addNode(n5);
      n7 = jj_consume_token(COLON);
n6 = JTBToolkit.makeNodeToken(n7);
n2.addNode(n6);
      n8 = Expression(null);
n2.addNode(n8);
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[110] = jj_gen;
      ;
    }
{if ("" != null) return new ConditionalExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public ConditionalOrExpression ConditionalOrExpression() throws ParseException {// --- JTB generated node declarations ---
  ConditionalAndExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  ConditionalAndExpression n5 = null;
    n0 = ConditionalAndExpression();
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SC_OR:{
        ;
        break;
        }
      default:
        jj_la1[111] = jj_gen;
        break label_37;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(SC_OR);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = ConditionalAndExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ConditionalOrExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public ConditionalAndExpression ConditionalAndExpression() throws ParseException {// --- JTB generated node declarations ---
  InclusiveOrExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  InclusiveOrExpression n5 = null;
    n0 = InclusiveOrExpression();
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SC_AND:{
        ;
        break;
        }
      default:
        jj_la1[112] = jj_gen;
        break label_38;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(SC_AND);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = InclusiveOrExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ConditionalAndExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public InclusiveOrExpression InclusiveOrExpression() throws ParseException {// --- JTB generated node declarations ---
  ExclusiveOrExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  ExclusiveOrExpression n5 = null;
    n0 = ExclusiveOrExpression();
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_OR:{
        ;
        break;
        }
      default:
        jj_la1[113] = jj_gen;
        break label_39;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(BIT_OR);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = ExclusiveOrExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new InclusiveOrExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public ExclusiveOrExpression ExclusiveOrExpression() throws ParseException {// --- JTB generated node declarations ---
  AndExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  AndExpression n5 = null;
    n0 = AndExpression();
    label_40:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case XOR:{
        ;
        break;
        }
      default:
        jj_la1[114] = jj_gen;
        break label_40;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(XOR);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = AndExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ExclusiveOrExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public AndExpression AndExpression() throws ParseException {// --- JTB generated node declarations ---
  EqualityExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  EqualityExpression n5 = null;
    n0 = EqualityExpression();
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_AND:{
        ;
        break;
        }
      default:
        jj_la1[115] = jj_gen;
        break label_41;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(BIT_AND);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = EqualityExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new AndExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public EqualityExpression EqualityExpression() throws ParseException {// --- JTB generated node declarations ---
  InstanceOfExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  InstanceOfExpression n8 = null;
    n0 = InstanceOfExpression();
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQ:
      case NE:{
        ;
        break;
        }
      default:
        jj_la1[116] = jj_gen;
        break label_42;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQ:{
        n5 = jj_consume_token(EQ);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0, 2);
        break;
        }
      case NE:{
        n7 = jj_consume_token(NE);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1, 2);
        break;
        }
      default:
        jj_la1[117] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n8 = InstanceOfExpression();
n2.addNode(n8);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new EqualityExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public InstanceOfExpression InstanceOfExpression() throws ParseException {// --- JTB generated node declarations ---
  RelationalExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Type n5 = null;
    n0 = RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INSTANCEOF:{
n2 = new NodeSequence(2);
      n4 = jj_consume_token(INSTANCEOF);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Type();
n2.addNode(n5);
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[118] = jj_gen;
      ;
    }
{if ("" != null) return new InstanceOfExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public RelationalExpression RelationalExpression() throws ParseException {// --- JTB generated node declarations ---
  ShiftExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  ShiftExpression n12 = null;
    n0 = ShiftExpression();
    label_43:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:
      case LE:
      case GE:
      case GT:{
        ;
        break;
        }
      default:
        jj_la1[119] = jj_gen;
        break label_43;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:{
        n5 = jj_consume_token(LT);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0, 4);
        break;
        }
      case GT:{
        n7 = jj_consume_token(GT);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1, 4);
        break;
        }
      case LE:{
        n9 = jj_consume_token(LE);
n8 = JTBToolkit.makeNodeToken(n9);
n3 = new NodeChoice(n8, 2, 4);
        break;
        }
      case GE:{
        n11 = jj_consume_token(GE);
n10 = JTBToolkit.makeNodeToken(n11);
n3 = new NodeChoice(n10, 3, 4);
        break;
        }
      default:
        jj_la1[120] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n12 = ShiftExpression();
n2.addNode(n12);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new RelationalExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public ShiftExpression ShiftExpression() throws ParseException {// --- JTB generated node declarations ---
  AdditiveExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  RUnsignedShift n6 = null;
  RSignedShift n7 = null;
  AdditiveExpression n8 = null;
    n0 = AdditiveExpression();
    label_44:
    while (true) {
      if (jj_2_23(1)) {
        ;
      } else {
        break label_44;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 146:{
        n5 = jj_consume_token(146);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0, 3);
        break;
        }
      default:
        jj_la1[121] = jj_gen;
        if (jj_2_24(1)) {
          n6 = RUnsignedShift();
n3 = new NodeChoice(n6, 1, 3);
        } else if (jj_2_25(1)) {
          n7 = RSignedShift();
n3 = new NodeChoice(n7, 2, 3);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
n2.addNode(n3);
      n8 = AdditiveExpression();
n2.addNode(n8);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ShiftExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

/* We use productions to match >>>, >> and > so that we can keep the type declaration syntax with generics clean */
// ModMMa 07/2012 : moved from after TryStatement() and renamed from RSIGNEDSHIFT()
  final public RSignedShift RSignedShift() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    if (getToken(1).kind == GT && ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    // modified MMa 07/2012 : '">" ">"' changed to '">>"' ?
      n1 = jj_consume_token(RSIGNEDSHIFT);
n0 = JTBToolkit.makeNodeToken(n1);
{if ("" != null) return new RSignedShift(n0);}
    throw new Error("Missing return statement in function");
}

// ModMMa 07/2012 : moved from after TryStatement() and renamed from RUNSIGNEDSHIFT()
  final public RUnsignedShift RUnsignedShift() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    if (getToken(1).kind == GT && ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    // modified MMa 07/2012 : '">" ">" ">"' changed to '"> >>"' ?
      n1 = jj_consume_token(RUNSIGNEDSHIFT);
n0 = JTBToolkit.makeNodeToken(n1);
{if ("" != null) return new RUnsignedShift(n0);}
    throw new Error("Missing return statement in function");
}

  final public AdditiveExpression AdditiveExpression() throws ParseException {// --- JTB generated node declarations ---
  MultiplicativeExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  MultiplicativeExpression n8 = null;
    n0 = MultiplicativeExpression();
    label_45:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[122] = jj_gen;
        break label_45;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        n5 = jj_consume_token(PLUS);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0, 2);
        break;
        }
      case MINUS:{
        n7 = jj_consume_token(MINUS);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1, 2);
        break;
        }
      default:
        jj_la1[123] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n8 = MultiplicativeExpression();
n2.addNode(n8);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new AdditiveExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {// --- JTB generated node declarations ---
  UnaryExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  UnaryExpression n10 = null;
    n0 = UnaryExpression();
    label_46:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STAR:
      case SLASH:
      case REM:{
        ;
        break;
        }
      default:
        jj_la1[124] = jj_gen;
        break label_46;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STAR:{
        n5 = jj_consume_token(STAR);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0, 3);
        break;
        }
      case SLASH:{
        n7 = jj_consume_token(SLASH);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1, 3);
        break;
        }
      case REM:{
        n9 = jj_consume_token(REM);
n8 = JTBToolkit.makeNodeToken(n9);
n3 = new NodeChoice(n8, 2, 3);
        break;
        }
      default:
        jj_la1[125] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n10 = UnaryExpression();
n2.addNode(n10);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new MultiplicativeExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public UnaryExpression UnaryExpression() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  UnaryExpression n7 = null;
  PreIncrementExpression n8 = null;
  PreDecrementExpression n9 = null;
  UnaryExpressionNotPlusMinus n10 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PLUS:
    case MINUS:{
n1 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        n4 = jj_consume_token(PLUS);
n3 = JTBToolkit.makeNodeToken(n4);
n2 = new NodeChoice(n3, 0, 2);
        break;
        }
      case MINUS:{
        n6 = jj_consume_token(MINUS);
n5 = JTBToolkit.makeNodeToken(n6);
n2 = new NodeChoice(n5, 1, 2);
        break;
        }
      default:
        jj_la1[126] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n2);
      n7 = UnaryExpression();
n1.addNode(n7);
n0 = new NodeChoice(n1, 0, 4);
      break;
      }
    case INCR:{
      n8 = PreIncrementExpression();
n0 = new NodeChoice(n8, 1, 4);
      break;
      }
    case DECR:{
      n9 = PreDecrementExpression();
n0 = new NodeChoice(n9, 2, 4);
      break;
      }
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case IDENTIFIER:{
      n10 = UnaryExpressionNotPlusMinus();
n0 = new NodeChoice(n10, 3, 4);
      break;
      }
    default:
      jj_la1[127] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new UnaryExpression(n0);}
    throw new Error("Missing return statement in function");
}

  final public PreIncrementExpression PreIncrementExpression() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  PrimaryExpression n2 = null;
    n1 = jj_consume_token(INCR);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrimaryExpression();
{if ("" != null) return new PreIncrementExpression(n0, n2);}
    throw new Error("Missing return statement in function");
}

  final public PreDecrementExpression PreDecrementExpression() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  PrimaryExpression n2 = null;
    n1 = jj_consume_token(DECR);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrimaryExpression();
{if ("" != null) return new PreDecrementExpression(n0, n2);}
    throw new Error("Missing return statement in function");
}

  final public UnaryExpressionNotPlusMinus UnaryExpressionNotPlusMinus() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  UnaryExpression n7 = null;
  CastExpression n8 = null;
  PostfixExpression n9 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BANG:
    case TILDE:{
n1 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TILDE:{
        n4 = jj_consume_token(TILDE);
n3 = JTBToolkit.makeNodeToken(n4);
n2 = new NodeChoice(n3, 0, 2);
        break;
        }
      case BANG:{
        n6 = jj_consume_token(BANG);
n5 = JTBToolkit.makeNodeToken(n6);
n2 = new NodeChoice(n5, 1, 2);
        break;
        }
      default:
        jj_la1[128] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n2);
      n7 = UnaryExpression();
n1.addNode(n7);
n0 = new NodeChoice(n1, 0, 3);
      break;
      }
    default:
      jj_la1[129] = jj_gen;
      if (jj_2_26(2147483647)) {
        n8 = CastExpression();
n0 = new NodeChoice(n8, 1, 3);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case IDENTIFIER:{
          n9 = PostfixExpression();
n0 = new NodeChoice(n9, 2, 3);
          break;
          }
        default:
          jj_la1[130] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return new UnaryExpressionNotPlusMinus(n0);}
    throw new Error("Missing return statement in function");
}

/*
 * This production is to determine lookahead only.
 * The LOOKAHEAD specifications below are not used, but they are there just to indicate that we know about this.
 */
  final public CastLookahead CastLookahead() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  PrimitiveType n4 = null;
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  Type n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeSequence n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  Type n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeChoice n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  NodeToken n26 = null;
  Token n27 = null;
  NodeToken n28 = null;
  Token n29 = null;
  NodeToken n30 = null;
  Token n31 = null;
  NodeToken n32 = null;
  Token n33 = null;
  Literal n34 = null;
    if (jj_2_27(2)) {
n1 = new NodeSequence(2);
      n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = PrimitiveType();
n1.addNode(n4);
n0 = new NodeChoice(n1, 0, 3);
    } else if (jj_2_28(2147483647)) {
n5 = new NodeSequence(4);
      n7 = jj_consume_token(LPAREN);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
      n8 = Type();
n5.addNode(n8);
      n10 = jj_consume_token(LBRACKET);
n9 = JTBToolkit.makeNodeToken(n10);
n5.addNode(n9);
      n12 = jj_consume_token(RBRACKET);
n11 = JTBToolkit.makeNodeToken(n12);
n5.addNode(n11);
n0 = new NodeChoice(n5, 1, 3);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
n13 = new NodeSequence(4);
        n15 = jj_consume_token(LPAREN);
n14 = JTBToolkit.makeNodeToken(n15);
n13.addNode(n14);
        n16 = Type();
n13.addNode(n16);
        n18 = jj_consume_token(RPAREN);
n17 = JTBToolkit.makeNodeToken(n18);
n13.addNode(n17);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case TILDE:{
          n21 = jj_consume_token(TILDE);
n20 = JTBToolkit.makeNodeToken(n21);
n19 = new NodeChoice(n20, 0, 8);
          break;
          }
        case BANG:{
          n23 = jj_consume_token(BANG);
n22 = JTBToolkit.makeNodeToken(n23);
n19 = new NodeChoice(n22, 1, 8);
          break;
          }
        case LPAREN:{
          n25 = jj_consume_token(LPAREN);
n24 = JTBToolkit.makeNodeToken(n25);
n19 = new NodeChoice(n24, 2, 8);
          break;
          }
        case IDENTIFIER:{
          n27 = jj_consume_token(IDENTIFIER);
n26 = JTBToolkit.makeNodeToken(n27);
n19 = new NodeChoice(n26, 3, 8);
          break;
          }
        case THIS:{
          n29 = jj_consume_token(THIS);
n28 = JTBToolkit.makeNodeToken(n29);
n19 = new NodeChoice(n28, 4, 8);
          break;
          }
        case SUPER:{
          n31 = jj_consume_token(SUPER);
n30 = JTBToolkit.makeNodeToken(n31);
n19 = new NodeChoice(n30, 5, 8);
          break;
          }
        case NEW:{
          n33 = jj_consume_token(NEW);
n32 = JTBToolkit.makeNodeToken(n33);
n19 = new NodeChoice(n32, 6, 8);
          break;
          }
        case FALSE:
        case NULL:
        case TRUE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:{
          n34 = Literal();
n19 = new NodeChoice(n34, 7, 8);
          break;
          }
        default:
          jj_la1[131] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
n13.addNode(n19);
n0 = new NodeChoice(n13, 2, 3);
        break;
        }
      default:
        jj_la1[132] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new CastLookahead(n0);}
    throw new Error("Missing return statement in function");
}

  final public PostfixExpression PostfixExpression() throws ParseException {// --- JTB generated node declarations ---
  PrimaryExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n0 = PrimaryExpression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INCR:
    case DECR:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INCR:{
        n4 = jj_consume_token(INCR);
n3 = JTBToolkit.makeNodeToken(n4);
n2 = new NodeChoice(n3, 0, 2);
        break;
        }
      case DECR:{
        n6 = jj_consume_token(DECR);
n5 = JTBToolkit.makeNodeToken(n6);
n2 = new NodeChoice(n5, 1, 2);
        break;
        }
      default:
        jj_la1[133] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[134] = jj_gen;
      ;
    }
{if ("" != null) return new PostfixExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public CastExpression CastExpression() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Type n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  UnaryExpression n7 = null;
  NodeSequence n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  Type n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  UnaryExpressionNotPlusMinus n14 = null;
    if (jj_2_29(2147483647)) {
n1 = new NodeSequence(4);
      n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = Type();
n1.addNode(n4);
      n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
n1.addNode(n5);
      n7 = UnaryExpression();
n1.addNode(n7);
n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
n8 = new NodeSequence(4);
        n10 = jj_consume_token(LPAREN);
n9 = JTBToolkit.makeNodeToken(n10);
n8.addNode(n9);
        n11 = Type();
n8.addNode(n11);
        n13 = jj_consume_token(RPAREN);
n12 = JTBToolkit.makeNodeToken(n13);
n8.addNode(n12);
        n14 = UnaryExpressionNotPlusMinus();
n8.addNode(n14);
n0 = new NodeChoice(n8, 1, 2);
        break;
        }
      default:
        jj_la1[135] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new CastExpression(n0);}
    throw new Error("Missing return statement in function");
}

  final public PrimaryExpression PrimaryExpression() throws ParseException {// --- JTB generated node declarations ---
  PrimaryPrefix n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  PrimarySuffix n2 = null;
    n0 = PrimaryPrefix();
    label_47:
    while (true) {
      if (jj_2_30(2)) {
        ;
      } else {
        break label_47;
      }
      n2 = PrimarySuffix();
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new PrimaryExpression(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public MemberSelector MemberSelector() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TypeArguments n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    n1 = jj_consume_token(DOT);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TypeArguments();
    n4 = jj_consume_token(IDENTIFIER);
n3 = JTBToolkit.makeNodeToken(n4);
{if ("" != null) return new MemberSelector(n0, n2, n3);}
    throw new Error("Missing return statement in function");
}

  final public PrimaryPrefix PrimaryPrefix() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Literal n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeSequence n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  Expression n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  AllocationExpression n17 = null;
  NodeSequence n18 = null;
  ResultType n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  Name n24 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:{
      n1 = Literal();
n0 = new NodeChoice(n1, 0, 7);
      break;
      }
    case THIS:{
      n3 = jj_consume_token(THIS);
n2 = JTBToolkit.makeNodeToken(n3);
n0 = new NodeChoice(n2, 1, 7);
      break;
      }
    case SUPER:{
n4 = new NodeSequence(3);
      n6 = jj_consume_token(SUPER);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n8 = jj_consume_token(DOT);
n7 = JTBToolkit.makeNodeToken(n8);
n4.addNode(n7);
      n10 = jj_consume_token(IDENTIFIER);
n9 = JTBToolkit.makeNodeToken(n10);
n4.addNode(n9);
n0 = new NodeChoice(n4, 2, 7);
      break;
      }
    case LPAREN:{
n11 = new NodeSequence(3);
      n13 = jj_consume_token(LPAREN);
n12 = JTBToolkit.makeNodeToken(n13);
n11.addNode(n12);
      n14 = Expression(null);
n11.addNode(n14);
      n16 = jj_consume_token(RPAREN);
n15 = JTBToolkit.makeNodeToken(n16);
n11.addNode(n15);
n0 = new NodeChoice(n11, 3, 7);
      break;
      }
    case NEW:{
      n17 = AllocationExpression();
n0 = new NodeChoice(n17, 4, 7);
      break;
      }
    default:
      jj_la1[136] = jj_gen;
      if (jj_2_31(2147483647)) {
n18 = new NodeSequence(3);
        n19 = ResultType(null);
n18.addNode(n19);
        n21 = jj_consume_token(DOT);
n20 = JTBToolkit.makeNodeToken(n21);
n18.addNode(n20);
        n23 = jj_consume_token(CLASS);
n22 = JTBToolkit.makeNodeToken(n23);
n18.addNode(n22);
n0 = new NodeChoice(n18, 5, 7);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case IDENTIFIER:{
          n24 = Name(null);
n0 = new NodeChoice(n24, 6, 7);
          break;
          }
        default:
          jj_la1[137] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return new PrimaryPrefix(n0);}
    throw new Error("Missing return statement in function");
}

  final public PrimarySuffix PrimarySuffix() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  AllocationExpression n9 = null;
  MemberSelector n10 = null;
  NodeSequence n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  Expression n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeSequence n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  Arguments n22 = null;
    if (jj_2_32(2)) {
n1 = new NodeSequence(2);
      n3 = jj_consume_token(DOT);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n5 = jj_consume_token(THIS);
n4 = JTBToolkit.makeNodeToken(n5);
n1.addNode(n4);
n0 = new NodeChoice(n1, 0, 6);
    } else if (jj_2_33(2)) {
n6 = new NodeSequence(2);
      n8 = jj_consume_token(DOT);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
      n9 = AllocationExpression();
n6.addNode(n9);
n0 = new NodeChoice(n6, 1, 6);
    } else if (jj_2_34(3)) {
      n10 = MemberSelector();
n0 = new NodeChoice(n10, 2, 6);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
n11 = new NodeSequence(3);
        n13 = jj_consume_token(LBRACKET);
n12 = JTBToolkit.makeNodeToken(n13);
n11.addNode(n12);
        n14 = Expression(null);
n11.addNode(n14);
        n16 = jj_consume_token(RBRACKET);
n15 = JTBToolkit.makeNodeToken(n16);
n11.addNode(n15);
n0 = new NodeChoice(n11, 3, 6);
        break;
        }
      case DOT:{
n17 = new NodeSequence(2);
        n19 = jj_consume_token(DOT);
n18 = JTBToolkit.makeNodeToken(n19);
n17.addNode(n18);
        n21 = jj_consume_token(IDENTIFIER);
n20 = JTBToolkit.makeNodeToken(n21);
n17.addNode(n20);
n0 = new NodeChoice(n17, 4, 6);
        break;
        }
      case LPAREN:{
        n22 = Arguments(null);
n0 = new NodeChoice(n22, 5, 6);
        break;
        }
      default:
        jj_la1[138] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new PrimarySuffix(n0);}
    throw new Error("Missing return statement in function");
}

  final public Literal Literal() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  BooleanLiteral n9 = null;
  NullLiteral n10 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:{
      n2 = jj_consume_token(INTEGER_LITERAL);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0, 6);
      break;
      }
    case FLOATING_POINT_LITERAL:{
      n4 = jj_consume_token(FLOATING_POINT_LITERAL);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1, 6);
      break;
      }
    case CHARACTER_LITERAL:{
      n6 = jj_consume_token(CHARACTER_LITERAL);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2, 6);
      break;
      }
    case STRING_LITERAL:{
      n8 = jj_consume_token(STRING_LITERAL);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3, 6);
      break;
      }
    case FALSE:
    case TRUE:{
      n9 = BooleanLiteral();
n0 = new NodeChoice(n9, 4, 6);
      break;
      }
    case NULL:{
      n10 = NullLiteral();
n0 = new NodeChoice(n10, 5, 6);
      break;
      }
    default:
      jj_la1[139] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new Literal(n0);}
    throw new Error("Missing return statement in function");
}

  final public IntegerLiteral IntegerLiteral() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(INTEGER_LITERAL);
n0 = JTBToolkit.makeNodeToken(n1);
try {
      jtbrt_IntegerLiteral = Integer.parseInt(token.image);
    }
    catch (NumberFormatException e) {
      {if (true) throw new Error();}
    }
{if ("" != null) return new IntegerLiteral(n0);}
    throw new Error("Missing return statement in function");
}

  final public BooleanLiteral BooleanLiteral() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:{
      n2 = jj_consume_token(TRUE);
n1 = JTBToolkit.makeNodeToken(n2);
jtbrt_BooleanLiteral = true;
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case FALSE:{
      n4 = jj_consume_token(FALSE);
n3 = JTBToolkit.makeNodeToken(n4);
jtbrt_BooleanLiteral = false;
n0 = new NodeChoice(n3, 1, 2);
      break;
      }
    default:
      jj_la1[140] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new BooleanLiteral(n0);}
    throw new Error("Missing return statement in function");
}

  final public StringLiteral StringLiteral() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  // --- user BNFProduction java block ---
  Token t = null;
  ;
    n1 = jj_consume_token(STRING_LITERAL);
n0 = JTBToolkit.makeNodeToken(n1);
t = n1;
jtbrt_StringLiteral = remove_escapes_and_quotes(t, t.image);
{if ("" != null) return new StringLiteral(n0);}
    throw new Error("Missing return statement in function");
}

  final public NullLiteral NullLiteral() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(NULL);
n0 = JTBToolkit.makeNodeToken(n1);
{if ("" != null) return new NullLiteral(n0);}
    throw new Error("Missing return statement in function");
}

  final public Arguments Arguments(List<Token> tokens) throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  ArgumentList n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  // --- user BNFProduction java block ---
  Token first = null;
  Token last = null;
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n1 = jj_consume_token(LPAREN);
n0 = JTBToolkit.makeNodeToken(n1);
first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:{
      n3 = ArgumentList();
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[141] = jj_gen;
      ;
    }
last = getToken(0);
    n5 = jj_consume_token(RPAREN);
n4 = JTBToolkit.makeNodeToken(n5);
if (last.next != first) {
      // i.e., this is not an empty sequence
      Token t = first;
      while (true) {
        tokens.add(t);
        if (t == last)
          break;
        t = t.next;
      }
    }
{if ("" != null) return new Arguments(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public ArgumentList ArgumentList() throws ParseException {// --- JTB generated node declarations ---
  Expression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Expression n5 = null;
    n0 = Expression(null);
    label_48:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[142] = jj_gen;
        break label_48;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Expression(null);
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ArgumentList(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public AllocationExpression AllocationExpression() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  PrimitiveType n4 = null;
  ArrayDimsAndInits n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  ClassOrInterfaceType n9 = null;
  NodeOptional n10 = new NodeOptional();
  TypeArguments n11 = null;
  NodeChoice n12 = null;
  ArrayDimsAndInits n13 = null;
  NodeSequence n14 = null;
  Arguments n15 = null;
  NodeOptional n16 = new NodeOptional();
  ClassOrInterfaceBody n17 = null;
    if (jj_2_35(2)) {
n1 = new NodeSequence(3);
      n3 = jj_consume_token(NEW);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = PrimitiveType();
n1.addNode(n4);
      n5 = ArrayDimsAndInits();
n1.addNode(n5);
n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NEW:{
n6 = new NodeSequence(4);
        n8 = jj_consume_token(NEW);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
        n9 = ClassOrInterfaceType();
n6.addNode(n9);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LT:{
          n11 = TypeArguments();
n10.addNode(n11);
          break;
          }
        default:
          jj_la1[143] = jj_gen;
          ;
        }
n6.addNode(n10);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LBRACKET:{
          n13 = ArrayDimsAndInits();
n12 = new NodeChoice(n13, 0, 2);
          break;
          }
        case LPAREN:{
n14 = new NodeSequence(2);
          n15 = Arguments(null);
n14.addNode(n15);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACE:{
            n17 = ClassOrInterfaceBody(false, null);
n16.addNode(n17);
            break;
            }
          default:
            jj_la1[144] = jj_gen;
            ;
          }
n14.addNode(n16);
n12 = new NodeChoice(n14, 1, 2);
          break;
          }
        default:
          jj_la1[145] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
n6.addNode(n12);
n0 = new NodeChoice(n6, 1, 2);
        break;
        }
      default:
        jj_la1[146] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new AllocationExpression(n0);}
    throw new Error("Missing return statement in function");
}

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]"
 */
  final public ArrayDimsAndInits ArrayDimsAndInits() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeList n2 = new NodeList();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  Expression n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeListOptional n9 = new NodeListOptional();
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeSequence n15 = null;
  NodeList n16 = new NodeList();
  NodeSequence n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  ArrayInitializer n22 = null;
    if (jj_2_38(2)) {
n1 = new NodeSequence(2);
      label_49:
      while (true) {
n3 = new NodeSequence(3);
        n5 = jj_consume_token(LBRACKET);
n4 = JTBToolkit.makeNodeToken(n5);
n3.addNode(n4);
        n6 = Expression(null);
n3.addNode(n6);
        n8 = jj_consume_token(RBRACKET);
n7 = JTBToolkit.makeNodeToken(n8);
n3.addNode(n7);
n2.addNode(n3);
        if (jj_2_36(2)) {
          ;
        } else {
          break label_49;
        }
      }
n2.nodes.trimToSize();
n1.addNode(n2);
      label_50:
      while (true) {
        if (jj_2_37(2)) {
          ;
        } else {
          break label_50;
        }
n10 = new NodeSequence(2);
        n12 = jj_consume_token(LBRACKET);
n11 = JTBToolkit.makeNodeToken(n12);
n10.addNode(n11);
        n14 = jj_consume_token(RBRACKET);
n13 = JTBToolkit.makeNodeToken(n14);
n10.addNode(n13);
n9.addNode(n10);
      }
n9.nodes.trimToSize();
n1.addNode(n9);
n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
n15 = new NodeSequence(2);
        label_51:
        while (true) {
n17 = new NodeSequence(2);
          n19 = jj_consume_token(LBRACKET);
n18 = JTBToolkit.makeNodeToken(n19);
n17.addNode(n18);
          n21 = jj_consume_token(RBRACKET);
n20 = JTBToolkit.makeNodeToken(n21);
n17.addNode(n20);
n16.addNode(n17);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACKET:{
            ;
            break;
            }
          default:
            jj_la1[147] = jj_gen;
            break label_51;
          }
        }
n16.nodes.trimToSize();
n15.addNode(n16);
        n22 = ArrayInitializer();
n15.addNode(n22);
n0 = new NodeChoice(n15, 1, 2);
        break;
        }
      default:
        jj_la1[148] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new ArrayDimsAndInits(n0);}
    throw new Error("Missing return statement in function");
}

  final public Statement Statement() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  LabeledStatement n1 = null;
  AssertStatement n2 = null;
  Block n3 = null;
  EmptyStatement n4 = null;
  NodeSequence n5 = null;
  StatementExpression n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  SwitchStatement n9 = null;
  IfStatement n10 = null;
  WhileStatement n11 = null;
  DoStatement n12 = null;
  ForStatement n13 = null;
  BreakStatement n14 = null;
  ContinueStatement n15 = null;
  ReturnStatement n16 = null;
  ThrowStatement n17 = null;
  SynchronizedStatement n18 = null;
  TryStatement n19 = null;
    if (jj_2_39(2)) {
      n1 = LabeledStatement();
n0 = new NodeChoice(n1, 0, 16);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASSERT:{
        n2 = AssertStatement();
n0 = new NodeChoice(n2, 1, 16);
        break;
        }
      case LBRACE:{
        n3 = Block(null);
n0 = new NodeChoice(n3, 2, 16);
        break;
        }
      case SEMICOLON:{
        n4 = EmptyStatement();
n0 = new NodeChoice(n4, 3, 16);
        break;
        }
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case INCR:
      case DECR:
      case IDENTIFIER:{
n5 = new NodeSequence(2);
        n6 = StatementExpression();
n5.addNode(n6);
        n8 = jj_consume_token(SEMICOLON);
n7 = JTBToolkit.makeNodeToken(n8);
n5.addNode(n7);
n0 = new NodeChoice(n5, 4, 16);
        break;
        }
      case SWITCH:{
        n9 = SwitchStatement();
n0 = new NodeChoice(n9, 5, 16);
        break;
        }
      case IF:{
        n10 = IfStatement();
n0 = new NodeChoice(n10, 6, 16);
        break;
        }
      case WHILE:{
        n11 = WhileStatement();
n0 = new NodeChoice(n11, 7, 16);
        break;
        }
      case DO:{
        n12 = DoStatement();
n0 = new NodeChoice(n12, 8, 16);
        break;
        }
      case FOR:{
        n13 = ForStatement();
n0 = new NodeChoice(n13, 9, 16);
        break;
        }
      case BREAK:{
        n14 = BreakStatement();
n0 = new NodeChoice(n14, 10, 16);
        break;
        }
      case CONTINUE:{
        n15 = ContinueStatement();
n0 = new NodeChoice(n15, 11, 16);
        break;
        }
      case RETURN:{
        n16 = ReturnStatement();
n0 = new NodeChoice(n16, 12, 16);
        break;
        }
      case THROW:{
        n17 = ThrowStatement();
n0 = new NodeChoice(n17, 13, 16);
        break;
        }
      case SYNCHRONIZED:{
        n18 = SynchronizedStatement();
n0 = new NodeChoice(n18, 14, 16);
        break;
        }
      case TRY:{
        n19 = TryStatement();
n0 = new NodeChoice(n19, 15, 16);
        break;
        }
      default:
        jj_la1[149] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new Statement(n0);}
    throw new Error("Missing return statement in function");
}

  final public AssertStatement AssertStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Expression n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Expression n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(ASSERT);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Expression(null);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLON:{
n4 = new NodeSequence(2);
      n6 = jj_consume_token(COLON);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = Expression(null);
n4.addNode(n7);
n3.addNode(n4);
      break;
      }
    default:
      jj_la1[150] = jj_gen;
      ;
    }
    n9 = jj_consume_token(SEMICOLON);
n8 = JTBToolkit.makeNodeToken(n9);
{if ("" != null) return new AssertStatement(n0, n2, n3, n8);}
    throw new Error("Missing return statement in function");
}

  final public LabeledStatement LabeledStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Statement n4 = null;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(COLON);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Statement();
{if ("" != null) return new LabeledStatement(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public Block Block(List<Token> tokens) throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  BlockStatement n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  // --- user BNFProduction java block ---
  Token first = null;
  Token last = null;
  if (tokens == null)
    tokens = new ArrayList<Token>();
    n1 = jj_consume_token(LBRACE);
n0 = JTBToolkit.makeNodeToken(n1);
first = getToken(1);
    label_52:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
      case 147:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[151] = jj_gen;
        break label_52;
      }
      n3 = BlockStatement();
n2.addNode(n3);
    }
n2.nodes.trimToSize();
last = getToken(0);
    n5 = jj_consume_token(RBRACE);
n4 = JTBToolkit.makeNodeToken(n5);
if (last.next != first) {
      // i.e., this is not an empty sequence
      Token t = first;
      while (true) {
        tokens.add(t);
        if (t == last)
          break;
        t = t.next;
      }
    }
{if ("" != null) return new Block(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public BlockStatement BlockStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  LocalVariableDeclaration n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Statement n5 = null;
  ClassOrInterfaceDeclaration n6 = null;
    if (jj_2_40(2147483647)) {
n1 = new NodeSequence(2);
      n2 = LocalVariableDeclaration();
n1.addNode(n2);
      n4 = jj_consume_token(SEMICOLON);
n3 = JTBToolkit.makeNodeToken(n4);
n1.addNode(n3);
n0 = new NodeChoice(n1, 0, 3);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case ASSERT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
      case IDENTIFIER:{
        n5 = Statement();
n0 = new NodeChoice(n5, 1, 3);
        break;
        }
      case CLASS:
      case INTERFACE:{
        n6 = ClassOrInterfaceDeclaration();
n0 = new NodeChoice(n6, 2, 3);
        break;
        }
      default:
        jj_la1[152] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new BlockStatement(n0);}
    throw new Error("Missing return statement in function");
}

  final public LocalVariableDeclaration LocalVariableDeclaration() throws ParseException {// --- JTB generated node declarations ---
  VariableModifiers n0 = null;
  Type n1 = null;
  VariableDeclarator n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  VariableDeclarator n7 = null;
    // modified MMa 06/2012
      //  Modifiers() Type() VariableDeclarator()
      n0 = VariableModifiers();
    n1 = Type();
    n2 = VariableDeclarator();
    label_53:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[153] = jj_gen;
        break label_53;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = VariableDeclarator();
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
{if ("" != null) return new LocalVariableDeclaration(n0, n1, n2, n3);}
    throw new Error("Missing return statement in function");
}

// added MMa 06/2012
  final public VariableModifiers VariableModifiers() throws ParseException {// --- JTB generated node declarations ---
  NodeListOptional n0 = new NodeListOptional();
  NodeChoice n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Annotation n4 = null;
    label_54:
    while (true) {
      if (jj_2_41(2)) {
        ;
      } else {
        break label_54;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FINAL:{
        n3 = jj_consume_token(FINAL);
n2 = JTBToolkit.makeNodeToken(n3);
n1 = new NodeChoice(n2, 0, 2);
        break;
        }
      case 147:{
        n4 = Annotation();
n1 = new NodeChoice(n4, 1, 2);
        break;
        }
      default:
        jj_la1[154] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
    }
n0.nodes.trimToSize();
{if ("" != null) return new VariableModifiers(n0);}
    throw new Error("Missing return statement in function");
}

  final public EmptyStatement EmptyStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SEMICOLON);
n0 = JTBToolkit.makeNodeToken(n1);
{if ("" != null) return new EmptyStatement(n0);}
    throw new Error("Missing return statement in function");
}

  final public StatementExpression StatementExpression() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  PreIncrementExpression n1 = null;
  PreDecrementExpression n2 = null;
  NodeSequence n3 = null;
  PrimaryExpression n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeChoice n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeSequence n11 = null;
  AssignmentOperator n12 = null;
  Expression n13 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INCR:{
      n1 = PreIncrementExpression();
n0 = new NodeChoice(n1, 0, 3);
      break;
      }
    case DECR:{
      n2 = PreDecrementExpression();
n0 = new NodeChoice(n2, 1, 3);
      break;
      }
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case IDENTIFIER:{
n3 = new NodeSequence(2);
      n4 = PrimaryExpression();
n3.addNode(n4);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASSIGN:
      case INCR:
      case DECR:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case 143:
      case 144:
      case 145:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INCR:{
          n8 = jj_consume_token(INCR);
n7 = JTBToolkit.makeNodeToken(n8);
n6 = new NodeChoice(n7, 0, 3);
          break;
          }
        case DECR:{
          n10 = jj_consume_token(DECR);
n9 = JTBToolkit.makeNodeToken(n10);
n6 = new NodeChoice(n9, 1, 3);
          break;
          }
        case ASSIGN:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case 143:
        case 144:
        case 145:{
n11 = new NodeSequence(2);
          n12 = AssignmentOperator();
n11.addNode(n12);
          n13 = Expression(null);
n11.addNode(n13);
n6 = new NodeChoice(n11, 2, 3);
          break;
          }
        default:
          jj_la1[155] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
n5.addNode(n6);
        break;
        }
      default:
        jj_la1[156] = jj_gen;
        ;
      }
n3.addNode(n5);
n0 = new NodeChoice(n3, 2, 3);
      break;
      }
    default:
      jj_la1[157] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new StatementExpression(n0);}
    throw new Error("Missing return statement in function");
}

  final public SwitchStatement SwitchStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeListOptional n9 = new NodeListOptional();
  NodeSequence n10 = null;
  SwitchLabel n11 = null;
  NodeListOptional n12 = null;
  BlockStatement n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
    n1 = jj_consume_token(SWITCH);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression(null);
    n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(LBRACE);
n7 = JTBToolkit.makeNodeToken(n8);
    label_55:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CASE:
      case _DEFAULT:{
        ;
        break;
        }
      default:
        jj_la1[158] = jj_gen;
        break label_55;
      }
n12 = new NodeListOptional();
n10 = new NodeSequence(2);
      n11 = SwitchLabel();
n10.addNode(n11);
      label_56:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case ASSERT:
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CLASS:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case FOR:
        case IF:
        case INT:
        case INTERFACE:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case LBRACE:
        case SEMICOLON:
        case INCR:
        case DECR:
        case 147:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[159] = jj_gen;
          break label_56;
        }
        n13 = BlockStatement();
n12.addNode(n13);
      }
n12.nodes.trimToSize();
n10.addNode(n12);
n9.addNode(n10);
    }
n9.nodes.trimToSize();
    n15 = jj_consume_token(RBRACE);
n14 = JTBToolkit.makeNodeToken(n15);
{if ("" != null) return new SwitchStatement(n0, n2, n4, n5, n7, n9, n14);}
    throw new Error("Missing return statement in function");
}

  final public SwitchLabel SwitchLabel() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CASE:{
n1 = new NodeSequence(3);
      n3 = jj_consume_token(CASE);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = Expression(null);
n1.addNode(n4);
      n6 = jj_consume_token(COLON);
n5 = JTBToolkit.makeNodeToken(n6);
n1.addNode(n5);
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case _DEFAULT:{
n7 = new NodeSequence(2);
      n9 = jj_consume_token(_DEFAULT);
n8 = JTBToolkit.makeNodeToken(n9);
n7.addNode(n8);
      n11 = jj_consume_token(COLON);
n10 = JTBToolkit.makeNodeToken(n11);
n7.addNode(n10);
n0 = new NodeChoice(n7, 1, 2);
      break;
      }
    default:
      jj_la1[160] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new SwitchLabel(n0);}
    throw new Error("Missing return statement in function");
}

  final public IfStatement IfStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Statement n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  Statement n12 = null;
    n1 = jj_consume_token(IF);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression(null);
    n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ELSE:{
n9 = new NodeSequence(2);
      n11 = jj_consume_token(ELSE);
n10 = JTBToolkit.makeNodeToken(n11);
n9.addNode(n10);
      n12 = Statement();
n9.addNode(n12);
n8.addNode(n9);
      break;
      }
    default:
      jj_la1[161] = jj_gen;
      ;
    }
{if ("" != null) return new IfStatement(n0, n2, n4, n5, n7, n8);}
    throw new Error("Missing return statement in function");
}

  final public WhileStatement WhileStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Statement n7 = null;
    n1 = jj_consume_token(WHILE);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression(null);
    n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
{if ("" != null) return new WhileStatement(n0, n2, n4, n5, n7);}
    throw new Error("Missing return statement in function");
}

  final public DoStatement DoStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Statement n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Expression n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
    n1 = jj_consume_token(DO);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Statement();
    n4 = jj_consume_token(WHILE);
n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(LPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Expression(null);
    n9 = jj_consume_token(RPAREN);
n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(SEMICOLON);
n10 = JTBToolkit.makeNodeToken(n11);
{if ("" != null) return new DoStatement(n0, n2, n3, n5, n7, n8, n10);}
    throw new Error("Missing return statement in function");
}

  final public ForStatement ForStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeChoice n4 = null;
  NodeSequence n5 = null;
  VariableModifiers n6 = null;
  Type n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  Expression n12 = null;
  NodeSequence n13 = null;
  NodeOptional n14 = new NodeOptional();
  ForInit n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeOptional n18 = new NodeOptional();
  Expression n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeOptional n22 = new NodeOptional();
  ForUpdate n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  Statement n26 = null;
    n1 = jj_consume_token(FOR);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    if (jj_2_42(2147483647)) {
n5 = new NodeSequence(5);
      n6 = VariableModifiers();
n5.addNode(n6);
      n7 = Type();
n5.addNode(n7);
      n9 = jj_consume_token(IDENTIFIER);
n8 = JTBToolkit.makeNodeToken(n9);
n5.addNode(n8);
      n11 = jj_consume_token(COLON);
n10 = JTBToolkit.makeNodeToken(n11);
n5.addNode(n10);
      n12 = Expression(null);
n5.addNode(n12);
n4 = new NodeChoice(n5, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case SEMICOLON:
      case INCR:
      case DECR:
      case 147:
      case IDENTIFIER:{
n13 = new NodeSequence(5);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case INCR:
        case DECR:
        case 147:
        case IDENTIFIER:{
          n15 = ForInit();
n14.addNode(n15);
          break;
          }
        default:
          jj_la1[162] = jj_gen;
          ;
        }
n13.addNode(n14);
        n17 = jj_consume_token(SEMICOLON);
n16 = JTBToolkit.makeNodeToken(n17);
n13.addNode(n16);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case BANG:
        case TILDE:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case IDENTIFIER:{
          n19 = Expression(null);
n18.addNode(n19);
          break;
          }
        default:
          jj_la1[163] = jj_gen;
          ;
        }
n13.addNode(n18);
        n21 = jj_consume_token(SEMICOLON);
n20 = JTBToolkit.makeNodeToken(n21);
n13.addNode(n20);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case _LOOKAHEAD:
        case _IGNORE_CASE:
        case _PARSER_BEGIN:
        case _PARSER_END:
        case _JAVACODE:
        case _TOKEN:
        case _SPECIAL_TOKEN:
        case _MORE:
        case _SKIP:
        case _TOKEN_MGR_DECLS:
        case _EOF:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LPAREN:
        case INCR:
        case DECR:
        case IDENTIFIER:{
          n23 = ForUpdate();
n22.addNode(n23);
          break;
          }
        default:
          jj_la1[164] = jj_gen;
          ;
        }
n13.addNode(n22);
n4 = new NodeChoice(n13, 1, 2);
        break;
        }
      default:
        jj_la1[165] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    n25 = jj_consume_token(RPAREN);
n24 = JTBToolkit.makeNodeToken(n25);
    n26 = Statement();
{if ("" != null) return new ForStatement(n0, n2, n4, n24, n26);}
    throw new Error("Missing return statement in function");
}

  final public ForInit ForInit() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  LocalVariableDeclaration n1 = null;
  StatementExpressionList n2 = null;
    if (jj_2_43(2147483647)) {
      n1 = LocalVariableDeclaration();
n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case _LOOKAHEAD:
      case _IGNORE_CASE:
      case _PARSER_BEGIN:
      case _PARSER_END:
      case _JAVACODE:
      case _TOKEN:
      case _SPECIAL_TOKEN:
      case _MORE:
      case _SKIP:
      case _TOKEN_MGR_DECLS:
      case _EOF:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LPAREN:
      case INCR:
      case DECR:
      case IDENTIFIER:{
        n2 = StatementExpressionList();
n0 = new NodeChoice(n2, 1, 2);
        break;
        }
      default:
        jj_la1[166] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new ForInit(n0);}
    throw new Error("Missing return statement in function");
}

  final public StatementExpressionList StatementExpressionList() throws ParseException {// --- JTB generated node declarations ---
  StatementExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  StatementExpression n5 = null;
    n0 = StatementExpression();
    label_57:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[167] = jj_gen;
        break label_57;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = StatementExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new StatementExpressionList(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public ForUpdate ForUpdate() throws ParseException {// --- JTB generated node declarations ---
  StatementExpressionList n0 = null;
    n0 = StatementExpressionList();
{if ("" != null) return new ForUpdate(n0);}
    throw new Error("Missing return statement in function");
}

  final public BreakStatement BreakStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(BREAK);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      n4 = jj_consume_token(IDENTIFIER);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[168] = jj_gen;
      ;
    }
    n6 = jj_consume_token(SEMICOLON);
n5 = JTBToolkit.makeNodeToken(n6);
{if ("" != null) return new BreakStatement(n0, n2, n5);}
    throw new Error("Missing return statement in function");
}

  final public ContinueStatement ContinueStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(CONTINUE);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      n4 = jj_consume_token(IDENTIFIER);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[169] = jj_gen;
      ;
    }
    n6 = jj_consume_token(SEMICOLON);
n5 = JTBToolkit.makeNodeToken(n6);
{if ("" != null) return new ContinueStatement(n0, n2, n5);}
    throw new Error("Missing return statement in function");
}

  final public ReturnStatement ReturnStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  Expression n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  // --- user BNFProduction java block ---
  Token t = null;
    n1 = jj_consume_token(RETURN);
n0 = JTBToolkit.makeNodeToken(n1);
t = n1;
// Add if statement to prevent subsequent code generated from being dead code
    if (inAction) {
      t.image = "{if (true) return";
      jumpPatched = true;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:{
      n3 = Expression(null);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[170] = jj_gen;
      ;
    }
    n5 = jj_consume_token(SEMICOLON);
n4 = JTBToolkit.makeNodeToken(n5);
t = n5;
// Add closing brace for above if statement
    if (inAction) {
      t.image = ";}";
    }
{if ("" != null) return new ReturnStatement(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public ThrowStatement ThrowStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Expression n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  // --- user BNFProduction java block ---
  Token t = null;
    n1 = jj_consume_token(THROW);
n0 = JTBToolkit.makeNodeToken(n1);
t = n1;
// Add if statement to prevent subsequent code generated from being dead code
    if (inAction) {
      t.image = "{if (true) throw";
      jumpPatched = true;
    }
    n2 = Expression(null);
    n4 = jj_consume_token(SEMICOLON);
n3 = JTBToolkit.makeNodeToken(n4);
t = n4;
// Add closing brace for above if statement
    if (inAction) {
      t.image = ";}";
    }
{if ("" != null) return new ThrowStatement(n0, n2, n3);}
    throw new Error("Missing return statement in function");
}

  final public SynchronizedStatement SynchronizedStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Expression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Block n7 = null;
    n1 = jj_consume_token(SYNCHRONIZED);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression(null);
    n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Block(null);
{if ("" != null) return new SynchronizedStatement(n0, n2, n4, n5, n7);}
    throw new Error("Missing return statement in function");
}

  final public TryStatement TryStatement() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Block n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  FormalParameter n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  Block n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  Block n17 = null;
    n1 = jj_consume_token(TRY);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Block(null);
    label_58:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CATCH:{
        ;
        break;
        }
      default:
        jj_la1[171] = jj_gen;
        break label_58;
      }
n4 = new NodeSequence(5);
      n6 = jj_consume_token(CATCH);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n8 = jj_consume_token(LPAREN);
n7 = JTBToolkit.makeNodeToken(n8);
n4.addNode(n7);
      n9 = FormalParameter();
n4.addNode(n9);
      n11 = jj_consume_token(RPAREN);
n10 = JTBToolkit.makeNodeToken(n11);
n4.addNode(n10);
      n12 = Block(null);
n4.addNode(n12);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FINALLY:{
n14 = new NodeSequence(2);
      n16 = jj_consume_token(FINALLY);
n15 = JTBToolkit.makeNodeToken(n16);
n14.addNode(n15);
      n17 = Block(null);
n14.addNode(n17);
n13.addNode(n14);
      break;
      }
    default:
      jj_la1[172] = jj_gen;
      ;
    }
{if ("" != null) return new TryStatement(n0, n2, n3, n13);}
    throw new Error("Missing return statement in function");
}

  final public Annotation Annotation() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NormalAnnotation n1 = null;
  SingleMemberAnnotation n2 = null;
  MarkerAnnotation n3 = null;
    if (jj_2_44(2147483647)) {
      n1 = NormalAnnotation();
n0 = new NodeChoice(n1, 0, 3);
    } else if (jj_2_45(2147483647)) {
      n2 = SingleMemberAnnotation();
n0 = new NodeChoice(n2, 1, 3);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 147:{
        n3 = MarkerAnnotation();
n0 = new NodeChoice(n3, 2, 3);
        break;
        }
      default:
        jj_la1[173] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new Annotation(n0);}
    throw new Error("Missing return statement in function");
}

  final public NormalAnnotation NormalAnnotation() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Name n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  MemberValuePairs n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n1 = jj_consume_token(147);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name(null);
    n4 = jj_consume_token(LPAREN);
n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      n6 = MemberValuePairs();
n5.addNode(n6);
      break;
      }
    default:
      jj_la1[174] = jj_gen;
      ;
    }
    n8 = jj_consume_token(RPAREN);
n7 = JTBToolkit.makeNodeToken(n8);
{if ("" != null) return new NormalAnnotation(n0, n2, n3, n5, n7);}
    throw new Error("Missing return statement in function");
}

  final public MarkerAnnotation MarkerAnnotation() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Name n2 = null;
    n1 = jj_consume_token(147);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name(null);
{if ("" != null) return new MarkerAnnotation(n0, n2);}
    throw new Error("Missing return statement in function");
}

  final public SingleMemberAnnotation SingleMemberAnnotation() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Name n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  MemberValue n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(147);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name(null);
    n4 = jj_consume_token(LPAREN);
n3 = JTBToolkit.makeNodeToken(n4);
    n5 = MemberValue();
    n7 = jj_consume_token(RPAREN);
n6 = JTBToolkit.makeNodeToken(n7);
{if ("" != null) return new SingleMemberAnnotation(n0, n2, n3, n5, n6);}
    throw new Error("Missing return statement in function");
}

  final public MemberValuePairs MemberValuePairs() throws ParseException {// --- JTB generated node declarations ---
  MemberValuePair n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  MemberValuePair n5 = null;
    n0 = MemberValuePair();
    label_59:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[175] = jj_gen;
        break label_59;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = MemberValuePair();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new MemberValuePairs(n0, n1);}
    throw new Error("Missing return statement in function");
}

  final public MemberValuePair MemberValuePair() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  MemberValue n4 = null;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(ASSIGN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = MemberValue();
{if ("" != null) return new MemberValuePair(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public MemberValue MemberValue() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Annotation n1 = null;
  MemberValueArrayInitializer n2 = null;
  ConditionalExpression n3 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 147:{
      n1 = Annotation();
n0 = new NodeChoice(n1, 0, 3);
      break;
      }
    case LBRACE:{
      n2 = MemberValueArrayInitializer();
n0 = new NodeChoice(n2, 1, 3);
      break;
      }
    case _LOOKAHEAD:
    case _IGNORE_CASE:
    case _PARSER_BEGIN:
    case _PARSER_END:
    case _JAVACODE:
    case _TOKEN:
    case _SPECIAL_TOKEN:
    case _MORE:
    case _SKIP:
    case _TOKEN_MGR_DECLS:
    case _EOF:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case IDENTIFIER:{
      n3 = ConditionalExpression();
n0 = new NodeChoice(n3, 2, 3);
      break;
      }
    default:
      jj_la1[176] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new MemberValue(n0);}
    throw new Error("Missing return statement in function");
}

  final public MemberValueArrayInitializer MemberValueArrayInitializer() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  MemberValue n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  MemberValue n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    n1 = jj_consume_token(LBRACE);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = MemberValue();
    label_60:
    while (true) {
      if (jj_2_46(2)) {
        ;
      } else {
        break label_60;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = MemberValue();
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:{
      n10 = jj_consume_token(COMMA);
n9 = JTBToolkit.makeNodeToken(n10);
n8.addNode(n9);
      break;
      }
    default:
      jj_la1[177] = jj_gen;
      ;
    }
    n12 = jj_consume_token(RBRACE);
n11 = JTBToolkit.makeNodeToken(n12);
{if ("" != null) return new MemberValueArrayInitializer(n0, n2, n3, n8, n11);}
    throw new Error("Missing return statement in function");
}

  final public AnnotationTypeDeclaration AnnotationTypeDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  AnnotationTypeBody n6 = null;
    n1 = jj_consume_token(147);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INTERFACE);
n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(IDENTIFIER);
n4 = JTBToolkit.makeNodeToken(n5);
    n6 = AnnotationTypeBody();
{if ("" != null) return new AnnotationTypeDeclaration(n0, n2, n4, n6);}
    throw new Error("Missing return statement in function");
}

  final public AnnotationTypeBody AnnotationTypeBody() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  AnnotationTypeMemberDeclaration n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
    n1 = jj_consume_token(LBRACE);
n0 = JTBToolkit.makeNodeToken(n1);
    label_61:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case SEMICOLON:
      case 147:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[178] = jj_gen;
        break label_61;
      }
      n3 = AnnotationTypeMemberDeclaration();
n2.addNode(n3);
    }
n2.nodes.trimToSize();
    n5 = jj_consume_token(RBRACE);
n4 = JTBToolkit.makeNodeToken(n5);
{if ("" != null) return new AnnotationTypeBody(n0, n2, n4);}
    throw new Error("Missing return statement in function");
}

  final public AnnotationTypeMemberDeclaration AnnotationTypeMemberDeclaration() throws ParseException {// --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  Modifiers n2 = null;
  NodeChoice n3 = null;
  NodeSequence n4 = null;
  Type n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeOptional n12 = new NodeOptional();
  DefaultValue n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  ClassOrInterfaceDeclaration n16 = null;
  EnumDeclaration n17 = null;
  AnnotationTypeDeclaration n18 = null;
  FieldDeclaration n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ABSTRACT:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case CLASS:
    case DOUBLE:
    case ENUM:
    case FINAL:
    case FLOAT:
    case INT:
    case INTERFACE:
    case LONG:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 147:
    case IDENTIFIER:{
n1 = new NodeSequence(2);
      n2 = Modifiers();
n1.addNode(n2);
      if (jj_2_47(2147483647)) {
n4 = new NodeSequence(6);
        n5 = Type();
n4.addNode(n5);
        n7 = jj_consume_token(IDENTIFIER);
n6 = JTBToolkit.makeNodeToken(n7);
n4.addNode(n6);
        n9 = jj_consume_token(LPAREN);
n8 = JTBToolkit.makeNodeToken(n9);
n4.addNode(n8);
        n11 = jj_consume_token(RPAREN);
n10 = JTBToolkit.makeNodeToken(n11);
n4.addNode(n10);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case _DEFAULT:{
          n13 = DefaultValue();
n12.addNode(n13);
          break;
          }
        default:
          jj_la1[179] = jj_gen;
          ;
        }
n4.addNode(n12);
        n15 = jj_consume_token(SEMICOLON);
n14 = JTBToolkit.makeNodeToken(n15);
n4.addNode(n14);
n3 = new NodeChoice(n4, 0, 5);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CLASS:
        case INTERFACE:{
          n16 = ClassOrInterfaceDeclaration();
n3 = new NodeChoice(n16, 1, 5);
          break;
          }
        case ENUM:{
          n17 = EnumDeclaration();
n3 = new NodeChoice(n17, 2, 5);
          break;
          }
        case 147:{
          n18 = AnnotationTypeDeclaration();
n3 = new NodeChoice(n18, 3, 5);
          break;
          }
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case IDENTIFIER:{
          n19 = FieldDeclaration();
n3 = new NodeChoice(n19, 4, 5);
          break;
          }
        default:
          jj_la1[180] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
n1.addNode(n3);
n0 = new NodeChoice(n1, 0, 2);
      break;
      }
    case SEMICOLON:{
      n21 = jj_consume_token(SEMICOLON);
n20 = JTBToolkit.makeNodeToken(n21);
n0 = new NodeChoice(n20, 1, 2);
      break;
      }
    default:
      jj_la1[181] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new AnnotationTypeMemberDeclaration(n0);}
    throw new Error("Missing return statement in function");
}

  final public DefaultValue DefaultValue() throws ParseException {// --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  MemberValue n2 = null;
    n1 = jj_consume_token(_DEFAULT);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = MemberValue();
{if ("" != null) return new DefaultValue(n0, n2);}
    throw new Error("Missing return statement in function");
}

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_3()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_4()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_5()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_6()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_7()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_8()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_9()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_10()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_11()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_12()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_13()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_14()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_15()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_16()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_17()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_18()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_19()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_20()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_21()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_22()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_23()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_24()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_25()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_26()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_27()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_28()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_29()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_30()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_31()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_32()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_33()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_34()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_35()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_36()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_37()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_38()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_39()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_40()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_41()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_42()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_43()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_44()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_45()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_46()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_47()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_3R_356()
 {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_193()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_372()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_302()
 {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3R_243()
 {
    if (jj_3R_269()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_302()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_411()
 {
    if (jj_3R_422()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_423()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_32()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_101()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_278()
 {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_411()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_184()
 {
    if (jj_3R_207()) return true;
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_115()
 {
    Token xsp;
    if (jj_3R_184()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_184()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_291()
 {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_243()) return true;
    return false;
  }

  private boolean jj_3R_343()
 {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_361()
 {
    if (jj_3R_375()) return true;
    return false;
  }

  private boolean jj_3R_229()
 {
    if (jj_3R_243()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_291()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_342()
 {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_335()
 {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_338()
 {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_361()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_334()
 {
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3R_333()
 {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_183()
 {
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3R_341()
 {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3_31()
 {
    if (jj_3R_102()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_430()
 {
    if (jj_3R_94()) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_339()
 {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_271()
 {
    if (jj_scan_token(SC_AND)) return true;
    if (jj_3R_229()) return true;
    return false;
  }

  private boolean jj_3R_429()
 {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_268()
 {
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  private boolean jj_3R_328()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_339()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_340()) return true;
    xsp = jj_scanpos;
    if (jj_3R_341()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_342()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_343()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_214()
 {
    if (jj_3R_229()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_271()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_182()
 {
    if (jj_3R_102()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_428()
 {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_327()
 {
    if (jj_scan_token(147)) return true;
    if (jj_scan_token(INTERFACE)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_338()) return true;
    return false;
  }

  private boolean jj_3R_267()
 {
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_181()
 {
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_421()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_428()) {
    jj_scanpos = xsp;
    if (jj_3R_429()) {
    jj_scanpos = xsp;
    if (jj_3R_430()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_241()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_267()) {
    jj_scanpos = xsp;
    if (jj_3R_268()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_333()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_334()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_335()) jj_scanpos = xsp;
    if (jj_3R_273()) return true;
    return false;
  }

  private boolean jj_3R_116()
 {
    if (jj_scan_token(BIT_OR)) return true;
    return false;
  }

  private boolean jj_3R_298()
 {
    if (jj_3R_62()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_421()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_68()
 {
    if (jj_3R_115()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_116()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_297()
 {
    if (jj_3R_306()) return true;
    return false;
  }

  private boolean jj_3R_180()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_296()
 {
    if (jj_3R_305()) return true;
    return false;
  }

  private boolean jj_3R_277()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_296()) {
    jj_scanpos = xsp;
    if (jj_3R_297()) {
    jj_scanpos = xsp;
    if (jj_3R_298()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_308()
 {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_246()
 {
    if (jj_scan_token(SC_OR)) return true;
    if (jj_3R_214()) return true;
    return false;
  }

  private boolean jj_3R_196()
 {
    if (jj_3R_214()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_246()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_179()
 {
    if (jj_scan_token(SUPER)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_390()
 {
    if (jj_scan_token(142)) return true;
    return false;
  }

  private boolean jj_3R_178()
 {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3_46()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_177()
 {
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_376()
 {
    if (jj_3R_118()) return true;
    if (jj_3R_83()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_390()) jj_scanpos = xsp;
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3R_112()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_205()
 {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_111()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_46()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_308()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_276()
 {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_232()
 {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_155()
 {
    if (jj_3R_196()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_232()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_108()
 {
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_176()
 {
    if (jj_3R_155()) return true;
    return false;
  }

  private boolean jj_3R_107()
 {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_175()
 {
    if (jj_3R_205()) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_174()
 {
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_111()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_41()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    return false;
  }

  private boolean jj_3R_106()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_41()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_377()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_376()) return true;
    return false;
  }

  private boolean jj_3R_154()
 {
    if (jj_scan_token(ORASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_104()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_153()
 {
    if (jj_scan_token(XORASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_80()
 {
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_362()
 {
    if (jj_3R_376()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_377()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_152()
 {
    if (jj_scan_token(ANDASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_151()
 {
    if (jj_scan_token(145)) return true;
    return false;
  }

  private boolean jj_3R_300()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_79()
 {
    if (jj_scan_token(STRICTFP)) return true;
    return false;
  }

  private boolean jj_3R_340()
 {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_362()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_150()
 {
    if (jj_scan_token(144)) return true;
    return false;
  }

  private boolean jj_3_30()
 {
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3R_397()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_344()) return true;
    return false;
  }

  private boolean jj_3R_78()
 {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_149()
 {
    if (jj_scan_token(143)) return true;
    return false;
  }

  private boolean jj_3R_62()
 {
    if (jj_3R_112()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_30()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_148()
 {
    if (jj_scan_token(MINUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_239()
 {
    if (jj_3R_106()) return true;
    if (jj_3R_83()) return true;
    if (jj_3R_344()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_397()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_77()
 {
    if (jj_scan_token(TRANSIENT)) return true;
    return false;
  }

  private boolean jj_3R_147()
 {
    if (jj_scan_token(PLUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_114()
 {
    if (jj_scan_token(141)) return true;
    return false;
  }

  private boolean jj_3R_146()
 {
    if (jj_scan_token(REMASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_301()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_300()) return true;
    return false;
  }

  private boolean jj_3R_67()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_114()) jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_76()
 {
    if (jj_scan_token(NATIVE)) return true;
    return false;
  }

  private boolean jj_3R_145()
 {
    if (jj_scan_token(SLASHASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_290()
 {
    if (jj_3R_300()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_301()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_144()
 {
    if (jj_scan_token(STARASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_75()
 {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    return false;
  }

  private boolean jj_3R_409()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_382()) return true;
    return false;
  }

  private boolean jj_3R_143()
 {
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_228()
 {
    if (jj_3R_241()) return true;
    return false;
  }

  private boolean jj_3_29()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3_40()
 {
    if (jj_3R_106()) return true;
    if (jj_3R_83()) return true;
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_scan_token(LT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) jj_scanpos = xsp;
    if (jj_3R_68()) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_94()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_74()
 {
    if (jj_scan_token(ABSTRACT)) return true;
    return false;
  }

  private boolean jj_3R_227()
 {
    if (jj_3R_240()) return true;
    return false;
  }

  private boolean jj_3R_366()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_347()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_340()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_366()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_73()
 {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_408()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_351()) return true;
    return false;
  }

  private boolean jj_3R_226()
 {
    if (jj_3R_239()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_209()
 {
    if (jj_scan_token(147)) return true;
    if (jj_3R_109()) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_111()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_405()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_408()) {
    jj_scanpos = xsp;
    if (jj_3R_409()) return true;
    }
    return false;
  }

  private boolean jj_3R_72()
 {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  private boolean jj_3R_212()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_3R_228()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_71()
 {
    if (jj_scan_token(PROTECTED)) return true;
    return false;
  }

  private boolean jj_3R_350()
 {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_349()
 {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_70()
 {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_210()
 {
    if (jj_scan_token(147)) return true;
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3R_69()
 {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  private boolean jj_3R_436()
 {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_348()
 {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_435()
 {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_270()
 {
    if (jj_3R_290()) return true;
    return false;
  }

  private boolean jj_3R_427()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_435()) {
    jj_scanpos = xsp;
    if (jj_3R_436()) return true;
    }
    return false;
  }

  private boolean jj_3R_118()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_110()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_346()
 {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_406()
 {
    if (jj_3R_62()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_427()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_22()
 {
    if (jj_3R_94()) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_190()
 {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_330()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_346()) jj_scanpos = xsp;
    if (jj_3R_102()) return true;
    if (jj_3R_347()) return true;
    xsp = jj_scanpos;
    if (jj_3R_348()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_349()) {
    jj_scanpos = xsp;
    if (jj_3R_350()) return true;
    }
    return false;
  }

  private boolean jj_3R_208()
 {
    if (jj_scan_token(147)) return true;
    if (jj_3R_109()) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_270()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_95()
 {
    if (jj_3R_155()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_122()
 {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_190()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3_45()
 {
    if (jj_scan_token(147)) return true;
    if (jj_3R_109()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_204()
 {
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3_44()
 {
    if (jj_scan_token(147)) return true;
    if (jj_3R_109()) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    }
    return false;
  }

  private boolean jj_3R_203()
 {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  private boolean jj_3R_187()
 {
    if (jj_3R_210()) return true;
    return false;
  }

  private boolean jj_3R_202()
 {
    if (jj_scan_token(SUPER)) return true;
    return false;
  }

  private boolean jj_3R_186()
 {
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_293()
 {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_201()
 {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_185()
 {
    if (jj_3R_208()) return true;
    return false;
  }

  private boolean jj_3R_200()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_105()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_240()) return true;
    return false;
  }

  private boolean jj_3R_117()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_378()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3R_199()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_363()
 {
    if (jj_3R_109()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_378()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_198()
 {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_197()
 {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_292()
 {
    if (jj_3R_86()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_12()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_419()
 {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_191()
 {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_292()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_293()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_410()
 {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_159()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_275()
 {
    if (jj_scan_token(ASSERT)) return true;
    if (jj_3R_95()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_410()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_28()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_418()
 {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_376()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3_21()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_158()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_124()
 {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_109()
 {
    if (jj_3R_93()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_21()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_288()
 {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_122()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_418()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_419()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_123()
 {
    if (jj_3R_191()) return true;
    return false;
  }

  private boolean jj_3R_266()
 {
    if (jj_3R_288()) return true;
    return false;
  }

  private boolean jj_3R_86()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    }
    return false;
  }

  private boolean jj_3R_265()
 {
    if (jj_3R_287()) return true;
    return false;
  }

  private boolean jj_3_27()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_264()
 {
    if (jj_3R_286()) return true;
    return false;
  }

  private boolean jj_3R_99()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_263()
 {
    if (jj_3R_285()) return true;
    return false;
  }

  private boolean jj_3R_262()
 {
    if (jj_3R_284()) return true;
    return false;
  }

  private boolean jj_3R_261()
 {
    if (jj_3R_283()) return true;
    return false;
  }

  private boolean jj_3R_260()
 {
    if (jj_3R_282()) return true;
    return false;
  }

  private boolean jj_3R_379()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_259()
 {
    if (jj_3R_281()) return true;
    return false;
  }

  private boolean jj_3R_258()
 {
    if (jj_3R_280()) return true;
    return false;
  }

  private boolean jj_3R_364()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_379()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_257()
 {
    if (jj_3R_279()) return true;
    return false;
  }

  private boolean jj_3R_172()
 {
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_256()
 {
    if (jj_3R_278()) return true;
    return false;
  }

  private boolean jj_3R_287()
 {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_171()
 {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_102()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) return true;
    }
    return false;
  }

  private boolean jj_3R_255()
 {
    if (jj_3R_277()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_scan_token(LT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_254()
 {
    if (jj_3R_276()) return true;
    return false;
  }

  private boolean jj_3R_253()
 {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_252()
 {
    if (jj_3R_275()) return true;
    return false;
  }

  private boolean jj_3R_365()
 {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3_26()
 {
    if (jj_3R_99()) return true;
    return false;
  }

  private boolean jj_3_39()
 {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_344()
 {
    if (jj_3R_364()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_365()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_240()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_39()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) {
    jj_scanpos = xsp;
    if (jj_3R_258()) {
    jj_scanpos = xsp;
    if (jj_3R_259()) {
    jj_scanpos = xsp;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) {
    jj_scanpos = xsp;
    if (jj_3R_264()) {
    jj_scanpos = xsp;
    if (jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_393()
 {
    if (jj_3R_406()) return true;
    return false;
  }

  private boolean jj_3R_167()
 {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_392()
 {
    if (jj_3R_405()) return true;
    return false;
  }

  private boolean jj_3R_166()
 {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_142()
 {
    if (jj_scan_token(_EOF)) return true;
    return false;
  }

  private boolean jj_3R_165()
 {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3R_404()
 {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_141()
 {
    if (jj_scan_token(_TOKEN_MGR_DECLS)) return true;
    return false;
  }

  private boolean jj_3R_164()
 {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_403()
 {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_286()
 {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_140()
 {
    if (jj_scan_token(_SKIP)) return true;
    return false;
  }

  private boolean jj_3R_84()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_163()
 {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3R_345()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_344()) return true;
    return false;
  }

  private boolean jj_3R_391()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_403()) {
    jj_scanpos = xsp;
    if (jj_3R_404()) return true;
    }
    if (jj_3R_351()) return true;
    return false;
  }

  private boolean jj_3R_139()
 {
    if (jj_scan_token(_MORE)) return true;
    return false;
  }

  private boolean jj_3R_162()
 {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  private boolean jj_3R_382()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_391()) {
    jj_scanpos = xsp;
    if (jj_3R_392()) {
    jj_scanpos = xsp;
    if (jj_3R_393()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_329()
 {
    if (jj_3R_83()) return true;
    if (jj_3R_344()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_345()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_138()
 {
    if (jj_scan_token(_SPECIAL_TOKEN)) return true;
    return false;
  }

  private boolean jj_3R_161()
 {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_137()
 {
    if (jj_scan_token(_TOKEN)) return true;
    return false;
  }

  private boolean jj_3R_160()
 {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3R_100()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_136()
 {
    if (jj_scan_token(_JAVACODE)) return true;
    return false;
  }

  private boolean jj_3R_135()
 {
    if (jj_scan_token(_PARSER_END)) return true;
    return false;
  }

  private boolean jj_3R_272()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_417()
 {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_134()
 {
    if (jj_scan_token(_PARSER_BEGIN)) return true;
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_3R_83()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_84()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_247()
 {
    Token xsp;
    if (jj_3R_272()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_272()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_191()) return true;
    return false;
  }

  private boolean jj_3R_82()
 {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_311()
 {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_306()
 {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_133()
 {
    if (jj_scan_token(_IGNORE_CASE)) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_321()
 {
    if (jj_3R_330()) return true;
    return false;
  }

  private boolean jj_3R_132()
 {
    if (jj_scan_token(_LOOKAHEAD)) return true;
    return false;
  }

  private boolean jj_3R_66()
 {
    if (jj_3R_62()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_320()
 {
    if (jj_3R_329()) return true;
    return false;
  }

  private boolean jj_3R_131()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_37()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_285()
 {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_417()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_319()
 {
    if (jj_3R_328()) return true;
    return false;
  }

  private boolean jj_3R_318()
 {
    if (jj_3R_327()) return true;
    return false;
  }

  private boolean jj_3R_305()
 {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_93()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_3R_63()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_317()
 {
    if (jj_3R_326()) return true;
    return false;
  }

  private boolean jj_3R_313()
 {
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_316()
 {
    if (jj_3R_241()) return true;
    return false;
  }

  private boolean jj_3_36()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_370()
 {
    if (jj_3R_382()) return true;
    return false;
  }

  private boolean jj_3R_312()
 {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_416()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_369()
 {
    if (jj_3R_306()) return true;
    return false;
  }

  private boolean jj_3R_304()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_312()) {
    jj_scanpos = xsp;
    if (jj_3R_313()) return true;
    }
    return false;
  }

  private boolean jj_3_38()
 {
    Token xsp;
    if (jj_3_36()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_36()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_37()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_65()
 {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_368()
 {
    if (jj_3R_305()) return true;
    return false;
  }

  private boolean jj_3R_310()
 {
    if (jj_3R_118()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_316()) {
    jj_scanpos = xsp;
    if (jj_3R_317()) {
    jj_scanpos = xsp;
    if (jj_3R_318()) {
    jj_scanpos = xsp;
    if (jj_3R_319()) {
    jj_scanpos = xsp;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_233()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_38()) {
    jj_scanpos = xsp;
    if (jj_3R_247()) return true;
    }
    return false;
  }

  private boolean jj_3R_284()
 {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_416()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_381()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_380()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_303()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) {
    jj_scanpos = xsp;
    if (jj_3R_311()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_62()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_295()
 {
    if (jj_3R_304()) return true;
    return false;
  }

  private boolean jj_3R_367()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_380()) {
    jj_scanpos = xsp;
    if (jj_3R_381()) return true;
    }
    if (jj_3R_351()) return true;
    return false;
  }

  private boolean jj_3R_351()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_367()) {
    jj_scanpos = xsp;
    if (jj_3R_368()) {
    jj_scanpos = xsp;
    if (jj_3R_369()) {
    jj_scanpos = xsp;
    if (jj_3R_370()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_415()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_64()
 {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_195()
 {
    if (jj_scan_token(HOOK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_295()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_194()
 {
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_283()
 {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_415()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_130()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) return true;
    }
    return false;
  }

  private boolean jj_3R_63()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_248()
 {
    if (jj_3R_273()) return true;
    return false;
  }

  private boolean jj_3R_434()
 {
    if (jj_3R_439()) return true;
    return false;
  }

  private boolean jj_3R_236()
 {
    if (jj_3R_127()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_248()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_396()
 {
    if (jj_scan_token(REM)) return true;
    return false;
  }

  private boolean jj_3R_235()
 {
    if (jj_3R_233()) return true;
    return false;
  }

  private boolean jj_3R_395()
 {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3R_294()
 {
    if (jj_3R_303()) return true;
    return false;
  }

  private boolean jj_3R_394()
 {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_249()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_130()) return true;
    return false;
  }

  private boolean jj_3R_234()
 {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_440()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_383()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_394()) {
    jj_scanpos = xsp;
    if (jj_3R_395()) {
    jj_scanpos = xsp;
    if (jj_3R_396()) return true;
    }
    }
    if (jj_3R_351()) return true;
    return false;
  }

  private boolean jj_3R_273()
 {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_294()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_92()
 {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_130()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_249()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_439()
 {
    if (jj_3R_277()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_440()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_331()
 {
    if (jj_3R_351()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_383()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_173()
 {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_193()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_234()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) return true;
    }
    return false;
  }

  private boolean jj_3_43()
 {
    if (jj_3R_106()) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_35()
 {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_100()) return true;
    if (jj_3R_233()) return true;
    return false;
  }

  private boolean jj_3R_438()
 {
    if (jj_3R_439()) return true;
    return false;
  }

  private boolean jj_3R_103()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) return true;
    }
    return false;
  }

  private boolean jj_3R_437()
 {
    if (jj_3R_239()) return true;
    return false;
  }

  private boolean jj_3R_274()
 {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3_20()
 {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_433()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_437()) {
    jj_scanpos = xsp;
    if (jj_3R_438()) return true;
    }
    return false;
  }

  private boolean jj_3R_238()
 {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  private boolean jj_3R_385()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_384()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_225()
 {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_193()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_238()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_19()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_371()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_384()) {
    jj_scanpos = xsp;
    if (jj_3R_385()) return true;
    }
    if (jj_3R_331()) return true;
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_426()
 {
    if (jj_3R_434()) return true;
    return false;
  }

  private boolean jj_3R_322()
 {
    if (jj_3R_331()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_371()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_193()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_425()
 {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_211()
 {
    if (jj_3R_225()) return true;
    return false;
  }

  private boolean jj_3R_242()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_156()
 {
    return false;
  }

  private boolean jj_3R_188()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_211()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_213()
 {
    if (jj_3R_95()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_242()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_424()
 {
    if (jj_3R_433()) return true;
    return false;
  }

  private boolean jj_3R_414()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_424()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_425()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_426()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_97()
 {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == GT && ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_156()) return true;
    if (jj_scan_token(RUNSIGNEDSHIFT)) return true;
    return false;
  }

  private boolean jj_3_42()
 {
    if (jj_3R_106()) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_157()
 {
    return false;
  }

  private boolean jj_3R_251()
 {
    if (jj_3R_274()) return true;
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_189()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3R_413()
 {
    if (jj_3R_106()) return true;
    if (jj_3R_83()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_98()
 {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == GT && ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_157()) return true;
    if (jj_scan_token(RSIGNEDSHIFT)) return true;
    return false;
  }

  private boolean jj_3R_250()
 {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_129()
 {
    if (jj_3R_193()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_17()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_119()
 {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_188()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_189()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_237()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_250()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACKET)) return true;
    xsp = jj_scanpos;
    if (jj_3R_251()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_192()
 {
    if (jj_3R_213()) return true;
    return false;
  }

  private boolean jj_3R_282()
 {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_413()) {
    jj_scanpos = xsp;
    if (jj_3R_414()) return true;
    }
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_240()) return true;
    return false;
  }

  private boolean jj_3_16()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_25()
 {
    if (jj_3R_98()) return true;
    return false;
  }

  private boolean jj_3R_127()
 {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_128()
 {
    if (jj_3R_100()) return true;
    Token xsp;
    if (jj_3_16()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_16()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_24()
 {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_387()
 {
    if (jj_3R_273()) return true;
    return false;
  }

  private boolean jj_3R_91()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) return true;
    }
    return false;
  }

  private boolean jj_3R_96()
 {
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_386()
 {
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3R_81()
 {
    if (jj_3R_118()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_386()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_387()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_23()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3_25()) return true;
    }
    }
    if (jj_3R_322()) return true;
    return false;
  }

  private boolean jj_3R_314()
 {
    if (jj_3R_322()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_231()
 {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_120()
 {
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_374()
 {
    if (jj_3R_303()) return true;
    return false;
  }

  private boolean jj_3_15()
 {
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_83()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) return true;
    }
    return false;
  }

  private boolean jj_3R_113()
 {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_355()
 {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_281()
 {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_240()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_360()
 {
    if (jj_scan_token(SEMICOLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_374()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_354()
 {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_359()
 {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_353()
 {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_121()
 {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_352()
 {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_85()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_121()) jj_scanpos = xsp;
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_245()
 {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_332()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_352()) {
    jj_scanpos = xsp;
    if (jj_3R_353()) {
    jj_scanpos = xsp;
    if (jj_3R_354()) {
    jj_scanpos = xsp;
    if (jj_3R_355()) return true;
    }
    }
    }
    if (jj_3R_314()) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_244()
 {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_307()
 {
    if (jj_3R_314()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_332()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_230()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) {
    jj_scanpos = xsp;
    if (jj_3R_245()) return true;
    }
    return false;
  }

  private boolean jj_3R_358()
 {
    if (jj_3R_81()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_8()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_280()
 {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_240()) return true;
    return false;
  }

  private boolean jj_3R_337()
 {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_358()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_359()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_360()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_125()
 {
    if (jj_3R_62()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_127()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_323()
 {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_412()
 {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_240()) return true;
    return false;
  }

  private boolean jj_3R_90()
 {
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_127()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_299()
 {
    if (jj_3R_307()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_323()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_224()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_223()
 {
    if (jj_3R_237()) return true;
    return false;
  }

  private boolean jj_3R_220()
 {
    if (jj_3R_231()) return true;
    return false;
  }

  private boolean jj_3R_336()
 {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_219()
 {
    if (jj_3R_230()) return true;
    return false;
  }

  private boolean jj_3R_279()
 {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_240()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_412()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_89()
 {
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_127()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_218()
 {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_326()
 {
    if (jj_scan_token(ENUM)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_336()) jj_scanpos = xsp;
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_217()
 {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_420()
 {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_325()
 {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_222()
 {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_216()
 {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_324()
 {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_215()
 {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_221()
 {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_206()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_126()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_315()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) return true;
    }
    if (jj_3R_299()) return true;
    return false;
  }

  private boolean jj_3R_207()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_389()
 {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_402()
 {
    if (jj_3R_329()) return true;
    return false;
  }

  private boolean jj_3R_289()
 {
    if (jj_3R_299()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_315()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_401()
 {
    if (jj_3R_327()) return true;
    return false;
  }

  private boolean jj_3R_88()
 {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_91()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_126()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_400()
 {
    if (jj_3R_326()) return true;
    return false;
  }

  private boolean jj_3R_432()
 {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_373()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  private boolean jj_3R_399()
 {
    if (jj_3R_241()) return true;
    return false;
  }

  private boolean jj_3_14()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_88()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    }
    return false;
  }

  private boolean jj_3R_357()
 {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_193()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_373()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_170()
 {
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3R_407()
 {
    if (jj_3R_420()) return true;
    return false;
  }

  private boolean jj_3R_87()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    }
    return false;
  }

  private boolean jj_3R_431()
 {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_422()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_431()) {
    jj_scanpos = xsp;
    if (jj_3R_432()) return true;
    }
    return false;
  }

  private boolean jj_3_47()
 {
    if (jj_3R_83()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_169()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_309()
 {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_289()) return true;
    return false;
  }

  private boolean jj_3R_269()
 {
    if (jj_3R_289()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_309()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_398()
 {
    if (jj_3R_83()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_407()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_168()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_95()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_34()
 {
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_388()
 {
    if (jj_3R_118()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_398()) {
    jj_scanpos = xsp;
    if (jj_3R_399()) {
    jj_scanpos = xsp;
    if (jj_3R_400()) {
    jj_scanpos = xsp;
    if (jj_3R_401()) {
    jj_scanpos = xsp;
    if (jj_3R_402()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_372()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  private boolean jj_3R_375()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_388()) {
    jj_scanpos = xsp;
    if (jj_3R_389()) return true;
    }
    return false;
  }

  private boolean jj_3_33()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_423()
 {
    if (jj_3R_212()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public JTBParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[182];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	   jj_la1_init_3();
	   jj_la1_init_4();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0xa00007e0,0x6,0x6,0x0,0xa00007e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe,0x0,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0xa8000000,0x0,0x0,0x0,0x0,0x0,0x0,0xa8000000,0x0,0xa0000000,0xa8000000,0x0,0x0,0x0,0xa0000ffe,0xa0000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0xa8000000,0x0,0x0,0x0,0xf0000ffe,0x0,0x0,0x0,0xa0000ffe,0x0,0xa0000000,0xa0000000,0x0,0x0,0xa0000000,0x0,0xa0000000,0xa0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0000ffe,0x0,0x0,0xa0000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0xffe,0x0,0x0,0x0,0xa0000ffe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0000ffe,0x0,0xf0000ffe,0xf0000ffe,0x0,0x0,0x0,0x0,0xa0000ffe,0x0,0xf0000ffe,0x0,0x0,0xa0000ffe,0xa0000ffe,0xa0000ffe,0xa0000ffe,0xa0000ffe,0x0,0x0,0x0,0xa0000ffe,0x0,0x0,0x0,0x0,0x0,0xa0000ffe,0x0,0xa8000000,0x0,0xa0000000,0xa8000000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0xe140a104,0x0,0x0,0x1000,0xe140a104,0x0,0x0,0x0,0x0,0x0,0x0,0xe0002000,0xe0002000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x100000,0xe2802408,0x0,0x0,0xe2002000,0x800408,0xe2802408,0x800008,0x0,0x800,0x80000,0x0,0x0,0x80000,0xe2002000,0x0,0xe3c0a50c,0x0,0x0,0x0,0x0,0x800,0x0,0xe3c0a50c,0x800408,0x1408104,0xe3c0a50c,0x0,0x0,0x0,0xd409104,0xd409104,0x0,0x0,0x0,0x0,0x0,0x0,0xe340a104,0x0,0x0,0x0,0xdc5b1ac,0x0,0x0,0x0,0xd409104,0x0,0x1408104,0x1408104,0x0,0x800,0x1408104,0x800,0x1408104,0x1408104,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd409104,0x0,0x0,0xd409104,0xc001000,0x0,0x0,0x0,0x0,0xc001000,0x0,0x0,0x8001000,0x1000,0xd409104,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0xd4591a4,0x0,0xdc5b1ac,0xdc591ac,0x0,0x2000,0x0,0x0,0xd409104,0x41,0xdc5b1ac,0x41,0x200,0xd40b104,0xd409104,0xd409104,0xd40b104,0xd409104,0x0,0x0,0x0,0xd409104,0x2,0x4000,0x0,0x0,0x0,0xd409104,0x0,0xe3c0a50c,0x40,0x1c0850c,0xe3c0a50c,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x2002,0x4,0x4,0x90800,0x2002,0x0,0x200,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x80000,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x80000,0x10000,0x0,0x0,0x0,0x80000,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x444c,0x4,0x0,0x444c,0x0,0x444c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x444c,0x0,0x644e,0x0,0x0,0x0,0x0,0x0,0x0,0x644e,0x0,0x2002,0x644e,0x0,0x0,0x0,0xf2892,0xf2892,0x0,0x0,0x200,0x0,0x0,0x0,0x444e,0x0,0x0,0x200,0xfb9f3,0x0,0x0,0x90,0xf2892,0x4,0x2,0x2,0x0,0x10,0x2,0x10,0x2,0x2002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf2892,0x0,0x0,0xf2892,0xf0890,0x0,0x0,0x0,0x0,0xf0890,0x0,0x0,0xf0800,0x800,0xf2892,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb9f3,0x0,0xfb9f3,0xfb9f3,0x0,0x0,0x0,0x0,0xf2892,0x0,0xfb9f3,0x0,0x0,0xf2892,0xf2892,0xf2892,0xf2892,0xf2892,0x0,0x0,0x0,0xf2892,0x0,0x0,0x0,0x0,0x0,0xf2892,0x0,0x444e,0x0,0x2,0x444e,};
	}
	private static void jj_la1_init_3() {
	   jj_la1_3 = new int[] {0x1000,0x0,0x0,0x0,0x1000,0x200,0x0,0x0,0x200,0x0,0x2000,0x0,0x0,0x200,0x1000,0x1000,0x40,0x40000000,0x0,0x2000,0x10,0x10000,0x40000000,0x0,0x0,0x2000,0x400,0x2000,0x1000,0xa008000,0xa008000,0x50,0x4,0x0,0x0,0x0,0x0,0x0,0x1000,0x40000000,0x5044,0x0,0x200,0xa008010,0xa008010,0x5044,0x4000,0x200,0x0,0x4000000,0x0,0x0,0x0,0x100,0x0,0x400,0x0,0x0,0x100,0x0,0x1000,0x0,0x0,0x200,0x200,0x0,0x0,0x200,0x1110,0x100,0x4,0x10,0x200,0x0,0x20000000,0x1110,0x0,0x1000,0x1100,0x200,0x800,0x40,0x7806014,0x7806014,0x200,0x1000,0x0,0x110,0x40,0x200,0x0,0x0,0x1000,0x0,0x1800114,0x200,0x1000,0x0,0x4,0x0,0x0,0x0,0x200,0x0,0x8000,0x0,0x0,0x0,0x200,0x800,0x8000,0x200000,0x400000,0x40000000,0x80000000,0x20000000,0x120000,0x120000,0x0,0xc1000,0xc1000,0x0,0x6000000,0x6000000,0x18000000,0x18000000,0x6000000,0x7806004,0x6000,0x6000,0x4,0x6004,0x4,0x1800000,0x1800000,0x4,0x4,0x0,0x444,0x0,0x0,0x7806004,0x200,0x1000,0x10,0x44,0x0,0x40,0x40,0x1800114,0x10000,0x1800114,0x1800114,0x200,0x0,0x1800800,0x1800800,0x1800004,0x0,0x1800114,0x0,0x0,0x1800004,0x7806004,0x1800004,0x1800104,0x1800004,0x200,0x0,0x0,0x7806004,0x0,0x0,0x0,0x0,0x200,0x7806014,0x200,0x100,0x0,0x0,0x100,};
	}
	private static void jj_la1_init_4() {
	   jj_la1_4 = new int[] {0x100000,0x100000,0x100000,0x0,0x100000,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x102000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x80000,0x0,0x0,0x80000,0x80000,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x180000,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x80000,0x100000,0x180000,0x0,0x0,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x4000,0x0,0x0,0x180000,0x0,0x0,0x0,0x100000,0x0,0x0,0x100000,0x0,0x0,0x100000,0x0,0x0,0x100000,0x0,0x381fe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x40000,0x0,0x0,0x1,0x1,0x0,0x100000,0x0,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x180000,0x100000,0x0,0x80000,0x381fe,0x381fe,0x100000,0x0,0x180000,0x0,0x0,0x180000,0x100000,0x100000,0x180000,0x100000,0x0,0x100000,0x100000,0x100000,0x0,0x0,0x80000,0x100000,0x0,0x180000,0x0,0x180000,0x0,0x180000,0x180000,};
	}
  final private JJCalls[] jj_2_rtns = new JJCalls[47];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public JTBParser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public JTBParser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new JTBParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 182; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 182; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public JTBParser(java.io.Reader stream) {
	 jj_input_stream = new JavaCharStream(stream, 1, 1);
	 token_source = new JTBParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 182; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new JavaCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new JTBParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 182; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public JTBParser(JTBParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 182; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(JTBParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 182; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = jj_lookingAhead ? jj_scanpos : token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[151];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 182; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		   if ((jj_la1_3[i] & (1<<j)) != 0) {
			 la1tokens[96+j] = true;
		   }
		   if ((jj_la1_4[i] & (1<<j)) != 0) {
			 la1tokens[128+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 151; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 47; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			   case 6: jj_3_7(); break;
			   case 7: jj_3_8(); break;
			   case 8: jj_3_9(); break;
			   case 9: jj_3_10(); break;
			   case 10: jj_3_11(); break;
			   case 11: jj_3_12(); break;
			   case 12: jj_3_13(); break;
			   case 13: jj_3_14(); break;
			   case 14: jj_3_15(); break;
			   case 15: jj_3_16(); break;
			   case 16: jj_3_17(); break;
			   case 17: jj_3_18(); break;
			   case 18: jj_3_19(); break;
			   case 19: jj_3_20(); break;
			   case 20: jj_3_21(); break;
			   case 21: jj_3_22(); break;
			   case 22: jj_3_23(); break;
			   case 23: jj_3_24(); break;
			   case 24: jj_3_25(); break;
			   case 25: jj_3_26(); break;
			   case 26: jj_3_27(); break;
			   case 27: jj_3_28(); break;
			   case 28: jj_3_29(); break;
			   case 29: jj_3_30(); break;
			   case 30: jj_3_31(); break;
			   case 31: jj_3_32(); break;
			   case 32: jj_3_33(); break;
			   case 33: jj_3_34(); break;
			   case 34: jj_3_35(); break;
			   case 35: jj_3_36(); break;
			   case 36: jj_3_37(); break;
			   case 37: jj_3_38(); break;
			   case 38: jj_3_39(); break;
			   case 39: jj_3_40(); break;
			   case 40: jj_3_41(); break;
			   case 41: jj_3_42(); break;
			   case 42: jj_3_43(); break;
			   case 43: jj_3_44(); break;
			   case 44: jj_3_45(); break;
			   case 45: jj_3_46(); break;
			   case 46: jj_3_47(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}

class JTBToolkit {

  static NodeToken makeNodeToken(final Token tok) {
    final NodeToken node = new NodeToken(tok.image.intern(), tok.kind, tok.beginLine, tok.beginColumn, tok.endLine, tok.endColumn);
    if (tok.specialToken == null)
      return node;
    Token t = tok;
    int nbt = 0;
    while (t.specialToken != null) {
      t = t.specialToken;
      nbt++;
    }
    final java.util.ArrayList<NodeToken> temp = new java.util.ArrayList<NodeToken>(nbt);
    t = tok;
    while (t.specialToken != null) {
      t = t.specialToken;
      temp.add(new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn));
    }
    for (int i = nbt - 1; i >= 0; --i)
      node.addSpecial(temp.get(i));
    // node.trimSpecials();
    return node;
  }
}

// ModMMa : adapted from JavaCC.jj to fit to JTB parser name

